<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>33.给线程池增加自动扩充线程数量，以及闲时自动回收的功能</title>
    <link href="/juc-actualCombat-1-33.html"/>
    <url>/juc-actualCombat-1-33.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><p class="note note-primary">前言</p></h1><p class="note note-info">对于前面2个章节实现的线程池还是存在问题，假设对它的<code>size</code>设置为2000，那么就会创建对应的线程，对于一些情况没有任务或者任务比较少的时候就可以关闭几个认为的。这里就来实现一下</p><h1 id="增加线程"><a href="#增加线程" class="headerlink" title="增加线程"></a><p class="note note-primary">增加线程</p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 17:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;  <span class="hljs-comment">/** 默认拒绝策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DiscardPolicy DEFAULT_DISCARD_POLICY =      () -&gt; &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DiscardException(<span class="hljs-string">"放弃此任务"</span>);      &#125;;  <span class="hljs-comment">/** 默认任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="hljs-number">2000</span>;  <span class="hljs-comment">/*任务队列*/</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">/** 前缀 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THREAD_PREFIX = <span class="hljs-string">"SIMPLE_THREAD_POOL-"</span>;  <span class="hljs-comment">/** 线程队列 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;WorkTask&gt; THREAD_QUEUE = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">/** 组 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"Pool_Group"</span>);  <span class="hljs-comment">/** 自增ID */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> seg;  <span class="hljs-comment">/** 拒绝策略 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DiscardPolicy discardPolicy;  <span class="hljs-comment">/** 任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> queueSize;  <span class="hljs-comment">/** 激活线程数 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> active;  <span class="hljs-comment">/** 是否销毁 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> destroy = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">/** 最大线程数 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> max;  <span class="hljs-comment">/** 最小线程数 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> min;  <span class="hljs-comment">/** 大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> min 最小线程数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> active 激活线程数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> max 最大线程数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> queueSize 任务队列大小限制</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">      <span class="hljs-keyword">int</span> min, <span class="hljs-keyword">int</span> active, <span class="hljs-keyword">int</span> max, <span class="hljs-keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>&#123;    <span class="hljs-keyword">this</span>.min = min;    <span class="hljs-keyword">this</span>.active = active;    <span class="hljs-keyword">this</span>.max = max;    <span class="hljs-keyword">this</span>.queueSize = queueSize;    <span class="hljs-keyword">this</span>.discardPolicy = discardPolicy;    init();  &#125;  <span class="hljs-comment">/** 初始化 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.min; i++) &#123;      createWorkTask();    &#125;    <span class="hljs-keyword">this</span>.size = min;    <span class="hljs-comment">// 启动自己</span>    <span class="hljs-keyword">this</span>.start();  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWorkTask</span><span class="hljs-params">()</span> </span>&#123;    WorkTask workTask = <span class="hljs-keyword">new</span> WorkTask(group, THREAD_PREFIX + (seg++));    workTask.start();    THREAD_QUEUE.add(workTask);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getActive</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> active;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> max;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> min;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueueSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> queueSize;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> size;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDestroy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.destroy;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (!destroy) &#123;      System.out.printf(          <span class="hljs-string">"Pool#Min:%d，Active：%d,Max:%d,Current：%d,TaskQueueSize：%d\n"</span>,          <span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.active, <span class="hljs-keyword">this</span>.max, <span class="hljs-keyword">this</span>.size, TASK_QUEUE.size());      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">5_000</span>);        <span class="hljs-comment">// 如果任务过多，小于active ，并且 当前线程数量小于</span>        <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; active &amp;&amp; size &lt; active) &#123;          <span class="hljs-comment">// 偏移量初始从 当前线程大小开始，创建到active个线程</span>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; active; i++) &#123;            createWorkTask();          &#125;          System.out.println(<span class="hljs-string">"The pool increment to active."</span>);          size = active;        &#125;        <span class="hljs-comment">// 如果任务超过MAX，线程创建到Max个线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; max &amp;&amp; size &lt; max) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; max; i++) &#123;            createWorkTask();          &#125;          System.out.println(<span class="hljs-string">"The pool increment to max."</span>);          size = max;        &#125;      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;  <span class="hljs-comment">/** 关闭，任务如果还没执行完，等待完成，在关闭，如果没有认为了直接关闭 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (!TASK_QUEUE.isEmpty()) &#123;      Thread.sleep(<span class="hljs-number">50</span>);    &#125;    <span class="hljs-comment">// 在代码执行到这一步之后，在 TASK_QUEUE 已经没有 任务了，但是这个时候 有可能又提交了一个任务去运行，所以并不代表你都可以把它关掉</span>    <span class="hljs-keyword">int</span> initVal = TASK_QUEUE.size();    <span class="hljs-keyword">while</span> (initVal &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">for</span> (WorkTask task : THREAD_QUEUE) &#123;        <span class="hljs-comment">// 如果任务是空的，线程自然是block，这个时候</span>        <span class="hljs-keyword">if</span> (task.getState() == Thread.State.BLOCKED) &#123;          <span class="hljs-comment">// 这个时候线程的生命周期结束</span>          task.interrupt();          <span class="hljs-comment">// 另外一个情况：在线程刚刚执行完任务的时候，调用中断是无效的，下次又会去 Block住l.这里把线程设置为 DEAD，它就能结束线程生命周期了</span>          task.close();          <span class="hljs-comment">// 关闭一个 “--”一个</span>          initVal--;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 如果没有关掉，就休息一下</span>          Thread.sleep(<span class="hljs-number">10</span>);        &#125;      &#125;    &#125;    <span class="hljs-comment">// 标识已经销毁</span>    <span class="hljs-keyword">this</span>.destroy = <span class="hljs-keyword">true</span>;    System.out.println(<span class="hljs-string">"线程池已处置。"</span>);  &#125;  <span class="hljs-comment">/** 提交任务 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;    <span class="hljs-keyword">if</span> (destroy) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"线程池已经销毁，不允许添加任务!"</span>);    &#125;    <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;      <span class="hljs-comment">// 如果超出任务限制，执行拒绝策略</span>      <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; queueSize) &#123;        discardPolicy.discard();      &#125;      TASK_QUEUE.addLast(runnable);      TASK_QUEUE.notifyAll();    &#125;  &#125;  <span class="hljs-comment">/** 状态 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> TaskSate &#123;    <span class="hljs-comment">/** 空闲 */</span>    FREE,    <span class="hljs-comment">/** 运行 */</span>    RUNNING,    <span class="hljs-comment">/** 阻塞 */</span>    BLOCKED,    <span class="hljs-comment">/** 挂 */</span>    DEAD  &#125;  <span class="hljs-comment">/** 拒接策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscardPolicy</span> </span>&#123;    <span class="hljs-comment">/** 拒绝 */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">discard</span><span class="hljs-params">()</span></span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardException</span><span class="hljs-params">(String message)</span> </span>&#123;      <span class="hljs-keyword">super</span>(message);    &#125;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">/** 线程状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> TaskSate taskSate = TaskSate.FREE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkTask</span><span class="hljs-params">(ThreadGroup group, String name)</span> </span>&#123;      <span class="hljs-keyword">super</span>(group, name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.taskSate = TaskSate.DEAD;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskSate <span class="hljs-title">getTaskSate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> taskSate;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      OUTER:      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.taskSate != TaskSate.DEAD) &#123;        Runnable runnable;        <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;          <span class="hljs-keyword">while</span> (TASK_QUEUE.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;              taskSate = TaskSate.BLOCKED;              TASK_QUEUE.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-keyword">break</span> OUTER;            &#125;          &#125;          runnable = TASK_QUEUE.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (runnable != <span class="hljs-keyword">null</span>) &#123;          taskSate = TaskSate.RUNNING;          runnable.run();          taskSate = TaskSate.FREE;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.stream.IntStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 19:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    SimpleThreadPool simpleThreadPool = <span class="hljs-keyword">new</span> SimpleThreadPool();    IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)        .forEach(            i -&gt;                simpleThreadPool.submit(                    () -&gt; &#123;                      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行中...,返回结果："</span> + i);                      <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">50_000</span>);                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                      &#125;                    &#125;));  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">4</span>,TaskQueueSize：<span class="hljs-number">0</span>SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...,返回结果：<span class="hljs-number">3</span>SIMPLE_THREAD_POOL<span class="hljs-number">-3</span>执行中...,返回结果：<span class="hljs-number">0</span>SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...,返回结果：<span class="hljs-number">2</span>SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...,返回结果：<span class="hljs-number">1</span>The pool increment to active.Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">8</span>,TaskQueueSize：<span class="hljs-number">36</span>SIMPLE_THREAD_POOL<span class="hljs-number">-5</span>执行中...,返回结果：<span class="hljs-number">7</span>SIMPLE_THREAD_POOL<span class="hljs-number">-6</span>执行中...,返回结果：<span class="hljs-number">6</span>SIMPLE_THREAD_POOL<span class="hljs-number">-7</span>执行中...,返回结果：<span class="hljs-number">5</span>SIMPLE_THREAD_POOL<span class="hljs-number">-4</span>执行中...,返回结果：<span class="hljs-number">4</span>The pool increment to max.Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">12</span>,TaskQueueSize：<span class="hljs-number">32</span>SIMPLE_THREAD_POOL<span class="hljs-number">-11</span>执行中...,返回结果：<span class="hljs-number">11</span>SIMPLE_THREAD_POOL<span class="hljs-number">-10</span>执行中...,返回结果：<span class="hljs-number">10</span>SIMPLE_THREAD_POOL<span class="hljs-number">-9</span>执行中...,返回结果：<span class="hljs-number">9</span>SIMPLE_THREAD_POOL<span class="hljs-number">-8</span>执行中...,返回结果：<span class="hljs-number">8</span>Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">12</span>,TaskQueueSize：<span class="hljs-number">28</span>...</code></pre><h1 id="回收线程"><a href="#回收线程" class="headerlink" title="回收线程"></a><p class="note note-primary">回收线程</p></h1><p class="note note-info">对于任务都处理完了，这个时候线程还是12个，这里避免耗费不必要的资源，需要进行回收</p><pre><code class="hljs java"> <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">while</span> (!destroy) &#123;    System.out.printf(        <span class="hljs-string">"Pool#Min:%d，Active：%d,Max:%d,Current：%d,TaskQueueSize：%d\n"</span>,        <span class="hljs-keyword">this</span>.min, <span class="hljs-keyword">this</span>.active, <span class="hljs-keyword">this</span>.max, <span class="hljs-keyword">this</span>.size, TASK_QUEUE.size());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">5_000</span>);      <span class="hljs-comment">// 如果任务过多，小于active ，并且 当前线程数量小于</span>      <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; active &amp;&amp; size &lt; active) &#123;        <span class="hljs-comment">// 偏移量初始从 当前线程大小开始，创建到active个线程</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; active; i++) &#123;          createWorkTask();        &#125;        System.out.println(<span class="hljs-string">"The pool increment to active."</span>);        size = active;      &#125;      <span class="hljs-comment">// 如果任务超过MAX，线程创建到Max个线程</span>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; max &amp;&amp; size &lt; max) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &lt; max; i++) &#123;          createWorkTask();        &#125;        System.out.println(<span class="hljs-string">"The pool increment to max."</span>);        size = max;      &#125;      <span class="hljs-comment">// 如果 任务空闲了 &amp;&amp; 当前线程大小大于  active，就回收线程到 active 个</span>      <span class="hljs-keyword">synchronized</span> (THREAD_QUEUE) &#123;        <span class="hljs-keyword">if</span> (TASK_QUEUE.isEmpty() &amp;&amp; size &gt; active) &#123;          System.out.println(<span class="hljs-string">"==========Reduce=========="</span>);          <span class="hljs-comment">// 释放线程个数</span>          <span class="hljs-keyword">int</span> releaseSize = size - active;          Iterator&lt;WorkTask&gt; iterator = THREAD_QUEUE.iterator();          <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;            <span class="hljs-comment">// 如果满足了释放的个数就结束掉</span>            <span class="hljs-keyword">if</span> (releaseSize &lt;= <span class="hljs-number">0</span>) &#123;              <span class="hljs-keyword">break</span>;            &#125;            WorkTask next = iterator.next();            next.close();            next.interrupt();            iterator.remove();            releaseSize--;          &#125;          size = active;        &#125;      &#125;    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;  <span class="hljs-comment">/** 关闭，任务如果还没执行完，等待完成，在关闭，如果没有认为了直接关闭 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  <span class="hljs-keyword">while</span> (!TASK_QUEUE.isEmpty()) &#123;    Thread.sleep(<span class="hljs-number">50</span>);  &#125;  <span class="hljs-comment">// 在代码执行到这一步之后，在 TASK_QUEUE 已经没有 任务了，但是这个时候 有可能又提交了一个任务去运行，所以并不代表你都可以把它关掉</span>  <span class="hljs-keyword">synchronized</span> (THREAD_QUEUE) &#123;    <span class="hljs-keyword">int</span> initVal = TASK_QUEUE.size();    <span class="hljs-keyword">while</span> (initVal &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">for</span> (WorkTask task : THREAD_QUEUE) &#123;        <span class="hljs-comment">// 如果任务是空的，线程自然是block，这个时候</span>        <span class="hljs-keyword">if</span> (task.getState() == State.BLOCKED) &#123;          <span class="hljs-comment">// 这个时候线程的生命周期结束</span>          task.interrupt();          <span class="hljs-comment">// 另外一个情况：在线程刚刚执行完任务的时候，调用中断是无效的，下次又会去 Block住l.这里把线程设置为 DEAD，它就能结束线程生命周期了</span>          task.close();          <span class="hljs-comment">// 关闭一个 “--”一个</span>          initVal--;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 如果没有关掉，就休息一下</span>          Thread.sleep(<span class="hljs-number">10</span>);        &#125;      &#125;    &#125;  &#125;  <span class="hljs-comment">// 标识已经销毁</span>  <span class="hljs-keyword">this</span>.destroy = <span class="hljs-keyword">true</span>;  System.out.println(<span class="hljs-string">"线程池已处置。"</span>);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 19:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    SimpleThreadPool simpleThreadPool = <span class="hljs-keyword">new</span> SimpleThreadPool();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;      simpleThreadPool.submit(          () -&gt; &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行中..."</span>);            <span class="hljs-keyword">try</span> &#123;              Thread.sleep(<span class="hljs-number">5_000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              e.printStackTrace();            &#125;          &#125;);    &#125;    Thread.sleep(<span class="hljs-number">210_000</span>);    simpleThreadPool.shutdown();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">4</span>,TaskQueueSize：<span class="hljs-number">5</span>SIMPLE_THREAD_POOL<span class="hljs-number">-3</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-3</span>执行中...The pool increment to active.Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">8</span>,TaskQueueSize：<span class="hljs-number">32</span>SIMPLE_THREAD_POOL<span class="hljs-number">-5</span>执行中...SIMPLE_THREAD_POOL<span class="hljs-number">-6</span>执行中......The pool increment to max.Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">12</span>,TaskQueueSize：<span class="hljs-number">16</span>SIMPLE_THREAD_POOL<span class="hljs-number">-9</span>执行中......==========Reduce==========Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">8</span>,TaskQueueSize：<span class="hljs-number">0</span>Close...Close...Close...Close...Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">8</span>,TaskQueueSize：<span class="hljs-number">0</span>Pool#Min:<span class="hljs-number">4</span>，Active：<span class="hljs-number">8</span>,Max:<span class="hljs-number">12</span>,Current：<span class="hljs-number">8</span>,TaskQueueSize：<span class="hljs-number">0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>32.给线程池增加拒绝策略以及停止方法</title>
    <link href="/juc-actualCombat-1-32.html"/>
    <url>/juc-actualCombat-1-32.html</url>
    
    <content type="html"><![CDATA[<h1 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a><p class="note note-primary">任务拒绝策略</p></h1><p class="note note-info">上一章节实现了一个简单的线程池，这个章节会加入新的东西，允许<code>TASK_QUEUE</code>它最多存多少个任务？不可能任务越来越大去挤爆你的<code>TASK_QUEUE</code>,一般来说线程池不能无限的给它提交任务。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 17:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPool</span> </span>&#123;  <span class="hljs-comment">/** 默认拒绝策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DiscardPolicy DEFAULT_DISCARD_POLICY =      () -&gt; &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DiscardException(<span class="hljs-string">"放弃此任务"</span>);      &#125;;  <span class="hljs-comment">/** 默认大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_SIZE = <span class="hljs-number">10</span>;  <span class="hljs-comment">/** 默认任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="hljs-number">2000</span>;  <span class="hljs-comment">/*任务队列*/</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">/** 前缀 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THREAD_PREFIX = <span class="hljs-string">"SIMPLE_THREAD_POOL-"</span>;  <span class="hljs-comment">/** 线程队列 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;WorkTask&gt; THREAD_QUEUE = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">/** 组 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"Pool_Group"</span>);  <span class="hljs-comment">/** 自增ID */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> seg;  <span class="hljs-comment">/** 拒绝策略 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DiscardPolicy discardPolicy;  <span class="hljs-comment">/** 任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> queueSize;  <span class="hljs-comment">/** 大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> size 线程数量</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> queueSize 任务队列大小限制</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>&#123;    <span class="hljs-keyword">this</span>.queueSize = queueSize;    <span class="hljs-keyword">this</span>.size = size;    <span class="hljs-keyword">this</span>.discardPolicy = discardPolicy;    init();  &#125;  <span class="hljs-comment">/** 初始化 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;      createWorkTask();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWorkTask</span><span class="hljs-params">()</span> </span>&#123;    WorkTask workTask = <span class="hljs-keyword">new</span> WorkTask(group, THREAD_PREFIX + (seg++));    workTask.start();    THREAD_QUEUE.add(workTask);  &#125;  <span class="hljs-comment">/** 提交任务 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;      <span class="hljs-comment">// 如果超出任务限制，执行拒绝策略</span>      <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; queueSize) &#123;        discardPolicy.discard();      &#125;      TASK_QUEUE.addLast(runnable);      TASK_QUEUE.notifyAll();    &#125;  &#125;  <span class="hljs-comment">/** 状态 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> TaskSate &#123;    <span class="hljs-comment">/** 空闲 */</span>    FREE,    <span class="hljs-comment">/** 运行 */</span>    RUNNING,    <span class="hljs-comment">/** 阻塞 */</span>    BLOCKED,    <span class="hljs-comment">/** 挂 */</span>    DEAD  &#125;  <span class="hljs-comment">/** 拒接策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscardPolicy</span> </span>&#123;    <span class="hljs-comment">/** 拒绝 */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">discard</span><span class="hljs-params">()</span></span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardException</span><span class="hljs-params">(String message)</span> </span>&#123;      <span class="hljs-keyword">super</span>(message);    &#125;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">/** 线程状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> TaskSate taskSate = TaskSate.FREE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkTask</span><span class="hljs-params">(ThreadGroup group, String name)</span> </span>&#123;      <span class="hljs-keyword">super</span>(group, name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.taskSate = TaskSate.DEAD;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskSate <span class="hljs-title">getTaskSate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> taskSate;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      OUTER:      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.taskSate != TaskSate.DEAD) &#123;        Runnable runnable;        <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;          <span class="hljs-keyword">while</span> (TASK_QUEUE.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;              taskSate = TaskSate.BLOCKED;              TASK_QUEUE.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-keyword">break</span> OUTER;            &#125;          &#125;          runnable = TASK_QUEUE.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (runnable != <span class="hljs-keyword">null</span>) &#123;          taskSate = TaskSate.RUNNING;          runnable.run();          taskSate = TaskSate.FREE;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.stream.IntStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 19:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SimpleThreadPool simpleThreadPool =        <span class="hljs-keyword">new</span> SimpleThreadPool(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, SimpleThreadPool.DEFAULT_DISCARD_POLICY);    IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)        .forEach(            i -&gt;                simpleThreadPool.submit(                    () -&gt; &#123;                      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行中...,返回结果："</span> + i);                      <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">100</span>);                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                      &#125;                    &#125;));  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter13</span>.SimpleThreadPool<span class="hljs-variable">$DiscardException</span>: 放弃此任务at com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter13</span><span class="hljs-selector-class">.SimpleThreadPool</span>.lambda<span class="hljs-variable">$static</span>$<span class="hljs-number">0</span>(SimpleThreadPool<span class="hljs-selector-class">.java</span>:<span class="hljs-number">15</span>)at com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter13</span><span class="hljs-selector-class">.SimpleThreadPool</span>.submit(SimpleThreadPool<span class="hljs-selector-class">.java</span>:<span class="hljs-number">71</span>)at com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter13</span><span class="hljs-selector-class">.SimpleThreadPoolTest</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">1</span>(SimpleThreadPoolTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">16</span>)at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.Streams<span class="hljs-variable">$RangeIntSpliterator</span>.forEachRemaining(Streams<span class="hljs-selector-class">.java</span>:<span class="hljs-number">110</span>)at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.stream</span>.IntPipeline<span class="hljs-variable">$Head</span>.forEach(IntPipeline<span class="hljs-selector-class">.java</span>:<span class="hljs-number">559</span>)at com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter13</span><span class="hljs-selector-class">.SimpleThreadPoolTest</span>.main(SimpleThreadPoolTest<span class="hljs-selector-class">.java</span>:<span class="hljs-number">14</span>)SIMPLE_THREAD_POOL-<span class="hljs-number">5</span>执行中...,返回结果：<span class="hljs-number">0</span>SIMPLE_THREAD_POOL-<span class="hljs-number">0</span>执行中...,返回结果：<span class="hljs-number">5</span>SIMPLE_THREAD_POOL-<span class="hljs-number">1</span>执行中...,返回结果：<span class="hljs-number">4</span>SIMPLE_THREAD_POOL-<span class="hljs-number">2</span>执行中...,返回结果：<span class="hljs-number">3</span>SIMPLE_THREAD_POOL-<span class="hljs-number">3</span>执行中...,返回结果：<span class="hljs-number">2</span>SIMPLE_THREAD_POOL-<span class="hljs-number">4</span>执行中...,返回结果：<span class="hljs-number">1</span>SIMPLE_THREAD_POOL-<span class="hljs-number">5</span>执行中...,返回结果：<span class="hljs-number">6</span>SIMPLE_THREAD_POOL-<span class="hljs-number">0</span>执行中...,返回结果：<span class="hljs-number">11</span>SIMPLE_THREAD_POOL-<span class="hljs-number">4</span>执行中...,返回结果：<span class="hljs-number">10</span>SIMPLE_THREAD_POOL-<span class="hljs-number">2</span>执行中...,返回结果：<span class="hljs-number">9</span>SIMPLE_THREAD_POOL-<span class="hljs-number">1</span>执行中...,返回结果：<span class="hljs-number">8</span>SIMPLE_THREAD_POOL-<span class="hljs-number">3</span>执行中...,返回结果：<span class="hljs-number">7</span>SIMPLE_THREAD_POOL-<span class="hljs-number">1</span>执行中...,返回结果：<span class="hljs-number">12</span></code></pre><h1 id="停止线程池"><a href="#停止线程池" class="headerlink" title="停止线程池"></a><p class="note note-primary">停止线程池</p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 17:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPool</span> </span>&#123;  <span class="hljs-comment">/** 默认拒绝策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DiscardPolicy DEFAULT_DISCARD_POLICY =      () -&gt; &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DiscardException(<span class="hljs-string">"放弃此任务"</span>);      &#125;;  <span class="hljs-comment">/** 默认大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_SIZE = <span class="hljs-number">10</span>;  <span class="hljs-comment">/** 默认任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="hljs-number">2000</span>;  <span class="hljs-comment">/*任务队列*/</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">/** 前缀 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THREAD_PREFIX = <span class="hljs-string">"SIMPLE_THREAD_POOL-"</span>;  <span class="hljs-comment">/** 线程队列 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;WorkTask&gt; THREAD_QUEUE = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">/** 组 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"Pool_Group"</span>);  <span class="hljs-comment">/** 自增ID */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> seg;  <span class="hljs-comment">/** 拒绝策略 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DiscardPolicy discardPolicy;  <span class="hljs-comment">/** 任务队列大小限制 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> queueSize;  <span class="hljs-comment">/** 大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-comment">/** 是否销毁 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> destroy = <span class="hljs-keyword">false</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(DEFAULT_SIZE, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> size 线程数量</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> queueSize 任务队列大小限制</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>&#123;    <span class="hljs-keyword">this</span>.queueSize = queueSize;    <span class="hljs-keyword">this</span>.size = size;    <span class="hljs-keyword">this</span>.discardPolicy = discardPolicy;    init();  &#125;  <span class="hljs-comment">/** 初始化 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;      createWorkTask();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWorkTask</span><span class="hljs-params">()</span> </span>&#123;    WorkTask workTask = <span class="hljs-keyword">new</span> WorkTask(group, THREAD_PREFIX + (seg++));    workTask.start();    THREAD_QUEUE.add(workTask);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.destroy;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getQueueSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> queueSize;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> size;  &#125;  <span class="hljs-comment">/** 关闭，任务如果还没执行完，等待完成，在关闭，如果没有认为了直接关闭 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (!TASK_QUEUE.isEmpty()) &#123;      Thread.sleep(<span class="hljs-number">50</span>);    &#125;    <span class="hljs-comment">// 在代码执行到这一步之后，在 TASK_QUEUE 已经没有 任务了，但是这个时候 有可能又提交了一个任务去运行，所以并不代表你都可以把它关掉</span>    <span class="hljs-keyword">int</span> initVal = TASK_QUEUE.size();    <span class="hljs-keyword">while</span> (initVal &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-keyword">for</span> (WorkTask task : THREAD_QUEUE) &#123;        <span class="hljs-comment">// 如果任务是空的，线程自然是block，这个时候</span>        <span class="hljs-keyword">if</span> (task.getState() == Thread.State.BLOCKED) &#123;          <span class="hljs-comment">// 这个时候线程的生命周期结束</span>          task.interrupt();          <span class="hljs-comment">// 另外一个情况：在线程刚刚执行完任务的时候，调用中断是无效的，下次又会去 Block住l.这里把线程设置为 DEAD，它就能结束线程生命周期了</span>          task.close();          <span class="hljs-comment">// 关闭一个 “--”一个</span>          initVal--;        &#125; <span class="hljs-keyword">else</span> &#123;          <span class="hljs-comment">// 如果没有关掉，就休息一下</span>          Thread.sleep(<span class="hljs-number">10</span>);        &#125;      &#125;    &#125;    <span class="hljs-comment">// 标识已经销毁</span>    <span class="hljs-keyword">this</span>.destroy = <span class="hljs-keyword">true</span>;    System.out.println(<span class="hljs-string">"线程池已处置。"</span>);  &#125;  <span class="hljs-comment">/** 提交任务 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;    <span class="hljs-keyword">if</span> (destroy) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"线程池已经销毁，不允许添加任务!"</span>);    &#125;    <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;      <span class="hljs-comment">// 如果超出任务限制，执行拒绝策略</span>      <span class="hljs-keyword">if</span> (TASK_QUEUE.size() &gt; queueSize) &#123;        discardPolicy.discard();      &#125;      TASK_QUEUE.addLast(runnable);      TASK_QUEUE.notifyAll();    &#125;  &#125;  <span class="hljs-comment">/** 状态 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> TaskSate &#123;    <span class="hljs-comment">/** 空闲 */</span>    FREE,    <span class="hljs-comment">/** 运行 */</span>    RUNNING,    <span class="hljs-comment">/** 阻塞 */</span>    BLOCKED,    <span class="hljs-comment">/** 挂 */</span>    DEAD  &#125;  <span class="hljs-comment">/** 拒接策略 */</span>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DiscardPolicy</span> </span>&#123;    <span class="hljs-comment">/** 拒绝 */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">discard</span><span class="hljs-params">()</span></span>;  &#125;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardException</span><span class="hljs-params">(String message)</span> </span>&#123;      <span class="hljs-keyword">super</span>(message);    &#125;  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">/** 线程状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> TaskSate taskSate = TaskSate.FREE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkTask</span><span class="hljs-params">(ThreadGroup group, String name)</span> </span>&#123;      <span class="hljs-keyword">super</span>(group, name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.taskSate = TaskSate.DEAD;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskSate <span class="hljs-title">getTaskSate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> taskSate;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      OUTER:      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.taskSate != TaskSate.DEAD) &#123;        Runnable runnable;        <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;          <span class="hljs-keyword">while</span> (TASK_QUEUE.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;              taskSate = TaskSate.BLOCKED;              TASK_QUEUE.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-keyword">break</span> OUTER;            &#125;          &#125;          runnable = TASK_QUEUE.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (runnable != <span class="hljs-keyword">null</span>) &#123;          taskSate = TaskSate.RUNNING;          runnable.run();          taskSate = TaskSate.FREE;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.stream.IntStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 19:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    SimpleThreadPool simpleThreadPool =        <span class="hljs-keyword">new</span> SimpleThreadPool(<span class="hljs-number">6</span>, <span class="hljs-number">10</span>, SimpleThreadPool.DEFAULT_DISCARD_POLICY);    IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)        .forEach(            i -&gt;                simpleThreadPool.submit(                    () -&gt; &#123;                      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行中...,返回结果："</span> + i);                      <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">100</span>);                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                      &#125;                    &#125;));    Thread.sleep(<span class="hljs-number">10_000</span>);    simpleThreadPool.shutdown();    simpleThreadPool.submit(        () -&gt; System.out.println(<span class="hljs-string">"test"</span>));  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">SIMPLE_THREAD_POOL<span class="hljs-number">-5</span>执行中...,返回结果：<span class="hljs-number">0</span>SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...,返回结果：<span class="hljs-number">5</span>SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...,返回结果：<span class="hljs-number">3</span>SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...,返回结果：<span class="hljs-number">4</span>SIMPLE_THREAD_POOL<span class="hljs-number">-3</span>执行中...,返回结果：<span class="hljs-number">2</span>SIMPLE_THREAD_POOL<span class="hljs-number">-4</span>执行中...,返回结果：<span class="hljs-number">1</span>SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...,返回结果：<span class="hljs-number">7</span>SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...,返回结果：<span class="hljs-number">6</span>SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...,返回结果：<span class="hljs-number">8</span>SIMPLE_THREAD_POOL<span class="hljs-number">-4</span>执行中...,返回结果：<span class="hljs-number">9</span>线程池已处置。Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.IllegalStateException: 线程池已经销毁，不允许添加任务!at com.shui.juc.chapter13.SimpleThreadPool.submit(SimpleThreadPool.java:<span class="hljs-number">112</span>)at com.shui.juc.chapter13.SimpleThreadPoolTest.main(SimpleThreadPoolTest.java:<span class="hljs-number">28</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>31.自定义个简单的线程池</title>
    <link href="/juc-actualCombat-1-31.html"/>
    <url>/juc-actualCombat-1-31.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">只有代码</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 17:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPool</span> </span>&#123;  <span class="hljs-comment">/** 默认大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_SIZE = <span class="hljs-number">10</span>;  <span class="hljs-comment">/*任务队列*/</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">/** 前缀 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String THREAD_PREFIX = <span class="hljs-string">"SIMPLE_THREAD_POOL-"</span>;  <span class="hljs-comment">/** 线程队列 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> List&lt;WorkTask&gt; THREAD_QUEUE = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">/** 组 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadGroup group = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"Pool_Group"</span>);  <span class="hljs-comment">/** 自增ID */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> seg;  <span class="hljs-comment">/** 大小 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>(DEFAULT_SIZE);  &#125;  <span class="hljs-comment">/** <span class="hljs-doctag">@param</span> size 线程数量 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;    <span class="hljs-keyword">this</span>.size = size;    init();  &#125;  <span class="hljs-comment">/** 初始化 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;      createWorkTask();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createWorkTask</span><span class="hljs-params">()</span> </span>&#123;    WorkTask workTask = <span class="hljs-keyword">new</span> WorkTask(group, THREAD_PREFIX + (seg++));    workTask.start();    THREAD_QUEUE.add(workTask);  &#125;  <span class="hljs-comment">/** 提交任务 */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;      TASK_QUEUE.addLast(runnable);      TASK_QUEUE.notifyAll();    &#125;  &#125;  <span class="hljs-comment">/** 状态 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">enum</span> TaskSate &#123;    <span class="hljs-comment">/** 空闲 */</span>    FREE,    <span class="hljs-comment">/** 运行 */</span>    RUNNING,    <span class="hljs-comment">/** 阻塞 */</span>    BLOCKED,    <span class="hljs-comment">/** 挂 */</span>    DEAD  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-comment">/** 线程状态 */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> TaskSate taskSate = TaskSate.FREE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkTask</span><span class="hljs-params">(ThreadGroup group, String name)</span> </span>&#123;      <span class="hljs-keyword">super</span>(group, name);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.taskSate = TaskSate.DEAD;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskSate <span class="hljs-title">getTaskSate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> taskSate;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      OUTER:      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.taskSate != TaskSate.DEAD) &#123;        Runnable runnable;        <span class="hljs-keyword">synchronized</span> (TASK_QUEUE) &#123;          <span class="hljs-keyword">while</span> (TASK_QUEUE.isEmpty()) &#123;            <span class="hljs-keyword">try</span> &#123;              taskSate = TaskSate.BLOCKED;              TASK_QUEUE.wait();            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              <span class="hljs-keyword">break</span> OUTER;            &#125;          &#125;          runnable = TASK_QUEUE.removeFirst();        &#125;        <span class="hljs-keyword">if</span> (runnable != <span class="hljs-keyword">null</span>) &#123;          taskSate = TaskSate.RUNNING;          runnable.run();          taskSate = TaskSate.FREE;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter13;<span class="hljs-keyword">import</span> java.util.stream.IntStream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 19:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleThreadPoolTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SimpleThreadPool simpleThreadPool = <span class="hljs-keyword">new</span> SimpleThreadPool();    IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">40</span>)        .forEach(            i -&gt;                simpleThreadPool.submit(                    () -&gt; &#123;                      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"执行中...,返回结果："</span> + i);                      <span class="hljs-keyword">try</span> &#123;                        Thread.sleep(<span class="hljs-number">100</span>);                      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                      &#125;                    &#125;));  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">SIMPLE_THREAD_POOL<span class="hljs-number">-9</span>执行中...,返回结果：<span class="hljs-number">0</span>SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...,返回结果：<span class="hljs-number">9</span>SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...,返回结果：<span class="hljs-number">8</span>SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...,返回结果：<span class="hljs-number">7</span>SIMPLE_THREAD_POOL<span class="hljs-number">-7</span>执行中...,返回结果：<span class="hljs-number">2</span><span class="hljs-comment">//...</span>SIMPLE_THREAD_POOL<span class="hljs-number">-6</span>执行中...,返回结果：<span class="hljs-number">28</span>SIMPLE_THREAD_POOL<span class="hljs-number">-1</span>执行中...,返回结果：<span class="hljs-number">32</span>SIMPLE_THREAD_POOL<span class="hljs-number">-3</span>执行中...,返回结果：<span class="hljs-number">31</span>SIMPLE_THREAD_POOL<span class="hljs-number">-9</span>执行中...,返回结果：<span class="hljs-number">33</span>SIMPLE_THREAD_POOL<span class="hljs-number">-0</span>执行中...,返回结果：<span class="hljs-number">34</span>SIMPLE_THREAD_POOL<span class="hljs-number">-7</span>执行中...,返回结果：<span class="hljs-number">35</span>SIMPLE_THREAD_POOL<span class="hljs-number">-2</span>执行中...,返回结果：<span class="hljs-number">30</span>SIMPLE_THREAD_POOL<span class="hljs-number">-8</span>执行中...,返回结果：<span class="hljs-number">36</span>SIMPLE_THREAD_POOL<span class="hljs-number">-5</span>执行中...,返回结果：<span class="hljs-number">37</span>SIMPLE_THREAD_POOL<span class="hljs-number">-4</span>执行中...,返回结果：<span class="hljs-number">38</span>SIMPLE_THREAD_POOL<span class="hljs-number">-6</span>执行中...,返回结果：<span class="hljs-number">39</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>30.线程池原理与自定义线程池</title>
    <link href="/juc-actualCombat-1-30.html"/>
    <url>/juc-actualCombat-1-30.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">对于线程池有很多开源的东西，比如像JDK提供的并发包，在一般情况下都会去使用的，对于重新写一个线程池是完全没有必要的，这个章节并不是学习自己写线程池在工作中去使用，而是让你掌握它的原理。</p><p>Null</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>29.ThreadGroup API介绍</title>
    <link href="/juc-actualCombat-1-29.html"/>
    <url>/juc-actualCombat-1-29.html</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadGroup-API介绍-上"><a href="#ThreadGroup-API介绍-上" class="headerlink" title="ThreadGroup API介绍-上"></a>ThreadGroup API介绍-上</h1><p class="note note-info"><code>ThreadGroup</code>在JDK1.4、5版本的时候使用的岁非常多的，那个时候 线程池API去用，开发者喜欢通过<code>ThreadGroup</code>去管理多线程，它对管理多线程有一定的好处，在前面章节介绍<code>Thread</code>构造函数有介绍如果没指定<code>ThreadGroup</code>它会去把当前线程的<code>ThreadGroup</code>做为它默认的<code>ThreadGroup</code>。<br/><code>Thread</code>和<code>ThreadGroup</code>的关系是什么？它类的描述：</p><p class="note note-info">ThreadGroup（线程组）代表一组线程。 此外，线程组也可以包含其他线程组。 ThreadGroup构成一个树，其中除了初始ThreadGroup的每个线程组具有父。<br/>一个线程被允许有关自己的线程组访问信息，而不是有关其线程组的父线程组或其他任何线程组访问信息。<br/>示例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter12;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 15:38</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGroupCreate</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThreadGroup tg1 = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"TG1"</span>);    Thread t1 =        <span class="hljs-keyword">new</span> Thread(tg1, <span class="hljs-string">"T1"</span>) &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(getThreadGroup().getName());            System.out.println(getThreadGroup().getParent());          &#125;        &#125;;    t1.start();    ThreadGroup tg2 = <span class="hljs-keyword">new</span> ThreadGroup(tg1, <span class="hljs-string">"TG2"</span>);    System.out.println(tg2.getName());    System.out.println(tg2.getParent());  &#125;&#125;</code></pre><p class="note note-warning">类介绍说不能有关其线程组的父线，但是这里测试是可以正常获取信息的</p><p class="note note-info"><code>ThreadGroup</code>的构造方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadGroup</span><span class="hljs-params">(String name)</span></span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadGroup</span><span class="hljs-params">(ThreadGroup parent, String name)</span></span></code></pre><h1 id="ThreadGroup-API介绍-下"><a href="#ThreadGroup-API介绍-下" class="headerlink" title="ThreadGroup API介绍-下"></a>ThreadGroup API介绍-下</h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter12;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Thread Group API</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 17:15</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGroupAPI</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThreadGroup tg1 = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"tg1"</span>);    Thread t1 =        <span class="hljs-keyword">new</span> Thread(tg1, <span class="hljs-string">"t1"</span>) &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;              <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">10_000</span>);              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;          &#125;        &#125;;    t1.start();    ThreadGroup tg2 = <span class="hljs-keyword">new</span> ThreadGroup(tg1, <span class="hljs-string">"tg2"</span>);    Thread t2 =        <span class="hljs-keyword">new</span> Thread(tg2, <span class="hljs-string">"t2"</span>) &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;              <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">10_000</span>);              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;          &#125;        &#125;;    t2.start();  &#125;&#125;</code></pre><h2 id="activeCount"><a href="#activeCount" class="headerlink" title="activeCount"></a><p class="note note-primary">activeCount</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">activeCount</span><span class="hljs-params">()</span></span></code></pre><p class="note note-light">介绍</p><p>返回活动线程的该线程组及其子组的数量的估计值。 递归遍历该线程组中的所有子组。<br>返回的值仅是一个估计值，因为线程数可以动态地改变，同时此方法遍历内部数据结构，和可能是由某些系统线程的存在而受到影响。 这种方法主要用于调试和监测目的。</p><p class="note note-light">示例</p><pre><code class="hljs java">System.out.println(<span class="hljs-string">"tg1 active count:"</span> + tg1.activeCount());</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">tg1 active count:<span class="hljs-number">2</span></code></pre><p class="note note-info">这里包含了t2线程，子<code>ThreadGroup tg2</code>也算入了</p><h2 id="activeGroupCount"><a href="#activeGroupCount" class="headerlink" title="activeGroupCount"></a><p class="note note-primary">activeGroupCount</p></h2><p class="note note-light">介绍</p><p>返回的活性基团的该线程组和其子组的数量的估计值。 递归遍历该线程组中的所有子组。<br>返回的值仅是一个估计值，因为线程组的数目可以动态地改变，同时此方法遍历内部数据结构。 这种方法主要用于调试和监测目的。</p><p class="note note-light">示例</p><pre><code class="hljs java">System.out.println(tg1.activeGroupCount());</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span></code></pre><h2 id="checkAccess"><a href="#checkAccess" class="headerlink" title="checkAccess"></a><p class="note note-primary">checkAccess</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkAccess</span><span class="hljs-params">()</span></span></code></pre><p class="note note-light">介绍</p><p>确定当前运行的线程是否有权修改该线程组。<br>如果有安全管理器，它checkAccess方法被调用此线程组作为其参数。 这可能导致抛出SecurityException 。</p><p class="note note-light">示例</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;      tg1.checkAccess();    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;      exception.printStackTrace();    &#125;</code></pre><h2 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a><p class="note note-primary">destroy</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span></code></pre><p class="note note-light">介绍</p><p>销毁此线程组及其所有子组。 此线程组必须为空，表明已被此线程组中的所有线程都自停。<br>首先， checkAccess此线程组被称为不带参数的方法; 这可能导致一个安全性异常。</p><p class="note note-light">示例</p><pre><code class="hljs java">tg1.destroy();</code></pre><p class="note note-light">结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalThreadStateException</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ThreadGroup</span><span class="hljs-selector-class">.destroy</span>(<span class="hljs-selector-tag">ThreadGroup</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:778)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter12</span><span class="hljs-selector-class">.ThreadGroupAPI</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">ThreadGroupAPI</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:42)</span></code></pre><h2 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a><p class="note note-primary">enumerate</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">enumerate</span><span class="hljs-params">(Thread[] list)</span></span></code></pre><p class="note note-light">介绍</p><p>拷贝到指定的数组的所有活动线程该线程组及其子组英寸<br>此方法的调用行为完全相同的方式调用<br>枚举 (list, true)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">enumerate</span><span class="hljs-params">(Thread[] list,</span></span><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">boolean</span> recurse)</span></span></code></pre><p class="note note-light">介绍</p><p>拷贝到指定的数组的所有活动线程该线程组英寸 如果recurse是true ，这种方法递归枚举此线程组，并在这些分组的所有活动线程引用的所有子组也包括在内。 如果数组太小而无法保持所有线程，额外的线程会被忽略。<br>应用程序可以使用的活动核心方法获取的数组应为多大的估计，但是， 如果数组太小而无法保持所有线程，额外的线程会被忽略。 如果关键是要获得此线程组中的所有活动线程，调用方应该验证返回的int值比的长度较少严格的list 。<br>由于这种方法固有的竞争条件，建议该方法只用于调试和监控的目的。</p><p>参数：<br>list（列表）    ：   一个数组该放到线程列表<br>recurse（递归） ：   如果true ，递归枚举此线程组的所有子组</p><p class="note note-light">示例</p><pre><code class="hljs java">Thread[] arr = <span class="hljs-keyword">new</span> Thread[tg1.activeCount()];   tg1.enumerate(arr);   Arrays.stream(arr).forEach(System.out::println);</code></pre><p class="note note-light">结果</p><p>Thread[t1,5,tg1]<br>Thread[t2,5,tg2]</p><pre><code class="hljs java">Thread[] arr = <span class="hljs-keyword">new</span> Thread[tg1.activeCount()];    tg1.enumerate(arr,<span class="hljs-keyword">false</span>);    Arrays.stream(arr).forEach(System.out::println);</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">Thread[t1,<span class="hljs-number">5</span>,tg1]<span class="hljs-literal">null</span></code></pre><p class="note note-info">对于重载一个参数和两个参数的区别在于两个参数的 recurse（递归）如果true ，递归枚举此线程组的所有子组，上面示例中传递<code>false</code>它的结果就只包含自己下面的线程了</p><h2 id="getMaxPriority"><a href="#getMaxPriority" class="headerlink" title="getMaxPriority"></a><p class="note note-primary">getMaxPriority</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxPriority</span><span class="hljs-params">()</span></span></code></pre><p class="note note-light">介绍</p><p>返回该线程组的最高优先级。 线程是该组的一部分，不具有比最高优先级更高的优先级。</p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><p class="note note-primary">interrupt</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span></code></pre><p>中断此线程组中的所有线程。<br>首先， checkAccess此线程组被称为不带参数的方法; 这可能导致一个安全性异常。<br>然后，这个方法调用interrupt对该线程组及其所有子组中的所有线程的方法。</p><p class="note note-light">示例</p><pre><code class="hljs java">tg1.interrupt();</code></pre><p class="note note-light">结果</p><pre><code class="hljs oxygene">java.lang.InterruptedException: sleep interruptedat java.lang.Thread.sleep(Native <span class="hljs-function"><span class="hljs-keyword">Method</span>)</span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">com</span>.<span class="hljs-title">shui</span>.<span class="hljs-title">juc</span>.<span class="hljs-title">chapter12</span>.<span class="hljs-title">ThreadGroupAPI</span>$2.<span class="hljs-title">run</span><span class="hljs-params">(ThreadGroupAPI.java:34)</span></span><span class="hljs-function"><span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">InterruptedException</span>:</span> sleep interruptedat java.lang.Thread.sleep(Native <span class="hljs-function"><span class="hljs-keyword">Method</span>)</span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">com</span>.<span class="hljs-title">shui</span>.<span class="hljs-title">juc</span>.<span class="hljs-title">chapter12</span>.<span class="hljs-title">ThreadGroupAPI</span>$1.<span class="hljs-title">run</span><span class="hljs-params">(ThreadGroupAPI.java:19)</span></span></code></pre><h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon"></a><p class="note note-primary">setDaemon</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> daemon)</span></span></code></pre><p class="note note-light">介绍</p><p>改变该线程组的后台程序状态。<br>首先， checkAccess此线程组被称为不带参数的方法; 这可能导致一个安全性异常。<br>当它的最后一个线程被停止或它的最后一个线程组被销毁守护线程组会自动销毁。</p><p>参数：<br>守护进程-如果true ，表示此线程组的后台程序线程组; 否则，标记该线程组为正常。</p><p class="note note-light">示例</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter12;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Thread Group API</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 17:15</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadGroupAPI</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThreadGroup tg1 = <span class="hljs-keyword">new</span> ThreadGroup(<span class="hljs-string">"tg1"</span>);    Thread t1 =        <span class="hljs-keyword">new</span> Thread(tg1, <span class="hljs-string">"t1"</span>) &#123;          <span class="hljs-meta">@Override</span>          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">try</span> &#123;              Thread.sleep(<span class="hljs-number">1_000</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;              e.printStackTrace();            &#125;          &#125;        &#125;;    t1.start();    <span class="hljs-comment">// tg1.setDaemon(true);</span>    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">2_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;    System.out.println(tg1.isDestroyed());  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs yaml"><span class="hljs-literal">false</span></code></pre><p class="note note-info">默认情况下<code>ThreadGroup</code>是<code>setDaemon(false)</code>的，对于它组里面的线程全部执行完以后，调用它的<code>isDestroyed()</code>是false，就表示没销毁，这个时候应该要在<code>main</code>中手动调用<code>destroy()</code>其它这里可以通过<code>setDaemon(true)</code>使得它在自己组中的线程执行完成之后自动销毁</p><pre><code class="hljs java">tg1.setDaemon(<span class="hljs-keyword">true</span>);</code></pre><p class="note note-light">结果</p><pre><code class="hljs yaml"><span class="hljs-literal">true</span></code></pre><h2 id="list"><a href="#list" class="headerlink" title="list"></a><p class="note note-primary">list</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span></span></code></pre><p class="note note-light">示例</p><pre><code class="hljs java">tg1.list();</code></pre><p class="note note-light">结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ThreadGroup</span><span class="hljs-selector-attr">[name=tg1,maxpri=10]</span>    <span class="hljs-selector-tag">Thread</span><span class="hljs-selector-attr">[t1,5,tg1]</span>    <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ThreadGroup</span><span class="hljs-selector-attr">[name=tg2,maxpri=10]</span>        <span class="hljs-selector-tag">Thread</span><span class="hljs-selector-attr">[t2,5,tg2]</span></code></pre><h2 id="setMaxPriority"><a href="#setMaxPriority" class="headerlink" title="setMaxPriority"></a><p class="note note-primary">setMaxPriority</p></h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMaxPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pri)</span></span></code></pre><p class="note note-light">结果</p><p>设置组的最高优先级。 线程组已经有一个更高优先级的线程中不会受到影响。<br>首先， checkAccess此线程组被称为不带参数的方法; 这可能导致一个安全性异常。<br>如果pri参数小于Thread.MIN_PRIORITY或大于Thread.MAX_PRIORITY ，该组的最高优先级保持不变。<br>否则，该线程组对象的优先级被设定为指定的小pri和最大允许该线程组的父的优先级。 （如果该线程组是系统线程组，没有父，那么它的最大优先级被简单地设定为pri ）。然后这个方法被递归调用，与pri作为其参数，对于属于该线程组的每个线程组。</p><h2 id="parentOf"><a href="#parentOf" class="headerlink" title="parentOf"></a><p class="note note-primary">parentOf</p></h2><pre><code class="hljs less"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">final</span> <span class="hljs-selector-tag">boolean</span> <span class="hljs-selector-tag">parentOf</span>(<span class="hljs-variable">@Nullable</span> ThreadGroup g)</code></pre><p class="note note-light">介绍</p><p>测试该线程组是否为线程组参数或其祖先线程组之一。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>28.如何捕获线程运行期间的异常</title>
    <link href="/juc-actualCombat-1-28.html"/>
    <url>/juc-actualCombat-1-28.html</url>
    
    <content type="html"><![CDATA[<h1 id="捕获线程的异常"><a href="#捕获线程的异常" class="headerlink" title="捕获线程的异常"></a>捕获线程的异常</h1><p class="note note-info">当线程出现<code>Exception</code>时你的应用程序怎么知道它？从一个线程中是抛不出异常的，因为线程的逻辑单元是放在<code>run()</code>中的，它的那个签名是不允许抛出异常的，那你只有捕获这个异常，但是当在线程中出现<code>RuntimeException</code>，可能在计算什么东西的时候除以0了，很明显<code>Exception</code>会发生，发生这个线程肯能是挂了，但是也不会导致你的应用程序挂掉，线程挂了以后最多只能在log中排查问题，那你怎么在外面知道它是一个什么<code>Exception</code>呢？这个就是本章要介绍的。<br/>来看一个案例：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter11;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程异常</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 13:21</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadException</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> B = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t =        <span class="hljs-keyword">new</span> Thread(            () -&gt; &#123;              <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">5_000</span>);                <span class="hljs-keyword">int</span> result = A / B;                System.out.println(result);              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;);    t.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"Thread-0"</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.ArithmeticException</span>: / by zeroat com<span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter11</span><span class="hljs-selector-class">.ThreadException</span>.lambda<span class="hljs-variable">$main</span>$<span class="hljs-number">0</span>(ThreadException<span class="hljs-selector-class">.java</span>:<span class="hljs-number">19</span>)at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span>.run(Thread<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)</code></pre><p class="note note-info">对于ArithmeticException这个异常在<code>main</code>中是获取不到的，如果你想通过异常的类型去做一些处理的话就没有办法,因为在<code>run()</code>中抛不出异常，在<code>Thread</code>提供了一个非常好用的方法，它可以让你拿到这个异常：</p><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> setUncaughtExceptionHandler(<span class="hljs-keyword">Thread</span>.UncaughtExceptionHandler eh)</code></pre><p>设置处理，由于未捕获到异常时调用该线程突然终止。<br>一个线程可以利用它如何通过有明确设置其未捕获的异常处理程序响应未捕获异常的完全控制。 如果没有设置这样的处理程序，则该线程的ThreadGroup对象作为其处理程序。<br/><br>参数：eh - 对象为这个线程未捕获到的异常处理程序。 如果为null，则该线程没有明确的处理程序。<br>抛出：SecurityException -如果当前线程无权修改该线程。<br>自从：1.5</p><p class="note note-info">通过这个方法对代码改造</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter11;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程异常</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 13:21</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadException</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> A = <span class="hljs-number">10</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> B = <span class="hljs-number">0</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t =        <span class="hljs-keyword">new</span> Thread(            () -&gt; &#123;              <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">5_000</span>);                <span class="hljs-keyword">int</span> result = A / B;                System.out.println(result);              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;);+       t.setUncaughtExceptionHandler(        (t1, e) -&gt; &#123;          System.out.println(<span class="hljs-string">"线程name："</span> + t1.getName() + <span class="hljs-string">"\t异常："</span> + e.getMessage());        &#125;);    t.start();    <span class="hljs-comment">// 未捕获的异常处理</span>  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs applescript">线程<span class="hljs-built_in">name</span>：Thread<span class="hljs-number">-0</span>异常：/ <span class="hljs-keyword">by</span> zero</code></pre><h1 id="记录执行过程中方法被谁调用了"><a href="#记录执行过程中方法被谁调用了" class="headerlink" title="记录执行过程中方法被谁调用了"></a>记录执行过程中方法被谁调用了</h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter11;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 14:54</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;  <span class="hljs-keyword">private</span> Test2 test2 = <span class="hljs-keyword">new</span> Test2();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    test2.test();  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter11;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 14:54</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;    Arrays.stream(Thread.currentThread().getStackTrace())        .filter(e -&gt; !e.isNativeMethod())        .forEach(            e -&gt;                System.out.println(                    <span class="hljs-string">"class:"</span>                        + e.getClassName()                        + <span class="hljs-string">"\tmethod:"</span>                        + e.getMethodName()                        + <span class="hljs-string">"\tline:"</span>                        + e.getLineNumber()));  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter11;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 14:56</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadException2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Test1 test1 = <span class="hljs-keyword">new</span> Test1();    test1.test();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs oxygene"><span class="hljs-keyword">class</span>:java.lang.Thread<span class="hljs-function"><span class="hljs-keyword">method</span>:</span>getStackTraceline:<span class="hljs-number">1559</span><span class="hljs-keyword">class</span>:com.shui.juc.chapter11.Test2<span class="hljs-function"><span class="hljs-keyword">method</span>:</span>testline:<span class="hljs-number">11</span><span class="hljs-keyword">class</span>:com.shui.juc.chapter11.Test1<span class="hljs-function"><span class="hljs-keyword">method</span>:</span>testline:<span class="hljs-number">10</span><span class="hljs-keyword">class</span>:com.shui.juc.chapter11.ThreadException2<span class="hljs-function"><span class="hljs-keyword">method</span>:</span>mainline:<span class="hljs-number">10</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>27.如何给你的应用程序注入钩子程序</title>
    <link href="/juc-actualCombat-1-27.html"/>
    <url>/juc-actualCombat-1-27.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">这章介绍如何获取<code>Exception</code>,在线程的<code>run()</code>是不允许抛出异常的,它不抛异常线程死掉了你外面是不知道是什么情况的,那你需要怎么知道它发生的异常?如果你没有捕获到它可能就只是输出堆栈信息,你外部<code>start()</code>是拿不到异常的。</p><p>在Centos中运行以下代码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 8:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExitCapture</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1_000</span>);        System.out.println(<span class="hljs-string">"I am working..."</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><pre><code class="hljs bash">/opt/code/java&gt; javac ExitCapture.java$ java -cp . ExitCapture I am working...I am working...I am working...I am working...<span class="hljs-comment">#后台运行</span>/opt/code/java&gt; nohup java -cp . ExitCapture &gt; test.log 2&gt;&amp; 1&amp;[1] 6367/opt/code/java&gt; tail -f ./test.logI am working...I am working...I am working...I am working...I am working...I am working...^C</code></pre><p class="note note-info">将进程杀死</p><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 6367</code></pre><p class="note note-info">当时如果我的程序它占用了很多数据库的连接或者很多文件，这里我想在你杀掉它的时候进行释放，或者在我异常退出的情况下，想让它通知我一下。<br/>代码再进行改进，在退出、出现异常情况下让别人知道程序退出。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 8:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExitCapture</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1_000</span>);        System.out.println(<span class="hljs-string">"I am working..."</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;      i++;      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">20</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Error"</span>);      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...Exception in thread <span class="hljs-string">"Thread-0"</span> java.lang.RuntimeException: Error        at ExitCapture.lambda<span class="hljs-symbol">$</span>main<span class="hljs-symbol">$</span><span class="hljs-number">0</span>(ExitCapture.java:<span class="hljs-number">20</span>)        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)</code></pre><p class="note note-info">接下来模拟在程序关闭时主动发送信息</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 8:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExitCapture</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// Runtime 可以拿CPU、执行的Shell脚本、</span>    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      System.out.println(<span class="hljs-string">"The application well be exit."</span>);      notifyAndRelease();    &#125;));    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1_000</span>);        System.out.println(<span class="hljs-string">"I am working..."</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;      i++;      <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">20</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Error"</span>);      &#125;    &#125;  &#125;  <span class="hljs-comment">/** 模拟：通知，这里可以调用一个Rest接口、可以发送邮件 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAndRelease</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"通知管理员。"</span>);    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">1_000</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;    &#125;    System.out.println(<span class="hljs-string">"将释放资源（socket、file、connection）。"</span>);    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">1_000</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;    &#125;    System.out.println(<span class="hljs-string">"发布并通知完成。"</span>);  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...Exception in thread <span class="hljs-string">"main"</span> java.lang.RuntimeException: Error        at ExitCapture.main(ExitCapture.java:<span class="hljs-number">25</span>)The application well be exit.通知管理员。将释放资源（socket、<span class="hljs-keyword">file</span>、connection）。发布并通知完成。</code></pre><p class="note note-info">那对于kill能不能感应到呢？先改下代码</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.management.RuntimeErrorException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/4 8:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExitCapture</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// Runtime 可以拿CPU、执行的Shell脚本、</span>    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      System.out.println(<span class="hljs-string">"The application well be exit."</span>);      notifyAndRelease();    &#125;));    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1_000</span>);        System.out.println(<span class="hljs-string">"I am working..."</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;     <span class="hljs-comment">/*  i++;</span><span class="hljs-comment">      if (i &gt; 20) &#123;</span><span class="hljs-comment">        throw new RuntimeException("Error");</span><span class="hljs-comment">      &#125; */</span>    &#125;  &#125;  <span class="hljs-comment">/** 模拟：通知，这里可以调用一个Rest接口、可以发送邮件 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyAndRelease</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"通知管理员。"</span>);    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">1_000</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;    &#125;    System.out.println(<span class="hljs-string">"将释放资源（socket、file、connection）。"</span>);    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">1_000</span>);    &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;    &#125;    System.out.println(<span class="hljs-string">"发布并通知完成。"</span>);  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-function"><span class="hljs-title">I</span></span> am working...<span class="hljs-symbol">$</span> kill  <span class="hljs-number">41439</span>The application well be exit.通知管理员。<span class="hljs-function"><span class="hljs-title">I</span></span> am working...将释放资源（socket、<span class="hljs-keyword">file</span>、connection）。<span class="hljs-function"><span class="hljs-title">I</span></span> am working...发布并通知完成。</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>26.如何实现一个自己的显式锁Lock</title>
    <link href="/juc-actualCombat-1-26.html"/>
    <url>/juc-actualCombat-1-26.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info"><code>synchronized</code>在其它线程去获取锁的时候，如果它已经获取到了而且它工作时间非常长，调用者一直进入阻塞状态，你对它也打断不了，它也不能立即返回，调用者就一直没有事情做，然后就在那傻傻等着，即使有一个线程去打断它也是无济于事的，在这个章节介绍自定义锁。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter10;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 现实锁</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/2 21:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 获取被 &lt;code&gt;Block&lt;/code&gt; 的大小</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBlockedSize</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/** 获取 阻塞的线程 */</span>  <span class="hljs-function">Collection&lt;Thread&gt; <span class="hljs-title">getBlockedThread</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 锁</span><span class="hljs-comment">   *</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 锁</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> millis 在 &lt;code&gt;millis&lt;/code&gt; 时间过完之后退出</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException, TimeOutException</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 解锁</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeOutException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TimeOutException</span><span class="hljs-params">(String message)</span> </span>&#123;      <span class="hljs-keyword">super</span>(message);    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter10;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/2 21:43</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooleanLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;  <span class="hljs-comment">/** Block 的线程 */</span>  <span class="hljs-keyword">private</span> Collection&lt;Thread&gt; blockedThreadCollection = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  <span class="hljs-comment">/** true:使表示已经被拿走了，false: 空闲 */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> initValue;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BooleanLock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">false</span>;  &#125;  <span class="hljs-comment">/** 获取被 &lt;code&gt;Block&lt;/code&gt; 的大小 */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBlockedSize</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> blockedThreadCollection.size();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 获取 阻塞的线程</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Thread&gt; <span class="hljs-title">getBlockedThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Collections.unmodifiableCollection(blockedThreadCollection);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 锁</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> InterruptedException</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (initValue) &#123;      blockedThreadCollection.add(getCurrentThread());      <span class="hljs-keyword">this</span>.wait();    &#125;    blockedThreadCollection.remove(getCurrentThread());    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">true</span>;  &#125;  <span class="hljs-comment">/** <span class="hljs-doctag">@return</span> 获取当前线程 */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> Thread <span class="hljs-title">getCurrentThread</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> Thread.currentThread();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 锁</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> millis 在 &lt;code&gt;millis&lt;/code&gt; 时间过完之后退出</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException, TimeOutException </span>&#123;&#125;  <span class="hljs-comment">/** 解锁 */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">false</span>;    System.out.println(getCurrentThread().getName() + <span class="hljs-string">" release the lock monitor."</span>);    <span class="hljs-keyword">this</span>.notifyAll();  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter10;<span class="hljs-keyword">import</span> java.util.stream.Stream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/2 21:58</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooleanLockTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">final</span> Lock booleanLock = <span class="hljs-keyword">new</span> BooleanLock();    Stream.of(<span class="hljs-string">"T1"</span>, <span class="hljs-string">"T2"</span>, <span class="hljs-string">"T3"</span>, <span class="hljs-string">"T4"</span>)        .forEach(            name -&gt;                <span class="hljs-keyword">new</span> Thread(                        () -&gt; &#123;                          <span class="hljs-keyword">try</span> &#123;                            booleanLock.lock();                            System.out.println(                                Thread.currentThread().getName() + <span class="hljs-string">" have the lock monitor."</span>);                            work();                          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                            e.printStackTrace();                          &#125; <span class="hljs-keyword">finally</span> &#123;                            booleanLock.unlock();                          &#125;                        &#125;,                        name)                    .start());  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" is working..."</span>);      Thread.sleep(<span class="hljs-number">10_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs sql">T1 have the <span class="hljs-keyword">lock</span> monitor.T1 <span class="hljs-keyword">is</span> working...T1 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T4 have the <span class="hljs-keyword">lock</span> monitor.T4 <span class="hljs-keyword">is</span> working...T4 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T2 have the <span class="hljs-keyword">lock</span> monitor.T2 <span class="hljs-keyword">is</span> working...T2 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T3 have the <span class="hljs-keyword">lock</span> monitor.T3 <span class="hljs-keyword">is</span> working...T3 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.Process finished <span class="hljs-keyword">with</span> <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span></code></pre><p class="note note-info">这样还是存在一些问题的，对于上面自定义的API，别人也可以拿到主线程中和使用，这里在<code>main</code>中调用<code>unlock</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> Lock booleanLock = <span class="hljs-keyword">new</span> BooleanLock();    Stream.of(<span class="hljs-string">"T1"</span>, <span class="hljs-string">"T2"</span>, <span class="hljs-string">"T3"</span>, <span class="hljs-string">"T4"</span>)        .forEach(            name -&gt;                <span class="hljs-keyword">new</span> Thread(                        () -&gt; &#123;                          <span class="hljs-keyword">try</span> &#123;                            booleanLock.lock();                            System.out.println(                                Thread.currentThread().getName() + <span class="hljs-string">" have the lock monitor."</span>);                            work();                          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                            e.printStackTrace();                          &#125; <span class="hljs-keyword">finally</span> &#123;                            booleanLock.unlock();                          &#125;                        &#125;,                        name)                    .start());    Thread.sleep(<span class="hljs-number">100</span>);    booleanLock.unlock();  &#125;</code></pre><pre><code class="hljs mercury">T1 have the lock monitor.T1 <span class="hljs-keyword">is</span> working...main release the lock monitor.//没有等待，直接输出T4T4 have the lock monitor.T4 <span class="hljs-keyword">is</span> working......</code></pre><p class="note note-info">对于这个问题，对于锁是谁加的，就只能谁去释放，如果是T1加的锁只能T1去释放，其它线程去释放就不行，这个怎么控制呢？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BooleanLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;  <span class="hljs-comment">/** 记录调用 lock()的线程，对于解锁的时候，通过它与当前线程去比较，如果不一样不做任何事情 */</span>  <span class="hljs-keyword">private</span> Thread currentThread;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">while</span> (initValue) &#123;      blockedThreadCollection.add(getCurrentThread());      <span class="hljs-keyword">this</span>.wait();    &#125;    blockedThreadCollection.remove(getCurrentThread());    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">true</span>;+   <span class="hljs-keyword">this</span>.currentThread = getCurrentThread();  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;+   <span class="hljs-keyword">if</span> (currentThread != getCurrentThread()) &#123;+     <span class="hljs-keyword">return</span>;+   &#125;    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">false</span>;    System.out.println(getCurrentThread().getName() + <span class="hljs-string">" release the lock monitor."</span>);    <span class="hljs-keyword">this</span>.notifyAll();  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs sql">T1 have the <span class="hljs-keyword">lock</span> monitor.T1 <span class="hljs-keyword">is</span> working...T1 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T4 have the <span class="hljs-keyword">lock</span> monitor.T4 <span class="hljs-keyword">is</span> working...T4 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T2 have the <span class="hljs-keyword">lock</span> monitor.T2 <span class="hljs-keyword">is</span> working...T2 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.T3 have the <span class="hljs-keyword">lock</span> monitor.T3 <span class="hljs-keyword">is</span> working...T3 <span class="hljs-keyword">release</span> the <span class="hljs-keyword">lock</span> monitor.Process finished <span class="hljs-keyword">with</span> <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span></code></pre><p class="note note-info">在线程很久没有抢到锁的情况，它能放弃去抢锁，去做别的事情，代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 锁</span><span class="hljs-comment">   *</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> millis 在 &lt;code&gt;millis&lt;/code&gt; 时间过完之后退出</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException, TimeOutException </span>&#123;    <span class="hljs-keyword">if</span> (millis &lt;= <span class="hljs-number">0</span>) &#123;      lock();    &#125;    <span class="hljs-keyword">long</span> hasReaming = millis;    <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis() + millis;    <span class="hljs-keyword">while</span> (initValue) &#123;      <span class="hljs-keyword">if</span> (hasReaming &lt;= <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeOutException(<span class="hljs-string">"Time out"</span>);      &#125;      blockedThreadCollection.add(getCurrentThread());      <span class="hljs-keyword">this</span>.wait(millis);      hasReaming = endTime - System.currentTimeMillis();    &#125;    <span class="hljs-keyword">this</span>.initValue = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">this</span>.currentThread = getCurrentThread();  &#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-keyword">final</span> Lock booleanLock = <span class="hljs-keyword">new</span> BooleanLock();    Stream.of(<span class="hljs-string">"T1"</span>, <span class="hljs-string">"T2"</span>, <span class="hljs-string">"T3"</span>, <span class="hljs-string">"T4"</span>)        .forEach(            name -&gt;                <span class="hljs-keyword">new</span> Thread(                        () -&gt; &#123;                          <span class="hljs-keyword">try</span> &#123;M+                            booleanLock.lock(<span class="hljs-number">20_000</span>);                            System.out.println(                                Thread.currentThread().getName() + <span class="hljs-string">" have the lock monitor."</span>);                            work();                          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                            e.printStackTrace();                          &#125; <span class="hljs-keyword">catch</span> (Lock.TimeOutException e) &#123;M+                            System.out.println(<span class="hljs-string">"不搞快点就罢工!"</span>);                          &#125; <span class="hljs-keyword">finally</span> &#123;                            booleanLock.unlock();                          &#125;                        &#125;,                        name)                    .start());    Thread.sleep(<span class="hljs-number">100</span>);    booleanLock.unlock();  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs mercury">T1 have the lock monitor.T1 <span class="hljs-keyword">is</span> working...T1 release the lock monitor.T4 have the lock monitor.T4 <span class="hljs-keyword">is</span> working...T4 release the lock monitor.T2 have the lock monitor.T2 <span class="hljs-keyword">is</span> working...不搞快点就罢工!T2 release the lock monitor.</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25.线程生产者消费者的综合实战结合Java8语法</title>
    <link href="/juc-actualCombat-1-25.html"/>
    <url>/juc-actualCombat-1-25.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info"><code>join()</code>可以保证你的线程都执行结束之后在去执行main后面的代码，不记得了可以回顾下<a href="/juc-actualCombat-1-11.html">11章节</a>。<br/>来说下案例：<br/></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/2/2ea15ec1-6ad5-4144-a0e5-76be48e68f05.png" srcset="/img/loading.gif" alt="2ea15ec1-6ad5-4144-a0e5-76be48e68f05"></p><p class="note note-info">有这么一个需求：现在需要对三台服务器做信息统计，如果想尽快做完，那就要使用多线程去完成了，你可以创建3个线程去取三个服务器的信息，那么如果是10台服务器，你去创建10个线程是没有问题的，但是有100、1k台机器呢？这个时候如果去创建100、1k个线程是行不通的，现在的Linux、Windows，它同时支持最大的线程数是有约束的，它的上限值取决于<code>stackSize</code>，多线程的效率是一个这样的状态：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/2/image-20200702191233837.png" srcset="/img/loading.gif" alt="image-20200702191233837"></p><p class="note note-info">对于线程越来越多，当线程达到一定数量它可能是最理想的状态，当超过这个值的时候你的应用可能会越来越慢，因为它慢在线程的切换开销，你有1k个线程你的CPU它的决定分配资源给哪个线程去执行，它得反复去切换这个东西，也就是说你的应用程序整体的占用资源几乎什么事都不做，它就可能忙着去切换你的线程了所以导致你这个应用程序的性能会越来越低，到后面由于内存的原因直接走不动了。所以在遇到程序性能比较低下的时候往这个线程是不是开辟过多这个方向去思考。<br/>基于这个原因，我可能有1k台服务器，那么我这里每次最多有10个线程去跑，它保持最多10个去跑，其中有一个线程执行完成之后，另外一个线程就去运行...，对于这些等待不去执行逻辑的线程它创建吗？也创建，但是它<code>wait()</code>了而释放了CPU执行权，这个时候CPU就不会对它做上下文的切换，此时此刻在CPU只需要切换这10个就OK了，那么应用程序的性能就不会由于很多线程导致性能下降的问题。<br/>下面通过前面章节学到的知识来完成这样的功能。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/2 19:30</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CaptureService</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> LinkedList&lt;Control&gt; CONTROLS = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX_WORKER = <span class="hljs-number">5</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    List&lt;Thread&gt; worker = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    Arrays.asList(<span class="hljs-string">"M1"</span>, <span class="hljs-string">"M2"</span>, <span class="hljs-string">"M3"</span>, <span class="hljs-string">"M4"</span>, <span class="hljs-string">"M5"</span>, <span class="hljs-string">"M6"</span>, <span class="hljs-string">"M7"</span>, <span class="hljs-string">"M8"</span>, <span class="hljs-string">"M9"</span>, <span class="hljs-string">"M10"</span>).stream()        .map(CaptureService::createCaptureThread)        .forEach(            t -&gt; &#123;              t.start();              worker.add(t);            &#125;);    worker.stream()        .forEach(            t -&gt; &#123;              <span class="hljs-keyword">try</span> &#123;                t.join();              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;);    Optional.of(<span class="hljs-string">"All of capture work finished"</span>).ifPresent(System.out::println);  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread <span class="hljs-title">createCaptureThread</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(        () -&gt; &#123;          Optional.of(<span class="hljs-string">"The worker ["</span> + Thread.currentThread().getName() + <span class="hljs-string">"] BEGIN capture data."</span>)              .ifPresent(System.out::println);          <span class="hljs-keyword">synchronized</span> (CONTROLS) &#123;            <span class="hljs-keyword">while</span> (CONTROLS.size() &gt; MAX_WORKER) &#123;              <span class="hljs-keyword">try</span> &#123;                CONTROLS.wait();              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();              &#125;            &#125;            CONTROLS.addLast(<span class="hljs-keyword">new</span> Control());          &#125;          Optional.of(<span class="hljs-string">"The worker ["</span> + Thread.currentThread().getName() + <span class="hljs-string">"] is working..."</span>)              .ifPresent(System.out::println);          <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">10000</span>);          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();          &#125;          <span class="hljs-keyword">synchronized</span> (CONTROLS) &#123;            Optional.of(<span class="hljs-string">"The worker ["</span> + Thread.currentThread().getName() + <span class="hljs-string">"] END capture data."</span>)                .ifPresent(System.out::println);            CONTROLS.removeFirst();            CONTROLS.notifyAll();          &#125;        &#125;,        name);  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Control</span> </span>&#123;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24.wait和sleep的本质区别是什么，深入分析</title>
    <link href="/juc-actualCombat-1-24.html"/>
    <url>/juc-actualCombat-1-24.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><p class="note note-primary">前言</p></h1><p class="note note-info">这章介绍<code>wait与sleep</code>的区别，它们两都捆让线程进入阻塞，但是它两之间有一个本质的区别</p><ol><li><code>sleep</code>是<code>Thread</code>的方法；wait是<code>Object</code>的方法，就算是对象数组也有。</li><li><code>sleep</code>不会释放对象monitor的锁；但是<code>wait</code>会释放这个锁，并且把它加入到对象 monitor 队列里面去。</li><li>使用<code>sleep</code>并不需要定义<code>synchronized</code>；但是你去使用<code>wait</code>你必须定义一个<code>synchronized</code>。</li><li>你使用<code>sleep</code>方法的时候你不需要被唤醒；但是<code>wait</code>是需要的，除了<code>wait(timeout)</code></li></ol><h1 id="使用sleep并不需要定义synchronized"><a href="#使用sleep并不需要定义synchronized" class="headerlink" title="使用sleep并不需要定义synchronized"></a><p class="note note-primary">使用<code>sleep</code>并不需要定义<code>synchronized</code></p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    m1();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">10_000</span>);      System.out.println(<span class="hljs-string">"123"</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><h1 id="使用wait你必须定义一个synchronized"><a href="#使用wait你必须定义一个synchronized" class="headerlink" title="使用wait你必须定义一个synchronized "></a><p class="note note-primary">使用<code>wait</code>你必须定义一个<code>synchronized</code> </p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    m1();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;      LOCK.wait();    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalMonitorStateException</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(<span class="hljs-selector-tag">Native</span> <span class="hljs-selector-tag">Method</span>)<span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(<span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:502)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter9</span><span class="hljs-selector-class">.DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.m1</span>(<span class="hljs-selector-tag">DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:16)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter9</span><span class="hljs-selector-class">.DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:11)</span></code></pre><p class="note note-info"><code>wait</code>必须在<code>synchronized</code>中，不然会报错</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    m1();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      <span class="hljs-keyword">try</span> &#123;        LOCK.wait();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-warning">这里<code>wait</code>的谁就必须<code>synchronized</code><br/>错误的例子</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK1 = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    m1();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK1) &#123;      <span class="hljs-keyword">try</span> &#123;        LOCK.wait();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalMonitorStateException</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(<span class="hljs-selector-tag">Native</span> <span class="hljs-selector-tag">Method</span>)<span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(<span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:502)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter9</span><span class="hljs-selector-class">.DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.m1</span>(<span class="hljs-selector-tag">DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:18)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter9</span><span class="hljs-selector-class">.DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">DifferenceOfWaitAndSleep</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:12)</span></code></pre><h1 id="sleep不会释放对象monitor的锁"><a href="#sleep不会释放对象monitor的锁" class="headerlink" title="sleep不会释放对象monitor的锁"></a><p class="note note-primary"><code>sleep</code>不会释放对象monitor的锁</p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-keyword">import</span> java.util.stream.Stream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Stream.of(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t2"</span>)        .forEach(            item -&gt;                <span class="hljs-keyword">new</span> Thread(                        () -&gt; &#123;                          m1();                        &#125;,                        item)                    .start());  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(Thread.currentThread().getName());      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">10_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs 1c">t1<span class="hljs-comment">//过去10秒</span>t2</code></pre><h1 id="wait会释放这个锁，并且把它加入到对象-monitor-队列里面去"><a href="#wait会释放这个锁，并且把它加入到对象-monitor-队列里面去" class="headerlink" title="wait会释放这个锁，并且把它加入到对象 monitor 队列里面去"></a><p class="note note-primary"><code>wait</code>会释放这个锁，并且把它加入到对象 monitor 队列里面去</p></h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-keyword">import</span> java.util.stream.Stream;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/1 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DifferenceOfWaitAndSleep</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Stream.of(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t2"</span>)        .forEach(            item -&gt;                <span class="hljs-keyword">new</span> Thread(                        () -&gt; &#123;                          m1();                        &#125;,                        item)                    .start());  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(Thread.currentThread().getName());      <span class="hljs-keyword">try</span> &#123;        LOCK.wait(<span class="hljs-number">10_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs 1c">t1 <span class="hljs-comment">//这里没有等待，立即执行 t2</span>t2</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.多线程下的生产者消费者模型，以及详细介绍notifyAll方法</title>
    <link href="/juc-actualCombat-1-23.html"/>
    <url>/juc-actualCombat-1-23.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">在上一章介绍的案例有一个很严重的问题，它那样做只能有一个生产者一个消费者，在实际开发中是会有多个生产者、消费者去做，但是通过<code>wait+notify</code>会出现假死，这章提供一个解决方案。<br/>这里先分析下之前的代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">// 如果已经生产了，调用 wait 方法</span>     <span class="hljs-keyword">if</span> (isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">// 如果没有生产，那就生产</span>       i++;       System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);       <span class="hljs-comment">// 唤醒正在该对象的监视器上等待（wait）的单个线程</span>       LOCK.notify();       isProduced = <span class="hljs-keyword">true</span>;     &#125;   &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-keyword">if</span> (isProduced) &#123;       System.out.println(<span class="hljs-string">"M-&gt;"</span> + i);       LOCK.notify();       isProduced = <span class="hljs-keyword">false</span>;     &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;   &#125; &#125;</code></pre><p class="note note-info">上面代码存在这么一个问题：<code>notify</code>唤醒的是哪一个线程？随机、FR、FO、这个是JVM没有明确要求你必须是哪种方式去唤醒的，对于这个问题先卖个关子,先介绍下几个方法,这些方法都属于<code>Object</code><br/><br/>    public final void wait()</p><p>使当前线程等待，直到另一个线程为此对象调用<code>notify（）</code>方法或<code>notifyAll（）</code>方法。换句话说，这个方法的行为就像它只是执行<code>wait（0）</code>一样。 当前线程必须拥有此对象的监视器。线程释放此监视器的所有权，并等待，直到另一个线程通过调用<code>notify</code>方法或<code>notifyAll</code>方法通知在该对象的监视器上等待的线程唤醒。然后线程等待，直到它可以重新获得监视器的所有权并继续执行。</p><p class="note note-info">public final native void wait(long timeout);</p><p>使当前线程等待，直到另一个线程为此对象调用<code>notify（）</code>方法或<code>notifyAll（）</code>方法，或者经过指定的时间量。<br>当前线程必须拥有此对象的监视器。 此方法会导致当前线程（称为T）将自己置于该对象的等待集中，然后放弃对该对象的所有同步声明。<br/><br>出于线程调度目的，线程T被禁用并处于休眠状态，直到发生以下四种情况之一： </p><ul><li>另一个线程调用这个对象的<code>notify</code>方法，而thread T恰好被任意选择为要唤醒的线程。 </li><li>另一个线程为此对象调用<code>notifyAll</code>方法。 </li><li>另一个线程中断线程T。 </li><li>指定的实时时间已过，或多或少。但是，如果<code>timeout</code>为零，则不考虑实时性，线程只是等待通知。 然后从该对象的等待集中删除线程T，并重新启用线程调度。然后，它以通常的方式与其他线程竞争对象上的同步权；一旦它获得了对象的控制权，它对该对象的所有同步声明都将恢复到以前的状态，也就是说，恢复到调用wait方法时的状态。然后，线程T从<code>wait</code>方法的调用返回。因此，从<code>wait</code>方法返回时，对象和线程T的同步状态与调用<code>wait</code>方法时的状态完全相同。 线程也可以在没有被通知、中断或超时的情况下被唤醒，这就是所谓的虚假唤醒。虽然这种情况在实践中很少发生，但应用程序必须通过测试本应导致线程被唤醒的条件，并在条件不满足时继续等待，以防出现这种情况。换句话说，等待应该总是在循环中发生，就像下面这样：<br/></li></ul><pre><code class="hljs java">同步（obj）&#123;  <span class="hljs-keyword">while</span>（条件不成立&gt; ） 等一下（超时）； ... <span class="hljs-comment">//根据情况采取适当的行动 </span>&#125;</code></pre><p>参数: 超时–等待的最长时间（毫秒）</p><hr><p class="note note-info">接着回到之前的代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-keyword">if</span> (isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125; <span class="hljs-keyword">else</span> &#123;       i++;       System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);       LOCK.notify();       isProduced = <span class="hljs-keyword">true</span>;     &#125;   &#125; &#125;</code></pre><p class="note note-info">它这里调用了<code>wait()</code>，意思是说它放弃了这个锁，也就是说它放弃了<code>LOCK</code>，它本来是持有这个锁（获取CPU执行权），这个时候它是一个“假死”的状态，直到<code>notify、notifyAll</code>把它唤醒。<br/>它被唤醒之后具备可运行状态，它不是说立即执行的，可运行状态还是需要它去强锁的，它只有抢到锁才会执行。<br/><code>notify</code>也介绍过，它会去唤醒一个线程</p><p>唤醒正在该对象的监视器上等待的单个线程。如果有线程正在等待此对象，则选择其中一个线程被唤醒。这种选择是任意的，由实现的自由裁量权决定。线程通过调用wait方法之一等待对象的监视器。<br/><br>在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续。被唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正积极地在该对象上进行同步；<br/><br>例如，被唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势。 此方法只能由作为此对象监视器所有者的线程调用。线程通过以下三种方式之一成为对象监视器的所有者：<br/> </p><ul><li>通过执行该对象的同步实例方法。 </li><li>通过执行在对象上同步的同步语句体。 </li><li>执行该类的静态方法的类。</li><li>一次只能有一个线程拥有一个对象的监视器。</li></ul><hr><p class="note note-info">它这里还有一个更重要的方法<code>notifyAll()</code></p><p>唤醒在该对象监视器上等待的所有线程，假设现在有三个线程<code>wait</code>了，通过它可以全部唤醒。 线程通过调用<code>wait</code>方法之一等待对象的监视器。<br/><br>在当前线程放弃此对象的锁之前，唤醒的线程将无法继续。被唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正积极地在该对象上进行同步；例如，被唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势。<br/><br>所以对于前面代码属出现的问题，通过它就能解决，这里进行改造：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">// 如果生产了数据，就wait住</span>     <span class="hljs-keyword">while</span> (isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;     <span class="hljs-comment">// 如果没有生产，那就生产</span>     i++;     System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);     <span class="hljs-comment">// 唤醒正在该对象的监视器上等待（wait）的单个线程</span>     LOCK.notify();     isProduced = <span class="hljs-keyword">true</span>;   &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">//如果生产数据，那就wait</span>     <span class="hljs-keyword">while</span> (!isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;     System.out.println(<span class="hljs-string">"M-&gt;"</span> + i);     LOCK.notify();     isProduced = <span class="hljs-keyword">false</span>;   &#125; &#125;</code></pre><p class="note note-info">上面代码为什么会去使用<code>while</code>？写成<code>if</code>可以吗？</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">// 如果生产了数据，就wait住</span>     <span class="hljs-keyword">if</span> (isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;     <span class="hljs-comment">// 如果没有生产，那就生产</span>   ...   &#125; &#125;</code></pre><p class="note note-info">假设这里是<code>if</code>其中有两个生产者线程，它们全部是唤醒的，一个抢到这个锁进来执行，执行的时候它判断到这边已经生产了，它<code>wait</code>，另外一个也<code>wait</code>了，然后它被唤醒之后去生产了数据，它执行完了，执行完之后去抢锁，它在抢锁的过程中发现它已经被生产过了所以它<code>wait</code>了，另外线程它干什么事？因为你使用的是<code>notifyAll</code>都唤醒了，根本不需要去判断了，那就直接又生产了一个数据，这样会导致消费者还没有消费完，已经被你重复生产了。</p><p>补充：因为调用的是<code>notifyAll</code>所以两个线程都被唤醒，它们其中一个去抢到锁去生产，生产之后要由于是<code>while(true)</code>在走这个逻辑，它是一个<code>wait</code>状态，那第二个线程在<code>Consume</code>被唤醒<code>notifyAll</code>的时候,把它同时也唤醒了，它只不过没有抢到锁，被1号线程执行了，那2号线程的逻辑代码已经在<code><br>if (isProduced) {<br>        try {<br>          LOCK.wait();<br>        } catch (InterruptedException e) {<br>          e.printStackTrace();<br>        }<br>      }<br></code>里面了，所以说它会直接往下走，我这边生产了一个，然后消费的还没有消费，那它抢到锁之后又生产了一个，那不就是重复生产了吗？它就把1号线程生产的给替换掉了，也就是说<code>Consume</code>去消费的时候只会看到第二个，不会看到第一个，这里先改成<code>if</code> 运行的效果</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-comment">// 如果生产了数据，就wait住</span>    <span class="hljs-keyword">if</span> (isProduced) &#123;      <span class="hljs-keyword">try</span> &#123;        LOCK.wait();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;    <span class="hljs-comment">// 如果没有生产，那就生产</span>    i++;    System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);    <span class="hljs-comment">// 唤醒正在该对象的监视器上等待（wait）的单个线程</span>    LOCK.notifyAll();    isProduced = <span class="hljs-keyword">true</span>;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">synchronized</span> (LOCK) &#123;    <span class="hljs-comment">//如果生产数据，那就wait</span>    <span class="hljs-keyword">if</span> (!isProduced) &#123;      <span class="hljs-keyword">try</span> &#123;        LOCK.wait();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;    System.out.println(<span class="hljs-string">"M-&gt;"</span> + i);    LOCK.notifyAll();    isProduced = <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">P-&gt;<span class="hljs-number">1</span>M-&gt;<span class="hljs-number">1</span>P-&gt;<span class="hljs-number">2</span>P-&gt;<span class="hljs-number">3</span>M-&gt;<span class="hljs-number">3</span></code></pre><p class="note note-info">对于这个问题的解决只需要把<code>if</code>换成<code>while</code>即可</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">// 如果生产了数据，就wait住</span>     <span class="hljs-keyword">while</span> (isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;     <span class="hljs-comment">// 如果没有生产，那就生产</span>     i++;     System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);     <span class="hljs-comment">// 唤醒正在该对象的监视器上等待（wait）的单个线程</span>     LOCK.notifyAll();     isProduced = <span class="hljs-keyword">true</span>;   &#125; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-keyword">synchronized</span> (LOCK) &#123;     <span class="hljs-comment">//如果生产数据，那就wait</span>     <span class="hljs-keyword">while</span> (!isProduced) &#123;       <span class="hljs-keyword">try</span> &#123;         LOCK.wait();       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;         e.printStackTrace();       &#125;     &#125;     System.out.println(<span class="hljs-string">"M-&gt;"</span> + i);     LOCK.notifyAll();     isProduced = <span class="hljs-keyword">false</span>;   &#125; &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">P-&gt;<span class="hljs-number">1</span>M-&gt;<span class="hljs-number">1</span>P-&gt;<span class="hljs-number">2</span>M-&gt;<span class="hljs-number">2</span>P-&gt;<span class="hljs-number">3</span>M-&gt;<span class="hljs-number">3</span>P-&gt;<span class="hljs-number">4</span>M-&gt;<span class="hljs-number">4</span>P-&gt;<span class="hljs-number">5</span>M-&gt;<span class="hljs-number">5</span>P-&gt;<span class="hljs-number">6</span>M-&gt;<span class="hljs-number">6</span>P-&gt;<span class="hljs-number">7</span>M-&gt;<span class="hljs-number">7</span>P-&gt;<span class="hljs-number">8</span>M-&gt;<span class="hljs-number">8</span>P-&gt;<span class="hljs-number">9</span>M-&gt;<span class="hljs-number">9</span>P-&gt;<span class="hljs-number">10</span>M-&gt;<span class="hljs-number">10</span>P-&gt;<span class="hljs-number">11</span>M-&gt;<span class="hljs-number">11</span>P-&gt;<span class="hljs-number">12</span>M-&gt;<span class="hljs-number">12</span>P-&gt;<span class="hljs-number">13</span>M-&gt;<span class="hljs-number">13</span>P-&gt;<span class="hljs-number">14</span>M-&gt;<span class="hljs-number">14</span>P-&gt;<span class="hljs-number">15</span>M-&gt;<span class="hljs-number">15</span>P-&gt;<span class="hljs-number">16</span>M-&gt;<span class="hljs-number">16</span></code></pre><p class="note note-info">这样就OK了，问题解决，即使线程抢到锁之后，因为它第一个线程已经把它改成<code>true</code>了，你第二次起来之后先到这报道一下:</p><pre><code class="hljs java"><span class="hljs-keyword">while</span> (isProduced) &#123;        <span class="hljs-keyword">try</span> &#123;          LOCK.wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();&#125;</code></pre><p class="note note-info">判断是否允许放行，如果这个条件成立就继续呆着<code>(wait)</code>，</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22.多Produce多Consume之间的通讯导致出现程序假死的原因分析</title>
    <link href="/juc-actualCombat-1-22.html"/>
    <url>/juc-actualCombat-1-22.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">对于上一章的代码是存在问题的，来看看它在多线程的情况</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ProducerConsumerVersion2 pc = <span class="hljs-keyword">new</span> ProducerConsumerVersion2();    Stream        .of(<span class="hljs-string">"P1"</span>, <span class="hljs-string">"p2"</span>)        .forEach(item -&gt; &#123;          <span class="hljs-keyword">new</span> Thread(item) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                pc.produce();              &#125;            &#125;          &#125;.start();        &#125;);    Stream        .of(<span class="hljs-string">"C1"</span>, <span class="hljs-string">"C2"</span>)        .forEach(item -&gt; &#123;          <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"P2"</span>) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;              <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                pc.consume();              &#125;            &#125;          &#125;.start();        &#125;);  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">P-&gt;<span class="hljs-number">1</span>M-&gt;<span class="hljs-number">1</span>P-&gt;<span class="hljs-number">2</span>M-&gt;<span class="hljs-number">2</span>P-&gt;<span class="hljs-number">3</span>M-&gt;<span class="hljs-number">3</span>P-&gt;<span class="hljs-number">4</span>M-&gt;<span class="hljs-number">4</span></code></pre><p class="note note-info">上面结果在3就挂住了，那它有没有死锁呢？</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jps.exe</span>74384 Launcher59876 RemoteMavenServer363896 Jps62248 ProducerConsumerVersion2109944105068 KotlinCompileDaemon<span class="hljs-meta">$</span><span class="bash"> jstack.exe  62248</span>2020-06-29 23:18:27Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.231-b11 mixed mode):"DestroyJavaVM" #18 prio=5 os_prio=0 tid=0x00000000033d3800 nid=0x50f4 waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE"P2" #17 prio=5 os_prio=0 tid=0x0000000020719800 nid=0x14e4c in Object.wait() [0x000000002120f000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076ba16818&gt; (a java.lang.Object)        at java.lang.Object.wait(Object.java:502)        at com.shui.juc.chapter9.ProducerConsumerVersion2.consume(ProducerConsumerVersion2.java:79)        - locked &lt;0x000000076ba16818&gt; (a java.lang.Object)        at com.shui.juc.chapter9.ProducerConsumerVersion2$2.run(ProducerConsumerVersion2.java:45)"P2" #16 prio=5 os_prio=0 tid=0x0000000020718800 nid=0xe984 in Object.wait() [0x000000002110e000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076ba16818&gt; (a java.lang.Object)        at java.lang.Object.wait(Object.java:502)        at com.shui.juc.chapter9.ProducerConsumerVersion2.consume(ProducerConsumerVersion2.java:79)        - locked &lt;0x000000076ba16818&gt; (a java.lang.Object)        at com.shui.juc.chapter9.ProducerConsumerVersion2$2.run(ProducerConsumerVersion2.java:45)"p2" #15 prio=5 os_prio=0 tid=0x000000002070f800 nid=0x16c40 in Object.wait() [0x000000002100f000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076ba16818&gt; (a java.lang.Object)        at java.lang.Object.wait(Object.java:502)        at com.shui.juc.chapter9.ProducerConsumerVersion2.produce(ProducerConsumerVersion2.java:58)        - locked &lt;0x000000076ba16818&gt; (a java.lang.Object)        at com.shui.juc.chapter9.ProducerConsumerVersion2$1.run(ProducerConsumerVersion2.java:30)"P1" #14 prio=5 os_prio=0 tid=0x000000002070c000 nid=0x16ac0 in Object.wait() [0x0000000020f0f000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076ba16818&gt; (a java.lang.Object)        at java.lang.Object.wait(Object.java:502)        at com.shui.juc.chapter9.ProducerConsumerVersion2.produce(ProducerConsumerVersion2.java:58)        - locked &lt;0x000000076ba16818&gt; (a java.lang.Object)        at com.shui.juc.chapter9.ProducerConsumerVersion2$1.run(ProducerConsumerVersion2.java:30)"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x00000000034cc000 nid=0x46c in Object.wait() [0x000000001faaf000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076b708ed8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)        - locked &lt;0x000000076b708ed8&gt; (a java.lang.ref.ReferenceQueue$Lock)        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:216)"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x000000001d08d000 nid=0x56b8 in Object.wait() [0x000000001f9af000]   java.lang.Thread.State: WAITING (on object monitor)        at java.lang.Object.wait(Native Method)        - waiting on &lt;0x000000076b706c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.Object.wait(Object.java:502)        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)        - locked &lt;0x000000076b706c00&gt; (a java.lang.ref.Reference$Lock)        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)"VM Thread" os_prio=2 tid=0x000000001e732800 nid=0x4fa0 runnable"GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00000000033e9000 nid=0x114f4 runnable...JNI global references: 2394</code></pre><p class="note note-info">通过JDK的工具查看发现并没有死锁。说下它的运行流程：</p><ol><li>P1 -&gt; 生产 -&gt; wait</li><li>C1 -&gt; 消费 -&gt; wait + notify </li><li>P2 -&gt; 生产 -&gt; wait + notify </li><li>C2 -&gt; 消费 -&gt; wait + notify </li><li>P1 -&gt; 生产 -&gt; wait + notify </li><li>C1 -&gt; 消费 -&gt; wait + notify </li><li>P2 -&gt; 生产 -&gt; wait + notify </li><li>Cx -&gt; 消费 -&gt; wait + notify </li><li>挂起</li></ol><p class="note note-info">这个<code>ontify</code>的是哪个线程，程序是不知道的。在 <code>wait/notify</code>有一些重要的概念性的内存，它不一定是真实存在的内存，有一块这样的东西，这个会在第二阶段的章节中详细介绍，现在只要清楚<code>wait</code>之后会放弃CPU执行权进入一个<code>wait</code>的状态，然后等待其它线程去唤醒你，对于唤醒的是哪一个，这个JVM没有明确给出规范，像FIFO、Random...都不一样，这个都不好说，这个在第二个阶段会详细介绍。</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21.线程间通信快速入门，使用wait和notify进行线程间的数据通信</title>
    <link href="/juc-actualCombat-1-21.html"/>
    <url>/juc-actualCombat-1-21.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">在应用程序过程中它并不是一个线程，多个线程做同一个事情，有可能是不同线程做不同事情，但是它们之间要做线程的通讯，比如：有多个线程去运行A任务，多个线程去运行去运行B任务，假设任务A是在数据库里拿数据的，拿完数据要把数据交给B，B负责去展示、写文件、发给另外的机器...，任务A产生的数据要交给B去进行接下来的工作，这个时候就导致一个线程之间的通信。接下来就介绍</p><p class="note note-info">来一个案例。一个线程负责生产，每生产一次，另外一个线程就来消费一次</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/29 19:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerVersion1</span> </span>&#123;  <span class="hljs-keyword">private</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ProducerConsumerVersion1 pc = <span class="hljs-keyword">new</span> ProducerConsumerVersion1();    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"P"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          pc.produce();        &#125;      &#125;    &#125;.start();    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"C"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          pc.consume();        &#125;      &#125;    &#125;.start();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 生产</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"P-&gt;"</span> + (i++));    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 消费</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"C-&gt;"</span> + i);    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">P-&gt;<span class="hljs-number">18914</span>P-&gt;<span class="hljs-number">18915</span>P-&gt;<span class="hljs-number">18916</span>P-&gt;<span class="hljs-number">18917</span>P-&gt;<span class="hljs-number">18918</span>P-&gt;<span class="hljs-number">18919</span>P-&gt;<span class="hljs-number">18920</span>P-&gt;<span class="hljs-number">18921</span>P-&gt;<span class="hljs-number">18922</span>P-&gt;<span class="hljs-number">18923</span>P-&gt;<span class="hljs-number">18924</span>M-&gt;<span class="hljs-number">18924</span>...</code></pre><p class="note note-info">上面结果和预期不一样，从上面结果看到生产很多次，才消费一次。这个是什么原因引起的？这是因为它们两之间没有进行通讯引起的，对于消费的线程来说另外的线程生产了它是不知道的，然后它要消费的 <code>i</code>是不是最新的，现在它什么都不知道，只要它碰到了就去读了，所以就出现这个问题。那么做一个改进的版本来解决这个吧。就是说生产完了就去通知消费的线程，如果没有消费那生产的线程就不生产</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter9;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 生产消费者v2</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/29 21:51</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumerVersion2</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 是否生产</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isProduced;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ProducerConsumerVersion2 pc = <span class="hljs-keyword">new</span> ProducerConsumerVersion2();    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"P"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          pc.produce();        &#125;      &#125;    &#125;.start();    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"M"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          pc.consume();        &#125;      &#125;    &#125;.start();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      <span class="hljs-comment">//如果已经生产了，调用 wait 方法</span>      <span class="hljs-keyword">if</span> (isProduced) &#123;        <span class="hljs-keyword">try</span> &#123;          LOCK.wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace();&#125;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//如果没有生产，那就生产</span>        i++;        System.out.println(<span class="hljs-string">"P-&gt;"</span> + i);        <span class="hljs-comment">//唤醒正在该对象的监视器上等待（wait）的单个线程</span>        LOCK.notify();        isProduced = <span class="hljs-keyword">true</span>;      &#125;    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      <span class="hljs-keyword">if</span> (isProduced) &#123;        System.out.println(<span class="hljs-string">"M-&gt;"</span> + i);        LOCK.notify();        isProduced = <span class="hljs-keyword">false</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">try</span> &#123;          LOCK.wait();        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">P-&gt;<span class="hljs-number">1</span>M-&gt;<span class="hljs-number">1</span>P-&gt;<span class="hljs-number">2</span>M-&gt;<span class="hljs-number">2</span>P-&gt;<span class="hljs-number">3</span>M-&gt;<span class="hljs-number">3</span>P-&gt;<span class="hljs-number">4</span>M-&gt;<span class="hljs-number">4</span>P-&gt;<span class="hljs-number">5</span>M-&gt;<span class="hljs-number">5</span>P-&gt;<span class="hljs-number">6</span>M-&gt;<span class="hljs-number">6</span>P-&gt;<span class="hljs-number">7</span>M-&gt;<span class="hljs-number">7</span>P-&gt;<span class="hljs-number">8</span>M-&gt;<span class="hljs-number">8</span>...</code></pre><p class="note note-light">总结</p><p>在上面案例中使用了<code>wait</code>、<code>notify</code>这里介绍一下</p><p class="note note-light">public final void wait()</p><pre><code class="hljs oxygene">使当前线程等待，直到另一个线程为此对象调用<span class="hljs-keyword">notify</span>（）方法或notifyAll（）方法。换句话说，这个方法的行为就像它只是执行调用等待（<span class="hljs-number">0</span>）一样。 当前线程必须拥有此对象的监视器。线程释放此监视器的所有权并等待，直到另一个线程通过调用<span class="hljs-keyword">notify</span>方法或notifyAll方法通知等待此对象监视器唤醒的线程。然后线程等待，直到它可以重新获得监视器的所有权并继续执行。 在单参数版本中，中断和虚假唤醒是可能的，此方法应始终在循环中使用</code></pre><p class="note note-light">public final void notify()</p><pre><code class="hljs bash">唤醒正在该对象的监视器上等待的单个线程。如果有线程正在等待此对象，则选择其中一个线程被唤醒。这种选择是任意的，由实现的自由裁量权决定。线程通过调用<span class="hljs-built_in">wait</span>方法之一等待对象的监视器。 在当前线程放弃对该对象的锁定之前，唤醒的线程将无法继续。被唤醒的线程将以通常的方式与任何其他线程竞争，这些线程可能正积极地在该对象上进行同步；例如，被唤醒的线程在成为下一个锁定此对象的线程时没有可靠的特权或劣势。 此方法只能由作为此对象监视器所有者的线程调用。线程通过以下三种方式之一成为对象监视器的所有者： 通过执行该对象的同步实例方法。 通过执行在对象上同步的同步语句体。 对于类类型的对象，通过执行该类的同步静态方法。 一次只能有一个线程拥有一个对象的监视器。</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20.多线程死锁分析，案例介绍</title>
    <link href="/juc-actualCombat-1-20.html"/>
    <url>/juc-actualCombat-1-20.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">在前面章节介绍了通过<code>synchronized</code>修饰方法、代码块。这个锁可以让区间里面的东西可以串行执行，起到了数据保护的作用，但是它也有一个风险：会引起死锁。在什么情况会出现死锁呢？在这个章节介绍什么情况回出现死锁，怎么通过JDK的一些命令去查看程序有没有死锁住。有时候程序在运行的过程中什么事都没干日志不输出、CPU没变化这个时候它极有可能它进入了死锁的状态。接下来编写一个死锁案例</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/26 17:47</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLock</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> OtherService otherService;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DeadLock</span><span class="hljs-params">(OtherService otherService)</span> </span>&#123;    <span class="hljs-keyword">this</span>.otherService = otherService;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"m1"</span>);      otherService.s1();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"m2"</span>);    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/26 17:47</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OtherService</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> DeadLock deadLock;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s1</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"S1==================="</span>);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">s2</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">synchronized</span> (LOCK) &#123;      System.out.println(<span class="hljs-string">"S2==================="</span>);      deadLock.m2();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDeadLock</span><span class="hljs-params">(DeadLock deadLock)</span> </span>&#123;    <span class="hljs-keyword">this</span>.deadLock = deadLock;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/26 17:56</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    OtherService otherService = <span class="hljs-keyword">new</span> OtherService();    DeadLock deadLock = <span class="hljs-keyword">new</span> DeadLock(otherService);    otherService.setDeadLock(deadLock);    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"t1"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          deadLock.m1();        &#125;      &#125;    &#125;.start();    <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"t2"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          otherService.s2();        &#125;      &#125;    &#125;.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gcode"><span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">1</span>===================<span class="hljs-name">m1</span>S<span class="hljs-number">2</span>===================<span class="hljs-comment">//卡住，不输出内容</span></code></pre><p class="note note-info">通过上面结果看到被卡住了，这是因为<code>DeadLock#m1()</code>执行时候它去调用<code>OtherService#s1()</code>，对于<code>OtherService#s1()</code>来说它也有一个锁的，此时另外的线程已经执行<code>OtherService#s2()</code>，它的内部调用<code>DeadLock#m2</code>，而<code>DeadLock#m2</code>需要<code>DeadLock#m1()</code>是一个锁，所以执行<code>OtherService#s2()</code>的线程卡住了，而<code>DeadLock#m1()</code>的内部调用的<code>OtherService#s1()</code>与<code>OtherService#s2()</code>是一个锁，所以这个线程也卡住了而造成死锁</p><p class="note note-info">通过<code>jstack</code>查看</p><pre><code class="hljs bash">$ jps75844 DeadLockTest$ jstack 75844...Found one Java-level deadlock:=============================<span class="hljs-string">"t2"</span>:  waiting to lock monitor 0x000000001ca23208 (object 0x000000076ba19f48, a java.lang.Object),  <span class="hljs-built_in">which</span> is held by <span class="hljs-string">"t1"</span><span class="hljs-string">"t1"</span>:  waiting to lock monitor 0x000000001ca25bf8 (object 0x000000076ba16f48, a java.lang.Object),  <span class="hljs-built_in">which</span> is held by <span class="hljs-string">"t2"</span>Java stack information <span class="hljs-keyword">for</span> the threads listed above:===================================================<span class="hljs-string">"t2"</span>:        at com.shui.juc.chapter8.DeadLock.m2(DeadLock.java:25)        - waiting to lock &lt;0x000000076ba19f48&gt; (a java.lang.Object)        at com.shui.juc.chapter8.OtherService.s2(OtherService.java:23)        - locked &lt;0x000000076ba16f48&gt; (a java.lang.Object)        at com.shui.juc.chapter8.DeadLockTest<span class="hljs-variable">$2</span>.run(DeadLockTest.java:30)<span class="hljs-string">"t1"</span>:        at com.shui.juc.chapter8.OtherService.s1(OtherService.java:16)        - waiting to lock &lt;0x000000076ba16f48&gt; (a java.lang.Object)        at com.shui.juc.chapter8.DeadLock.m1(DeadLock.java:19)        - locked &lt;0x000000076ba19f48&gt; (a java.lang.Object)        at com.shui.juc.chapter8.DeadLockTest<span class="hljs-variable">$1</span>.run(DeadLockTest.java:20)Found 1 deadlock. <span class="hljs-comment"># 找到一个死锁</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.通过实验分析Class锁的存在</title>
    <link href="/juc-actualCombat-1-19.html"/>
    <url>/juc-actualCombat-1-19.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">有些时候在写代码的时候可能里面会有一些静态类、静态方法，它的那个锁到底是什么样子？如果你不显示用代码块的方式去把它作为方法修饰符去做那它锁的是谁，它用谁做的Monitor？</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStatic</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"m1"</span> + Thread        .currentThread()        .getName());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">3_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"m2"</span> + Thread        .currentThread()        .getName());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">3_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 20:26</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStaticTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T1"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        SynchronizedStatic.m1();      &#125;    &#125;;    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T2"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        SynchronizedStatic.m2();      &#125;    &#125;;    t1.start();    t2.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gcode"><span class="hljs-name">m1</span>T<span class="hljs-number">1</span><span class="hljs-comment">//等待sleep结束才输出一下内容</span><span class="hljs-name">m2</span>T<span class="hljs-number">2</span></code></pre><p class="note note-info">这里它们没有同时输出，可以断定它们2个使用的是同一个锁，那么它到底用的是什么锁？在<code>SynchronizedStatic</code>它可以有一个静态代码块，现在给这个代码块加一个锁，如果有一个方法去调用了非静态的锁的锁</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 20:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStatic</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"m1"</span> + Thread        .currentThread()        .getName());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">3_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"m2"</span> + Thread        .currentThread()        .getName());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">3_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m3</span><span class="hljs-params">()</span> </span>&#123;    System.out.println(<span class="hljs-string">"m3"</span> + Thread        .currentThread()        .getName());    <span class="hljs-keyword">try</span> &#123;      Thread.sleep(<span class="hljs-number">3_000</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 20:26</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStaticTest</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T1"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        SynchronizedStatic.m1();      &#125;    &#125;;    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T2"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        SynchronizedStatic.m2();      &#125;    &#125;;    Thread t3 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T3"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        SynchronizedStatic.m3();      &#125;    &#125;;    t1.start();    t2.start();    t3.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs gcode"><span class="hljs-name">m1</span>T<span class="hljs-number">1</span><span class="hljs-name">m3</span>T<span class="hljs-number">3</span><span class="hljs-comment">//等待sleep结束</span><span class="hljs-name">m2</span>T<span class="hljs-number">2</span></code></pre><p class="note note-info">这里m3是直接输出的，这里怎么让<code>m3</code>去抢锁呢？</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedStatic</span> </span>&#123;  <span class="hljs-keyword">static</span> &#123;    <span class="hljs-keyword">synchronized</span> (SynchronizedStatic<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;      <span class="hljs-keyword">try</span> &#123;        System.out.println(<span class="hljs-string">"static"</span> + Thread            .currentThread()            .getName());        Thread.sleep(<span class="hljs-number">3_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;    ...&#125;</code></pre><p class="note note-info">结果</p><pre><code class="hljs gcode">staticT<span class="hljs-number">1</span>...等待static执行完<span class="hljs-name">m1</span>T<span class="hljs-number">1</span><span class="hljs-name">m3</span>T<span class="hljs-number">3</span><span class="hljs-name">m2</span>T<span class="hljs-number">2</span></code></pre><p class="note note-info">这里T3会等待静态代码块先执行再去执行T3，T1拿到静态代码块，T3去抢静态代码块发现有其它线程在使用，所以它是会被Block住的，那就说明静态代码块<code>synchronized static</code>加的锁就<code>Class锁</code></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18.通过实验分析This锁的存在</title>
    <link href="/juc-actualCombat-1-18.html"/>
    <url>/juc-actualCombat-1-18.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">上一章节说<code>synchronized</code>修饰方法的话实际上加的是<code>this锁</code>，这里通过实验来证明一下，下面请看以下代码</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 19:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedThis</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThisLock thisLock = <span class="hljs-keyword">new</span> ThisLock();    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T1"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; thisLock.m1();&#125;    &#125;;    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"T2"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123; thisLock.m2();&#125;    &#125;;    t1.start();    t2.start();  &#125;  <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThisLock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread            .currentThread()            .getName());        Thread.sleep(<span class="hljs-number">3_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m2</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        System.out.println(Thread            .currentThread()            .getName());        Thread.sleep(<span class="hljs-number">3_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs 1c">T1<span class="hljs-comment">//等待sleep再输出下面内容</span>T2</code></pre><p class="note note-info">这里T1线程调用的是<code>m1</code>，T2线程调用的是<code>m2</code>从结果上来看，T1执行<code>m1</code>的时候T2是需要等待的，所以<code>This锁</code>是存在的</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17.同步代码块以及同步方法之间的区别和关系</title>
    <link href="/juc-actualCombat-1-17.html"/>
    <url>/juc-actualCombat-1-17.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">上一个章节使用<code>synchronized</code>去同步代码块，它还可以去同步方法，可以直接在方法上加上<code>synchronized</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 14:35</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object MONITER = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-meta">@Override</span>→  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">if</span> (index &gt; MAX) <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">5</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;      &#125;      System.out.println(Thread          .currentThread()          .getName() + <span class="hljs-string">"的号码是"</span> + (index++));    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 14:37</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank3</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    SynchronizedRunnable synchronizedRunnable = <span class="hljs-keyword">new</span> SynchronizedRunnable();    Thread t1 = <span class="hljs-keyword">new</span> Thread(synchronizedRunnable, <span class="hljs-string">"一号窗口"</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(synchronizedRunnable, <span class="hljs-string">"二号窗口"</span>);    Thread t3 = <span class="hljs-keyword">new</span> Thread(synchronizedRunnable, <span class="hljs-string">"三号窗口"</span>);    t1.start();    t2.start();    t3.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">一号窗口的号码是<span class="hljs-number">0</span>一号窗口的号码是<span class="hljs-number">1</span>一号窗口的号码是<span class="hljs-number">2</span>一号窗口的号码是<span class="hljs-number">3</span>一号窗口的号码是<span class="hljs-number">4</span>一号窗口的号码是<span class="hljs-number">5</span>一号窗口的号码是<span class="hljs-number">6</span>一号窗口的号码是<span class="hljs-number">7</span>一号窗口的号码是<span class="hljs-number">8</span>一号窗口的号码是<span class="hljs-number">9</span>一号窗口的号码是<span class="hljs-number">10</span>一号窗口的号码是<span class="hljs-number">11</span>一号窗口的号码是<span class="hljs-number">12</span>一号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">14</span>一号窗口的号码是<span class="hljs-number">15</span>一号窗口的号码是<span class="hljs-number">16</span>一号窗口的号码是<span class="hljs-number">17</span>一号窗口的号码是<span class="hljs-number">18</span>一号窗口的号码是<span class="hljs-number">19</span>一号窗口的号码是<span class="hljs-number">20</span>一号窗口的号码是<span class="hljs-number">21</span>一号窗口的号码是<span class="hljs-number">22</span>一号窗口的号码是<span class="hljs-number">23</span>一号窗口的号码是<span class="hljs-number">24</span>一号窗口的号码是<span class="hljs-number">25</span>一号窗口的号码是<span class="hljs-number">26</span>一号窗口的号码是<span class="hljs-number">27</span>一号窗口的号码是<span class="hljs-number">28</span>一号窗口的号码是<span class="hljs-number">29</span>一号窗口的号码是<span class="hljs-number">30</span>一号窗口的号码是<span class="hljs-number">31</span>一号窗口的号码是<span class="hljs-number">32</span>一号窗口的号码是<span class="hljs-number">33</span>一号窗口的号码是<span class="hljs-number">34</span>一号窗口的号码是<span class="hljs-number">35</span>一号窗口的号码是<span class="hljs-number">36</span>一号窗口的号码是<span class="hljs-number">37</span>一号窗口的号码是<span class="hljs-number">38</span>一号窗口的号码是<span class="hljs-number">39</span>一号窗口的号码是<span class="hljs-number">40</span>一号窗口的号码是<span class="hljs-number">41</span>一号窗口的号码是<span class="hljs-number">42</span>一号窗口的号码是<span class="hljs-number">43</span>一号窗口的号码是<span class="hljs-number">44</span>一号窗口的号码是<span class="hljs-number">45</span>一号窗口的号码是<span class="hljs-number">46</span>一号窗口的号码是<span class="hljs-number">47</span>一号窗口的号码是<span class="hljs-number">48</span>一号窗口的号码是<span class="hljs-number">49</span>一号窗口的号码是<span class="hljs-number">50</span></code></pre><p class="note note-info">结果中看出，50个号码都是一个线程完成了，这是为什么？因为在方法中加入<code>synchronized</code>是这么处理的：线程1执行方法之后它会给方法上锁，其它方法是不能执行方法的，要等待线程1完全执行才能执行，但是在线程1执行完成之后线程2去执行方法此时<code>index>50==true</code>了，那么就退出循环体然后当前线程执行结束。对于这种情况，如果就是不想用同步代码块这种情况怎么去把这种线程写到同步方法签名去呢？这里修改一下：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 14:35</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span> (ticket()) <span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">ticket</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (index &gt; MAX)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">5</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"的号码是"</span> + (index++));<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">一号窗口的号码是<span class="hljs-number">0</span>一号窗口的号码是<span class="hljs-number">1</span>二号窗口的号码是<span class="hljs-number">2</span>三号窗口的号码是<span class="hljs-number">3</span>二号窗口的号码是<span class="hljs-number">4</span>三号窗口的号码是<span class="hljs-number">5</span>二号窗口的号码是<span class="hljs-number">6</span>三号窗口的号码是<span class="hljs-number">7</span>二号窗口的号码是<span class="hljs-number">8</span>三号窗口的号码是<span class="hljs-number">9</span>二号窗口的号码是<span class="hljs-number">10</span>三号窗口的号码是<span class="hljs-number">11</span>二号窗口的号码是<span class="hljs-number">12</span>三号窗口的号码是<span class="hljs-number">13</span>二号窗口的号码是<span class="hljs-number">14</span>三号窗口的号码是<span class="hljs-number">15</span>二号窗口的号码是<span class="hljs-number">16</span>三号窗口的号码是<span class="hljs-number">17</span>二号窗口的号码是<span class="hljs-number">18</span>三号窗口的号码是<span class="hljs-number">19</span>二号窗口的号码是<span class="hljs-number">20</span>二号窗口的号码是<span class="hljs-number">21</span>三号窗口的号码是<span class="hljs-number">22</span>二号窗口的号码是<span class="hljs-number">23</span>三号窗口的号码是<span class="hljs-number">24</span>二号窗口的号码是<span class="hljs-number">25</span>三号窗口的号码是<span class="hljs-number">26</span>二号窗口的号码是<span class="hljs-number">27</span>三号窗口的号码是<span class="hljs-number">28</span>二号窗口的号码是<span class="hljs-number">29</span>三号窗口的号码是<span class="hljs-number">30</span>二号窗口的号码是<span class="hljs-number">31</span>三号窗口的号码是<span class="hljs-number">32</span>二号窗口的号码是<span class="hljs-number">33</span>三号窗口的号码是<span class="hljs-number">34</span>二号窗口的号码是<span class="hljs-number">35</span>三号窗口的号码是<span class="hljs-number">36</span>二号窗口的号码是<span class="hljs-number">37</span>三号窗口的号码是<span class="hljs-number">38</span>二号窗口的号码是<span class="hljs-number">39</span>三号窗口的号码是<span class="hljs-number">40</span>二号窗口的号码是<span class="hljs-number">41</span>三号窗口的号码是<span class="hljs-number">42</span>二号窗口的号码是<span class="hljs-number">43</span>三号窗口的号码是<span class="hljs-number">44</span>二号窗口的号码是<span class="hljs-number">45</span>三号窗口的号码是<span class="hljs-number">46</span>二号窗口的号码是<span class="hljs-number">47</span>三号窗口的号码是<span class="hljs-number">48</span>二号窗口的号码是<span class="hljs-number">49</span>三号窗口的号码是<span class="hljs-number">50</span></code></pre><p class="note note-info">使用代码块的代码是这么写的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">ticket</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">if</span> (index &gt; MAX)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">5</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"的号码是"</span> + (index++));<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;&#125;</code></pre><p class="note note-info">这个效果与上面是一样的，对于同步方法它加锁的是<code>this</code>，而代码块可以指定其它对象锁</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16.结合jconsole,jstack以及汇编指令认识synchronized关键字</title>
    <link href="/juc-actualCombat-1-16.html"/>
    <url>/juc-actualCombat-1-16.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">上一章介绍了线程安全的问题，通过银行叫号的例子发现它在多线程情况下会对数据修改产生一些问题，其实在深层次可以把这个问题归结到线程的<code>MemroyCache</code>，它会在后续中介绍。上一章介绍的<code>synchronized</code>到底是什么？它会导致在多线程的时候在它里面的代码变成“单线程”，可以理解为：只要有一个线程进入了<code>synchronized</code>的区域，那其它线程在执行到这的时候需要等待，待上一个线程进入<code>synchronized</code>区域外才能进入，这就使得被<code>synchronized</code>的代码看上去和单线程没有区别了，所以在使用<code>synchronized</code>会影响效率，来看以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-keyword">import</span> java.time.Duration;<span class="hljs-keyword">import</span> java.time.Instant;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 13:13</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Runnable runnable = () -&gt; &#123;      <span class="hljs-keyword">synchronized</span> (LOCK) &#123;        <span class="hljs-keyword">try</span> &#123;          Thread.sleep(<span class="hljs-number">100_000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();        &#125;      &#125;    &#125;;    Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable);    Thread t2 = <span class="hljs-keyword">new</span> Thread(runnable);    Thread t3 = <span class="hljs-keyword">new</span> Thread(runnable);    Instant start = Instant.now();    t1.start();    t2.start();    t3.start();    t1.join();    t2.join();    t3.join();    Instant end = Instant.now();    System.out.println(<span class="hljs-string">"耗时："</span> + Duration        .between(start, end)        .getSeconds() + <span class="hljs-string">"s"</span>);  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs java">耗时：<span class="hljs-number">300</span>s</code></pre><p class="note note-info">上面使用时间为300秒，这和单线程得到的结果没有任何的区别。通过<code>jstack工具</code>查看</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> jps</span>44048 Jps106480 Launcher110136 RemoteMavenServer36113912 SynchronizedTest7546884972 KotlinCompileDaemon<span class="hljs-meta">$</span><span class="bash"> jstack.exe 102088</span>2020-06-25 13:40:13Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.231-b11 mixed mode):"Thread-2" #16 prio=5 os_prio=0 tid=0x0000000020935000 nid=0x19844 waiting for monitor entry [0x000000002136e000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.shui.juc.chapter7.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)        - waiting to lock &lt;0x000000076ba16e68&gt; (a java.lang.Object)        at com.shui.juc.chapter7.SynchronizedTest$$Lambda$1/1879492184.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)"Thread-1" #15 prio=5 os_prio=0 tid=0x0000000020934000 nid=0x1c050 waiting for monitor entry [0x000000002126f000]   java.lang.Thread.State: BLOCKED (on object monitor)        at com.shui.juc.chapter7.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)        - waiting to lock &lt;0x000000076ba16e68&gt; (a java.lang.Object)        at com.shui.juc.chapter7.SynchronizedTest$$Lambda$1/1879492184.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)"Thread-0" #14 prio=5 os_prio=0 tid=0x0000000020933800 nid=0x1856c waiting on condition [0x000000002116f000]   java.lang.Thread.State: TIMED_WAITING (sleeping)        at java.lang.Thread.sleep(Native Method)        at com.shui.juc.chapter7.SynchronizedTest.lambda$main$0(SynchronizedTest.java:18)        - locked &lt;0x000000076ba16e68&gt; (a java.lang.Object)        at com.shui.juc.chapter7.SynchronizedTest$$Lambda$1/1879492184.run(Unknown Source)        at java.lang.Thread.run(Thread.java:748)...</code></pre><p class="note note-info">根据上面的信息可以看到每个线程的状态，<code>Thread-2</code>、<code>Thread-1</code>的状态为<code>block</code><code>Thread-0</code>的状态是 <code>TIMED_WAITING</code></p><p class="note note-info"><code>jconsole</code>看的效果同理，这里就不演示了</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.数据同步的引入与Synchronized的简单介绍</title>
    <link href="/juc-actualCombat-1-15.html"/>
    <url>/juc-actualCombat-1-15.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">在之前做了一个银行叫号的案例，代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindowRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">if</span> (index &gt; MAX) <span class="hljs-keyword">break</span>;      System.out.println(Thread          .currentThread()          .getName() + <span class="hljs-string">"的号码是"</span> + (index++));    &#125;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">final</span> TicketWindowRunnable ticketWindowRunnable = <span class="hljs-keyword">new</span> TicketWindowRunnable();    Thread thread1 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"一号窗口"</span>);    Thread thread2 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"二号窗口"</span>);    Thread thread3 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"三号窗口"</span>);    thread1.start();    thread2.start();    thread3.start();  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">二号窗口的号码是<span class="hljs-number">1</span>二号窗口的号码是<span class="hljs-number">3</span>二号窗口的号码是<span class="hljs-number">4</span>二号窗口的号码是<span class="hljs-number">5</span>二号窗口的号码是<span class="hljs-number">6</span>二号窗口的号码是<span class="hljs-number">7</span>二号窗口的号码是<span class="hljs-number">8</span>二号窗口的号码是<span class="hljs-number">9</span>二号窗口的号码是<span class="hljs-number">10</span>二号窗口的号码是<span class="hljs-number">11</span>二号窗口的号码是<span class="hljs-number">12</span>一号窗口的号码是<span class="hljs-number">0</span>一号窗口的号码是<span class="hljs-number">14</span>三号窗口的号码是<span class="hljs-number">2</span>一号窗口的号码是<span class="hljs-number">15</span>一号窗口的号码是<span class="hljs-number">17</span>一号窗口的号码是<span class="hljs-number">18</span>二号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">19</span>一号窗口的号码是<span class="hljs-number">21</span>一号窗口的号码是<span class="hljs-number">22</span>三号窗口的号码是<span class="hljs-number">16</span>三号窗口的号码是<span class="hljs-number">24</span>三号窗口的号码是<span class="hljs-number">25</span>三号窗口的号码是<span class="hljs-number">26</span>三号窗口的号码是<span class="hljs-number">27</span>三号窗口的号码是<span class="hljs-number">28</span>三号窗口的号码是<span class="hljs-number">29</span>三号窗口的号码是<span class="hljs-number">30</span>三号窗口的号码是<span class="hljs-number">31</span>三号窗口的号码是<span class="hljs-number">32</span>一号窗口的号码是<span class="hljs-number">23</span>一号窗口的号码是<span class="hljs-number">34</span>一号窗口的号码是<span class="hljs-number">35</span>一号窗口的号码是<span class="hljs-number">36</span>二号窗口的号码是<span class="hljs-number">20</span>一号窗口的号码是<span class="hljs-number">37</span>一号窗口的号码是<span class="hljs-number">39</span>一号窗口的号码是<span class="hljs-number">40</span>一号窗口的号码是<span class="hljs-number">41</span>一号窗口的号码是<span class="hljs-number">42</span>一号窗口的号码是<span class="hljs-number">43</span>一号窗口的号码是<span class="hljs-number">44</span>三号窗口的号码是<span class="hljs-number">33</span>一号窗口的号码是<span class="hljs-number">45</span>一号窗口的号码是<span class="hljs-number">47</span>一号窗口的号码是<span class="hljs-number">48</span>一号窗口的号码是<span class="hljs-number">49</span>一号窗口的号码是<span class="hljs-number">50</span>二号窗口的号码是<span class="hljs-number">38</span>三号窗口的号码是<span class="hljs-number">46</span></code></pre><p class="note note-info">上面结果50跑到前面去了，这个可能是因为46先叫了，但是在输出的时候在这个线程它停顿了一下，这个并不奇怪，它并不一定时时刻刻都在运行，它是需要切换的。将它休眠一下</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      <span class="hljs-keyword">if</span> (index &gt; MAX) <span class="hljs-keyword">break</span>;+      <span class="hljs-keyword">try</span> &#123;+        Thread.sleep(<span class="hljs-number">5</span>);+      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123; &#125;      System.out.println(Thread          .currentThread()          .getName() + <span class="hljs-string">"的号码是"</span> + (index++));    &#125;  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">二号窗口的号码是<span class="hljs-number">0</span>一号窗口的号码是<span class="hljs-number">0</span>三号窗口的号码是<span class="hljs-number">1</span>二号窗口的号码是<span class="hljs-number">3</span>一号窗口的号码是<span class="hljs-number">2</span>三号窗口的号码是<span class="hljs-number">2</span>三号窗口的号码是<span class="hljs-number">5</span>二号窗口的号码是<span class="hljs-number">6</span>一号窗口的号码是<span class="hljs-number">4</span>一号窗口的号码是<span class="hljs-number">8</span>二号窗口的号码是<span class="hljs-number">7</span>三号窗口的号码是<span class="hljs-number">7</span>二号窗口的号码是<span class="hljs-number">9</span>一号窗口的号码是<span class="hljs-number">9</span>三号窗口的号码是<span class="hljs-number">10</span>三号窗口的号码是<span class="hljs-number">11</span>二号窗口的号码是<span class="hljs-number">11</span>一号窗口的号码是<span class="hljs-number">12</span>二号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">14</span>三号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">15</span>三号窗口的号码是<span class="hljs-number">15</span>二号窗口的号码是<span class="hljs-number">15</span>一号窗口的号码是<span class="hljs-number">16</span>三号窗口的号码是<span class="hljs-number">17</span>二号窗口的号码是<span class="hljs-number">16</span>二号窗口的号码是<span class="hljs-number">18</span>一号窗口的号码是<span class="hljs-number">18</span>三号窗口的号码是<span class="hljs-number">19</span>一号窗口的号码是<span class="hljs-number">21</span>二号窗口的号码是<span class="hljs-number">20</span>三号窗口的号码是<span class="hljs-number">20</span>二号窗口的号码是<span class="hljs-number">23</span>三号窗口的号码是<span class="hljs-number">22</span>一号窗口的号码是<span class="hljs-number">22</span>二号窗口的号码是<span class="hljs-number">24</span>一号窗口的号码是<span class="hljs-number">24</span>三号窗口的号码是<span class="hljs-number">25</span>一号窗口的号码是<span class="hljs-number">26</span>二号窗口的号码是<span class="hljs-number">26</span>三号窗口的号码是<span class="hljs-number">27</span>一号窗口的号码是<span class="hljs-number">28</span>二号窗口的号码是<span class="hljs-number">28</span>三号窗口的号码是<span class="hljs-number">28</span>三号窗口的号码是<span class="hljs-number">29</span>二号窗口的号码是<span class="hljs-number">29</span>一号窗口的号码是<span class="hljs-number">29</span>二号窗口的号码是<span class="hljs-number">30</span>三号窗口的号码是<span class="hljs-number">31</span>一号窗口的号码是<span class="hljs-number">30</span>三号窗口的号码是<span class="hljs-number">32</span>一号窗口的号码是<span class="hljs-number">32</span>二号窗口的号码是<span class="hljs-number">32</span>三号窗口的号码是<span class="hljs-number">34</span>二号窗口的号码是<span class="hljs-number">33</span>一号窗口的号码是<span class="hljs-number">33</span>二号窗口的号码是<span class="hljs-number">35</span>三号窗口的号码是<span class="hljs-number">37</span>一号窗口的号码是<span class="hljs-number">36</span>一号窗口的号码是<span class="hljs-number">38</span>三号窗口的号码是<span class="hljs-number">39</span>二号窗口的号码是<span class="hljs-number">38</span>一号窗口的号码是<span class="hljs-number">40</span>二号窗口的号码是<span class="hljs-number">40</span>三号窗口的号码是<span class="hljs-number">41</span>一号窗口的号码是<span class="hljs-number">42</span>三号窗口的号码是<span class="hljs-number">43</span>二号窗口的号码是<span class="hljs-number">42</span>三号窗口的号码是<span class="hljs-number">44</span>一号窗口的号码是<span class="hljs-number">45</span>二号窗口的号码是<span class="hljs-number">44</span>一号窗口的号码是<span class="hljs-number">46</span>三号窗口的号码是<span class="hljs-number">47</span>二号窗口的号码是<span class="hljs-number">46</span>二号窗口的号码是<span class="hljs-number">48</span>一号窗口的号码是<span class="hljs-number">48</span>三号窗口的号码是<span class="hljs-number">49</span>一号窗口的号码是<span class="hljs-number">50</span>二号窗口的号码是<span class="hljs-number">50</span>三号窗口的号码是<span class="hljs-number">51</span></code></pre><p class="note note-info">这里怎么会出现51号呢？这是是线程数据同步引起的，到底是怎么发生的？</p><p>假设3个线程执行到<code>MAX</code>了，当前<code>index=50</code>，这3个线程都满足条件，2号线程已经通过<code>if</code>的判断，走到 <code>System.out.print</code>中，1号线程此时正在进行<code>if</code>判断，但是在这个时候2号线程还并没有去真正执行，所以此时<code>index=49</code>在二号线程执行完打印50时，一号线程再去打印此时此刻就不是50++，而是51++，所以打印出来的是51</p><p class="note note-info">通过<code>synchronized</code>解决</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter7;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindowRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;+  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object MONITER = <span class="hljs-keyword">new</span> Object();  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;+      <span class="hljs-keyword">synchronized</span> (MONITER) &#123;        <span class="hljs-keyword">if</span> (index &gt; MAX) <span class="hljs-keyword">break</span>;        <span class="hljs-keyword">try</span> &#123;          Thread.sleep(<span class="hljs-number">5</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;        &#125;        System.out.println(Thread            .currentThread()            .getName() + <span class="hljs-string">"的号码是"</span> + (index++));      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">一号窗口的号码是<span class="hljs-number">0</span>一号窗口的号码是<span class="hljs-number">1</span>一号窗口的号码是<span class="hljs-number">2</span>一号窗口的号码是<span class="hljs-number">3</span>一号窗口的号码是<span class="hljs-number">4</span>一号窗口的号码是<span class="hljs-number">5</span>一号窗口的号码是<span class="hljs-number">6</span>一号窗口的号码是<span class="hljs-number">7</span>一号窗口的号码是<span class="hljs-number">8</span>一号窗口的号码是<span class="hljs-number">9</span>一号窗口的号码是<span class="hljs-number">10</span>一号窗口的号码是<span class="hljs-number">11</span>一号窗口的号码是<span class="hljs-number">12</span>一号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">14</span>一号窗口的号码是<span class="hljs-number">15</span>一号窗口的号码是<span class="hljs-number">16</span>一号窗口的号码是<span class="hljs-number">17</span>一号窗口的号码是<span class="hljs-number">18</span>一号窗口的号码是<span class="hljs-number">19</span>一号窗口的号码是<span class="hljs-number">20</span>一号窗口的号码是<span class="hljs-number">21</span>一号窗口的号码是<span class="hljs-number">22</span>一号窗口的号码是<span class="hljs-number">23</span>一号窗口的号码是<span class="hljs-number">24</span>一号窗口的号码是<span class="hljs-number">25</span>一号窗口的号码是<span class="hljs-number">26</span>一号窗口的号码是<span class="hljs-number">27</span>一号窗口的号码是<span class="hljs-number">28</span>一号窗口的号码是<span class="hljs-number">29</span>一号窗口的号码是<span class="hljs-number">30</span>一号窗口的号码是<span class="hljs-number">31</span>一号窗口的号码是<span class="hljs-number">32</span>一号窗口的号码是<span class="hljs-number">33</span>一号窗口的号码是<span class="hljs-number">34</span>一号窗口的号码是<span class="hljs-number">35</span>一号窗口的号码是<span class="hljs-number">36</span>一号窗口的号码是<span class="hljs-number">37</span>一号窗口的号码是<span class="hljs-number">38</span>一号窗口的号码是<span class="hljs-number">39</span>一号窗口的号码是<span class="hljs-number">40</span>一号窗口的号码是<span class="hljs-number">41</span>一号窗口的号码是<span class="hljs-number">42</span>一号窗口的号码是<span class="hljs-number">43</span>一号窗口的号码是<span class="hljs-number">44</span>一号窗口的号码是<span class="hljs-number">45</span>一号窗口的号码是<span class="hljs-number">46</span>一号窗口的号码是<span class="hljs-number">47</span>一号窗口的号码是<span class="hljs-number">48</span>一号窗口的号码是<span class="hljs-number">49</span>一号窗口的号码是<span class="hljs-number">50</span>Process finished with exit code <span class="hljs-number">0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14.编写ThreadService实现暴力结束线程</title>
    <link href="/juc-actualCombat-1-14.html"/>
    <url>/juc-actualCombat-1-14.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">这一章介绍如何强制结束线程，举个例子：读一个网络资源、做一些比较耗时的事情，期望是30分钟执行完成，超过30分钟就认为是失败的就不等待它了，通过暴力的方式去结束，但是在JDK暴力的方式只有<code>stop()</code>，这个方式已经被弃用了，那么用什么方式来做这个呢？</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter6;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 10:18</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadService</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 执行线程</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread executeThread;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> finished = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 执行一个异步任务</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;    executeThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      Thread runner = <span class="hljs-keyword">new</span> Thread(task);      runner.setDaemon(<span class="hljs-keyword">true</span>);      runner.start();      <span class="hljs-keyword">try</span> &#123;        runner.join();        finished = <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;      &#125;    &#125;);    executeThread.start();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 关闭</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-keyword">long</span> mills)</span> </span>&#123;    <span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();    <span class="hljs-comment">//如果没有执行结束</span>    <span class="hljs-keyword">while</span> (!finished) &#123;      <span class="hljs-comment">//超时</span>      <span class="hljs-keyword">if</span> ((System.currentTimeMillis() - currentTime) &gt;= mills) &#123;        System.out.println(<span class="hljs-string">"任务超时，需要结束它"</span>);        executeThread.interrupt();        <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-keyword">try</span> &#123;        executeThread.sleep(<span class="hljs-number">1</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        System.out.println(<span class="hljs-string">"执行线程被打断"</span>);        <span class="hljs-keyword">break</span>;      &#125;    &#125;    finished = <span class="hljs-keyword">false</span>;  &#125;&#125;</code></pre><p class="note note-info">上面的代码通过守护线程的特性加上<code>interrupt()</code>通过<code>join()</code>感知被打断来实现，测试一下结果</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter6;<span class="hljs-keyword">import</span> java.time.Duration;<span class="hljs-keyword">import</span> java.time.Instant;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 10:37</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCloseForce</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    ThreadService service = <span class="hljs-keyword">new</span> ThreadService();    Instant start = Instant.now();    service.execute(() -&gt; &#123;      <span class="hljs-comment">//模拟加载非常庞大的资源</span>      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;      &#125;      <span class="hljs-comment">/*try &#123;</span><span class="hljs-comment">        Thread.sleep(5_000);</span><span class="hljs-comment">      &#125; catch (InterruptedException ignored) &#123;</span><span class="hljs-comment">      &#125;*/</span>    &#125;);    <span class="hljs-comment">//设置10秒超时</span>    service.shutdown(<span class="hljs-number">10_000</span>);    Instant end = Instant.now();    System.out.println(Duration        .between(start, end)        .getSeconds());  &#125;&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs awk">任务超时，需要结束它<span class="hljs-number">10</span>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span></code></pre><pre><code class="hljs java">service.execute(() -&gt; &#123;     <span class="hljs-comment">//模拟加载非常庞大的资源</span>    <span class="hljs-comment">/* while (true)&#123;</span><span class="hljs-comment"></span><span class="hljs-comment">     &#125;*/</span>     <span class="hljs-keyword">try</span> &#123;       Thread.sleep(<span class="hljs-number">5_000</span>);     &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignored) &#123;     &#125;   &#125;);</code></pre><p class="note note-light">结果</p><pre><code class="hljs awk"><span class="hljs-number">5</span>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13.采用优雅的方式结束线程生命周期</title>
    <link href="/juc-actualCombat-1-13.html"/>
    <url>/juc-actualCombat-1-13.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">通过变量改变来结束</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter6;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 8:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCloseGraceful</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Worker worker = <span class="hljs-keyword">new</span> Worker();    worker.start();    Thread.sleep(<span class="hljs-number">10_000</span>);    worker.shutdown();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> start = <span class="hljs-keyword">true</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (start) &#123;      &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">this</span>.start = <span class="hljs-keyword">false</span>;    &#125;  &#125;&#125;</code></pre><p class="note note-info"><code>interrupt()</code>结束</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter6;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 8:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCloseGraceful2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Worker worker = <span class="hljs-keyword">new</span> Worker();    worker.start();    Thread.sleep(<span class="hljs-number">10_000</span>);    System.out.println(<span class="hljs-string">"interrupt"</span>);    worker.interrupt();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-comment">//HTTP通讯</span>        <span class="hljs-keyword">try</span> &#123;          Thread.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          <span class="hljs-keyword">break</span>;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-info">通过<code>isInterrupted()</code>结束</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter6;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/25 8:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadCloseGraceful3</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Worker worker = <span class="hljs-keyword">new</span> Worker();    worker.start();    Thread.sleep(<span class="hljs-number">3_000</span>);    System.out.println(<span class="hljs-string">"interrupt"</span>);    worker.interrupt();  &#125;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        <span class="hljs-comment">//HTTP通讯</span>        <span class="hljs-keyword">if</span> (isInterrupted()) &#123;          <span class="hljs-keyword">break</span>;        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p class="note note-info">在有一些场景中，通过上面的方式无法结束线程周期，比如：这是一个很耗时间的操作，期望花30分钟结束，但是它需要一个小时时间，这里你无论是打断它还是给它<code>boolean flag</code>都没用，它是在执行操作的时候<code>block</code>了，那么怎么做？你没有机会去打断，它<code>block</code>住了，它没法监听<code>interrupted</code>也没有机会去读<code>boolean flag</code>，及时它有<code>shutdown</code>去改变它，它也没机会去判断让它退出去，这个要怎么做呢？这个会在下一个章节进行介绍</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> flag=<span class="hljs-keyword">true</span>;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;               <span class="hljs-comment">//block</span>     &#125;   &#125; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12.Thread中断-Interrupt方法</title>
    <link href="/juc-actualCombat-1-12.html"/>
    <url>/juc-actualCombat-1-12.html</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span></span></code></pre><ul><li>中断该线程。</li><li>除非当前线程被中断本身，它总是允许的，所述<code>checkAccess</code>该线程的方法被调用，这可能导致<code>SecurityException</code>被抛出。<br>如果该线程被阻塞在的调用<code>wait()</code> ， <code>wait(long)</code> ，或者<code>wait(long, int)</code>的方法的 Object 类，或者在<code>join()</code> <code>join(long)</code> ， <code>join(long, int)</code> ， <code>sleep(long)</code> ，或<code>sleep(long, int)</code>这个类的方法，那么它的中断状态将被清除，它还将收到一个<code>InterruptedException</code> 。</li><li>如果该线程在可阻止在<code>I/O</code>操作<code>InterruptibleChannel</code>则信道将被关闭，该线程的中断状态将被设置，并且线程将收到一个<code>java.nio.channels.ClosedByInterruptException</code> 。</li><li>如果这个线程被阻塞在<code>java.nio.channels.Selector</code>则该线程的中断状态将被设置，它会从选择操作立即返回，可能有非零值，就好像选择的<code>wakeup</code>方法被调用。<br>如果没有以前的条件保存，则该线程的中断状态将被设置。<br>中断一个线程是不是还活着需求不会有任何效果。</li></ul><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;      &#125;    &#125;  &#125;;  t1.start();  Thread.sleep(<span class="hljs-number">1000</span>);  System.out.println(t1.isInterrupted());  t1.interrupt();  System.out.println(t1.isInterrupted());&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs yaml"><span class="hljs-literal">false</span><span class="hljs-literal">true</span></code></pre><p class="note note-info">这个时候并没有被中断，这是什么情况？原因是因为它没有被捕获到或者说是没有接受到信号，它会抛出异常，但是这里的代码没有任何捕获的语句，上面介绍的方式就能够捕获到</p><p class="note note-info">那么不通过上面介绍的方式当前线程能感应到吗？这里改一下代码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Thread t1 = <span class="hljs-keyword">new</span> Thread()&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;        System.out.println(<span class="hljs-keyword">this</span>.isInterrupted());      &#125;    &#125;  &#125;;  t1.start();  Thread.sleep(<span class="hljs-number">1000</span>);  System.out.println(t1.isInterrupted());  t1.interrupt();  System.out.println(t1.isInterrupted());&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs erlang"><span class="hljs-literal">false</span>...<span class="hljs-literal">true</span>...</code></pre><p class="note note-success">从上面结果可以看出，它还是能感应到其它线程通过 <code>interrupt()</code>而得到的信号</p><p class="note note-info">这里来看一下 <code>interrupt()</code>的源码</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != Thread.currentThread())            checkAccess();        <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;            Interruptible b = blocker;            <span class="hljs-keyword">if</span> (b != <span class="hljs-keyword">null</span>) &#123;                interrupt0();           <span class="hljs-comment">// 只是设置中断标志</span>                b.interrupt(<span class="hljs-keyword">this</span>);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        interrupt0();    &#125;</code></pre><p class="note note-info"><code>interrupt0();</code>这里有一个注释：<code>只是设置中断标志</code>，就说不管<code>run()</code>中有没有最上面介绍那3种类型的方法去调用它h会被<code>interrupt start</code>进行设置，我们现在这个修改之后的代码只是因为它没有捕获到异常所以它退不出来，这里对它进行改进一下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;          System.out.println(<span class="hljs-keyword">this</span>.isInterrupted());          Thread.sleep(<span class="hljs-number">10_000</span>);        &#125;      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        System.out.println(<span class="hljs-string">"收到打断信号:"</span> + e.getMessage());      &#125;    &#125;  &#125;;  t1.start();  Thread.sleep(<span class="hljs-number">1000</span>);  System.out.println(t1.isInterrupted());  t1.interrupt();  System.out.println(t1.isInterrupted());&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs awk">falsefalsetrue收到打断信号:sleep interruptedProcess finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span></code></pre><p class="note note-success">通过<code>sleep</code>可以有效打断</p><p class="note note-info">再来试试其它的打断方式：<code>wait</code></p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object MONITOR = <span class="hljs-keyword">new</span> Object();  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (MONITOR) &#123;              MONITOR.wait(<span class="hljs-number">10</span>);              System.out.println(<span class="hljs-keyword">this</span>.isInterrupted());            &#125;          &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();        &#125;      &#125;    &#125;;    t1.start();    Thread.sleep(<span class="hljs-number">1000</span>);    System.out.println(t1.isInterrupted());    t1.interrupt();    System.out.println(t1.isInterrupted());  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs oxygene"><span class="hljs-keyword">false</span> x n...<span class="hljs-keyword">true</span>java.lang.InterruptedExceptionat java.lang.Object.wait(Native <span class="hljs-function"><span class="hljs-keyword">Method</span>)</span><span class="hljs-function"><span class="hljs-title">at</span> <span class="hljs-title">com</span>.<span class="hljs-title">shui</span>.<span class="hljs-title">juc</span>.<span class="hljs-title">chapter6</span>.<span class="hljs-title">ThreadInterrupt</span>$1.<span class="hljs-title">run</span><span class="hljs-params">(ThreadInterrupt.java:19)</span></span><span class="hljs-function"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 0</span></code></pre><p class="note note-info">通过<code>stop</code>也是能够打断<p><pre><code class="hljs java">...t1.stop();</code></pre><p class="note note-warning"><code>stop</code>不建议去使用，它存在很多的问题</p><p class="note note-info">对于<code>isInterrupted</code>查看线程状态还提供了静态的方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">interrupted</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-keyword">true</span>);   &#125;</code></pre><p class="note note-info">这是不是有些多此一举呢？在现在的代码中，想在当前线程中调用<code>isInterrupted</code>是OK的</p><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            <span class="hljs-keyword">synchronized</span> (MONITOR) &#123;              MONITOR.wait(<span class="hljs-number">10</span>);              System.out.println(<span class="hljs-keyword">this</span>.isInterrupted());            &#125;          &#125;        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;+          System.out.println(isInterrupted());        &#125;      &#125;    &#125;;</code></pre><p class="note note-info">在<code>Thread</code>中<code>run</code>方法调用自己内部其它方法是没有问题的，但是对于通过<code>Runnable</code>就不能这么做了，这个时候就可以使用它提供的静态方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Runnable runnable = () -&gt; &#123;    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;      System.out.println(Thread.interrupted());    &#125;  &#125;;Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable);  t1.start();  t1.interrupt();&#125;</code></pre><p class="note note-info">使用<code>join()</code>感应打断</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;        &#125;      &#125;    &#125;;    t1.start();    Thread main = Thread.currentThread();    Thread t2 = <span class="hljs-keyword">new</span> Thread() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;          sleep(<span class="hljs-number">100</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();        &#125;        main.interrupt();        System.out.println(<span class="hljs-string">"interrupt"</span>);      &#125;    &#125;;    t2.start();    <span class="hljs-keyword">try</span> &#123;      t1.join();    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs css"><span class="hljs-selector-tag">interrupt</span><span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(<span class="hljs-selector-tag">Native</span> <span class="hljs-selector-tag">Method</span>)<span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.join</span>(<span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:1252)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.join</span>(<span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:1326)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter6</span><span class="hljs-selector-class">.ThreadInterrupt3</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">ThreadInterrupt3</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:39)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.Thread的join方法详细介绍</title>
    <link href="/juc-actualCombat-1-11.html"/>
    <url>/juc-actualCombat-1-11.html</url>
    
    <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span></code></pre><p class="note note-info">该线程等待死亡。此方法的调用行为完全相同的方式调用</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span></code></pre><p class="note note-info">最多等待<code>millis</code>毫秒该线程终止。 的超时0手段永远等待。此实现使用的循环<code>this.wait</code>电话空调上<code>this.isAlive</code> 。 作为线程终止<code>this.notifyAll</code>方法被调用。 建议应用程序不使用<code>wait</code> ， <code>notify</code> ，或<code>notifyAll</code>上<code>Thread</code>实例。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis, <span class="hljs-keyword">int</span> nanos)</span></span></code></pre><p class="note note-info">最多等待<code>millis</code>毫秒加上<code>nanos</code>纳秒该线程死亡。此实现使用的循环this.wait电话空调上<code>this.isAlive</code> 。 作为线程终止<code>this.notifyAll</code>方法被调用。 建议应用程序不使用<code>wait</code> ， <code>notify</code> ，或<code>notifyAll</code>上<code>Thread</code>实例。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p class="note note-info">希望main主线程，在子线程执行完以后打印“main”</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   Runnable runnable = () -&gt; IntStream       .range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)       .forEach(item -&gt; System.out.println(Thread           .currentThread()           .getName() + <span class="hljs-string">":"</span> + item));   Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t1"</span>);   Thread t2 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t2"</span>);   Thread t3 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t3"</span>);   t1.start();   t2.start();   t3.start();   System.out.println(<span class="hljs-string">"main"</span>); &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">maint2:<span class="hljs-number">1</span>t2:<span class="hljs-number">2</span>t2:<span class="hljs-number">3</span>t2:<span class="hljs-number">4</span>t2:<span class="hljs-number">5</span>t2:<span class="hljs-number">6</span>t2:<span class="hljs-number">7</span>t1:<span class="hljs-number">1</span>...</code></pre><p class="note note-info">这里通过<code>join</code>修改一下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Runnable runnable = () -&gt; IntStream        .range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)        .forEach(item -&gt; System.out.println(Thread            .currentThread()            .getName() + <span class="hljs-string">":"</span> + item));    Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t1"</span>);    Thread t2 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t2"</span>);    Thread t3 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t3"</span>);    t1.start();    t2.start();    t3.start();    t1.join();    t2.join();    t3.join();    System.out.println(<span class="hljs-string">"main"</span>);  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs java">...t3:<span class="hljs-number">2</span>t3:<span class="hljs-number">3</span>t3:<span class="hljs-number">4</span>t3:<span class="hljs-number">5</span>t3:<span class="hljs-number">6</span>t3:<span class="hljs-number">7</span>t3:<span class="hljs-number">8</span>t3:<span class="hljs-number">9</span>main</code></pre><p class="note note-warning"><code>join</code>只会使当前调用它线程去等待，其它线程不会受到影响</p><p class="note note-info">现在改造上面的代码：<code>线程2</code>必须等待<code>线程1</code>执行完再去执行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Runnable runnable = () -&gt; IntStream      .range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)      .forEach(item -&gt; &#123;        <span class="hljs-keyword">try</span> &#123;          Thread.sleep(<span class="hljs-number">100</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;        &#125;        System.out.println(Thread            .currentThread()            .getName() + <span class="hljs-string">":"</span> + item);      &#125;);  Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t1"</span>);  Thread t2 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t2"</span>)&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        t1.join();      &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;      &#125;      <span class="hljs-keyword">super</span>.run();    &#125;  &#125;;  t1.start();  t2.start();  t1.join();  t2.join();  System.out.println(<span class="hljs-string">"main"</span>);&#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs angelscript">t1:<span class="hljs-number">1</span>t1:<span class="hljs-number">2</span>t1:<span class="hljs-number">3</span>t1:<span class="hljs-number">4</span>t1:<span class="hljs-number">5</span>t1:<span class="hljs-number">6</span>t1:<span class="hljs-number">7</span>t1:<span class="hljs-number">8</span>t1:<span class="hljs-number">9</span>t2:<span class="hljs-number">1</span>t2:<span class="hljs-number">2</span>t2:<span class="hljs-number">3</span>t2:<span class="hljs-number">4</span>t2:<span class="hljs-number">5</span>t2:<span class="hljs-number">6</span>t2:<span class="hljs-number">7</span>t2:<span class="hljs-number">8</span>t2:<span class="hljs-number">9</span>main</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10.线程ID，优先级</title>
    <link href="/juc-actualCombat-1-10.html"/>
    <url>/juc-actualCombat-1-10.html</url>
    
    <content type="html"><![CDATA[<h1 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;      System.out.println(<span class="hljs-string">"Hello"</span>);      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1_000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;, <span class="hljs-string">"t1"</span>);    System.out.println(<span class="hljs-string">"NAME:"</span>+t.getName());    System.out.println(<span class="hljs-string">"ID:"</span>+t.getId());    System.out.println(<span class="hljs-string">"PRIORITY:"</span>+t.getPriority());  &#125;</code></pre><p class="note note-light">结果</p><pre><code class="hljs avrasm"><span class="hljs-symbol">NAME:</span>t1<span class="hljs-symbol">ID:</span><span class="hljs-number">14</span><span class="hljs-symbol">PRIORITY:</span><span class="hljs-number">5</span></code></pre><p class="note note-info">这里ID为14，这是怎么赋值的？以下<code>getId</code>方法源码：</p><pre><code class="hljs java"><span class="hljs-comment">/* 返回该线程的标识符。 线程ID是在创建该线程时产生正长数。 线程ID是唯一的，它的生命周期内保持不变。 当一个线程被终止时，该线程ID可以重复使用 */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> tid;    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextThreadID</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> ++threadSeqNumber;&#125;    <span class="hljs-comment">/* For generating thread ID */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> threadSeqNumber;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;        <span class="hljs-comment">//...</span>        <span class="hljs-comment">/* Set thread ID */</span>        tid = nextThreadID();    &#125;</code></pre><p class="note note-info">对于上面的ID为14不是1是因为在JVM启动时会先加载一些线程</p><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><p class="note note-light">语法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newPriority)</span></span></code></pre><p class="note note-info">更改线程的优先级。首先checkAccess这个线程的方法被称为不带参数。 这可能导致抛出SecurityException 。否则，该线程的优先级设置为指定的较小newPriority和最大允许的线程的线程组的优先级。</p><p class="note note-light">示例</p><pre><code class="hljs java">Thread t1 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t1"</span>);Thread t2 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t2"</span>);Thread t3 = <span class="hljs-keyword">new</span> Thread(runnable, <span class="hljs-string">"t3"</span>);t3.setPriority(Thread.MAX_PRIORITY);t1.setPriority(Thread.MIN_PRIORITY);t1.setPriority(Thread.NORM_PRIORITY);</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9.Daemon线程的创建以及使用场景分析</title>
    <link href="/juc-actualCombat-1-9.html"/>
    <url>/juc-actualCombat-1-9.html</url>
    
    <content type="html"><![CDATA[<p class="note note-info">来做一个小实验，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;  Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        Thread.sleep(<span class="hljs-number">1000_1000</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125;  &#125;;  thread.start();  Thread.sleep(<span class="hljs-number">50_000</span>);&#125;</code></pre><p class="note note-info">执行以上代码，得出的结果就是main这个主线程结束了以后，创建的这个<code>thread</code>对象线程还在执行，这里通过<code>jconsole</code>来看</p><p class="note note-light">刚开始时：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200620113731716.png" srcset="/img/loading.gif" alt="image-20200620113731716"></p><p class="note note-light">主线程结束，创建的这个线程还在执行</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200620114052367.png" srcset="/img/loading.gif" alt="image-20200620114052367"></p><p class="note note-info">对于这个程序，我希望在主线程结束时，这个名字为<code>Thread-0</code>的线程也跟着结束，这里就用到了本章介绍的<code>daemon</code>（守护线程）。创建的线程是守护线程的方式如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDaemon</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> on)</span></span></code></pre><p class="note note-info">源码的注释是这么描述的：</p><p>将该线程标记无论是守护线程或用户线程。 当只有线程上运行的Java虚拟机退出都是守护线程。<br>线程开始之前此方法必须被调用。</p><p class="note note-info">所以这里可以通过它来实现我想达到的预期，现在的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread thread = <span class="hljs-keyword">new</span> Thread() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;          Thread.sleep(<span class="hljs-number">1000_1000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();        &#125;      &#125;    &#125;;    thread.setDaemon(<span class="hljs-keyword">true</span>);    thread.start();    Thread.sleep(<span class="hljs-number">50_000</span>);  &#125;</code></pre><p class="note note-success">对于一些场景中，一些不重要的操作就可以通过创建守护线程来实现，但是这里要注意一点：主线程可能已经执行完成，在它之中创建的线程如果是守护线程的话，可能还在<code>Runnable</code>状态而主线程结束，这个守护线程也跟着结束了</p><p class="note note-warning">设置守护线程<code>（setDaemon）</code>的时候，一定要在<code>start</code>之前否则它会出现异常</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8.Thread构造函数StackSize</title>
    <link href="/juc-actualCombat-1-8.html"/>
    <url>/juc-actualCombat-1-8.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7.多线程与JVM内存结构的关系，虚拟机栈实验</title>
    <link href="/juc-actualCombat-1-7.html"/>
    <url>/juc-actualCombat-1-7.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.构造Thread对象你也许不知道的几件事</title>
    <link href="/juc-actualCombat-1-6.html"/>
    <url>/juc-actualCombat-1-6.html</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>本文章介绍<code>Thread</code>的构造方法，构造方法的介绍参考-<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">JDK文档</a>，不啰嗦，直接上代码说明</p>          </div><h1 id="默认name"><a href="#默认name" class="headerlink" title="默认name"></a>默认name</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;   Thread t1 = <span class="hljs-keyword">new</span> Thread();   Thread t2 = <span class="hljs-keyword">new</span> Thread();   System.out.println(t1.getName());   System.out.println(t2.getName()); &#125;</code></pre><p class="note note-light">结果</p><p>Thread-0<br>Thread-1</p><p>它的名字为什么是这个样子的？来看源码</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * Allocates a new &#123;<span class="hljs-doctag">@code</span> Thread&#125; object. This constructor has the same</span><span class="hljs-comment">     * effect as &#123;<span class="hljs-doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> (null, null, gname)&#125;, where &#123;<span class="hljs-doctag">@code</span> gname&#125; is a newly generated</span><span class="hljs-comment">     * name. Automatically generated names are of the form</span><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thread</span><span class="hljs-params">()</span> </span>&#123;        init(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-string">"Thread-"</span> + nextThreadNum(), <span class="hljs-number">0</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextThreadNum</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> threadInitNumber++;    &#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;        <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"name cannot be null"</span>);        &#125;        <span class="hljs-keyword">this</span>.name = name;        ...</code></pre><p class="note note-light">翻译</p><p>分配一个新的Thread对象。 此构造具有相同的效果线程 (null, null, gname)其中gname是新生成的名字。 自动生成的名称的形式的”Thread-“+ n，其中n是一个整数。</p><h1 id="调用start方法没反应"><a href="#调用start方法没反应" class="headerlink" title="调用start方法没反应"></a>调用start方法没反应</h1><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread();    t1.start();  &#125;</code></pre><p class="note note-light">结果</p><p>并没有什么</p><p>这个是什么原因？它的源码是这样的：</p><pre><code class="hljs java"><span class="hljs-comment">/*使该线程开始执行; Java虚拟机调用run该线程的方法。</span><span class="hljs-comment">结果是两个线程同时运行：当前线程（从调用返回start方法）和另一个线程（执行其run方法）。</span><span class="hljs-comment">这是从来没有的法律，以启动一个线程不止一次。 特别是，一个线程可能无法一旦完成执行重新启动。*/</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-comment">/**</span><span class="hljs-comment">        *不会为VM创建/设置的主方法线程或“系统” *组线程调用此方法。将来可能会向该方法添加*的任何新功能也必须添加到VM。 * *状          * 态值为零对应于状态“ NEW”</span><span class="hljs-comment">        */</span>       <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();       <span class="hljs-comment">/* 通知组该线程即将开始*，以便可以将其添加到组的线程列表*中，并且该组的未启动计数可以减少。 */</span>       group.add(<span class="hljs-keyword">this</span>);       <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//调用C的方法，</span>           start0();           started = <span class="hljs-keyword">true</span>;       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">if</span> (!started) &#123;                   group.threadStartFailed(<span class="hljs-keyword">this</span>);               &#125;           &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;               <span class="hljs-comment">/* do nothing. 没做什么。如果start0抛出了Throwable，则它将被向上传递到调用堆栈 */</span>           &#125;       &#125;   &#125;<span class="hljs-comment">//C语言的方法，它会去调用自己的run方法</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//如果该线程是使用独立的构造Runnable运行对象，则该Runnable对象的run方法被调用; 否则，此方法不执行任何操作并返回。</span> <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;           target.run();       &#125;   &#125;</code></pre><p class="note note-success">在控制台之所以没有看到任何结果是因为上面代码并没有传递<code>Runnable</code>的实现</p><h1 id="传递Runnable"><a href="#传递Runnable" class="headerlink" title="传递Runnable"></a>传递Runnable</h1><p class="note note-info">对于上面这个，那么我们来对<code>Thread</code>传递一个Runnable实现</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(Thread            .currentThread()            .getName());      &#125;    &#125;);    t1.start();  &#125;</code></pre><p class="note note-light">结果</p><p>T1</p><h1 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h1><p class="note note-info">对于无参构造器初始化，还有一个很重要的参数-<code>ThreadGroup    </code>,对于<code>Thread</code>的构造方法，它都会去调用<code>java.lang.Thread#init(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long, java.security.AccessControlContext, boolean)</code>，这个里面一个参数，就是这里要说的<code>ThreadGroup</code>，对于无参构造器，它对这个值传递了一个null，来看它做了什么</p><pre><code class="hljs java"> <span class="hljs-keyword">if</span> (g == <span class="hljs-keyword">null</span>) &#123;     <span class="hljs-keyword">if</span> (g == <span class="hljs-keyword">null</span>) &#123;         g = parent.getThreadGroup();     &#125; &#125; <span class="hljs-comment">//...</span><span class="hljs-keyword">this</span>.group = g;</code></pre><p class="note note-success">这里它会去赋值上它parent的<code>ThreadGroup</code></p><hr><p class="note note-info">这里就有问题了，它父子的<code>ThreadGroup</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Thread t1 = <span class="hljs-keyword">new</span> Thread();  System.out.println(Thread.currentThread().getThreadGroup());  System.out.println(t1.getThreadGroup());&#125;</code></pre><p class="note note-light">结果</p><p>java.lang.ThreadGroup[name=main,maxpri=10]<br>java.lang.ThreadGroup[name=main,maxpri=10]</p><p class="note note-success">如果没有传递<code>Thread</code>的<code>ThreadGroup</code>，它就会去赋值上创建它对象的<code>ThreadGroup</code>,此时子线程也就是上面代码创建的<code>Thread对象</code>和父线程也就是上面代码的<code>main</code>方法将会在同一个<code>ThreadGroup</code>中</p><hr><p class="note note-info">可以通过<code>ThreadGroup</code>的API获取到自己下面有多少个线程在运行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Runnable target = <span class="hljs-keyword">new</span> Runnable() &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;          TimeUnit.SECONDS.sleep(<span class="hljs-number">100</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;          e.printStackTrace();        &#125;      &#125;    &#125;;    Thread t1 = <span class="hljs-keyword">new</span> Thread(target);    t1.start();    ThreadGroup threadGroup = Thread        .currentThread()        .getThreadGroup();    System.out.println(threadGroup.activeCount());  &#125;</code></pre><p class="note note-light">结果</p><p>2</p><p class="note note-info">在<code>ThreadGroup</code>中有个<code>enumerate</code>方法</p><p>java.lang.ThreadGroup 公有 int enumerate(Thread[] list)<br>拷贝到指定的数组的所有活动线程该线程组及其子组英寸<br>此方法的调用行为完全相同的方式调用<br>枚举 (list, true)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Runnable target = <span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">100</span>);      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();      &#125;    &#125; <span class="hljs-comment">//run</span>  &#125;; <span class="hljs-comment">//Runnable</span>              Thread t1 = <span class="hljs-keyword">new</span> Thread(target, <span class="hljs-string">"T1"</span>);  t1.start();  ThreadGroup threadGroup = Thread      .currentThread()      .getThreadGroup();  <span class="hljs-keyword">int</span> size = threadGroup.activeCount();  Thread[] thread = <span class="hljs-keyword">new</span> Thread[size];  threadGroup.enumerate(thread);  Arrays      .stream(thread)      .forEach(item -&gt; System.out.println(item.getName()));&#125;</code></pre><p class="note note-light">结果</p><p>main<br>T1</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Velocity实现代码生成</title>
    <link href="/other-velocity.html"/>
    <url>/other-velocity.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/shui4444/velocity" target="_blank" rel="noopener">源码链接</a></p><p>通过<code>Maven</code>创建工程，pom文件：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>29.0-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>目录结构：</p><pre><code class="hljs tcl">velocity├── pom.xml├── src│   ├── main│   │   ├── java│   │   │   └── org│   │   │       └── example│   │   │           └── velocity│   │   │               ├── Main.java测试│   │   │               └── model│   │   │                   └── pojo│   │   │                       └── ClassPOJO.java│   │   └── resources│   │       └── template│   │           └── UserEntity.java.vm模板</code></pre><p>ClassPOJO</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.velocity.model.pojo;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassPOJO</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPOJO</span><span class="hljs-params">(String field, String type)</span> </span>&#123;    <span class="hljs-keyword">this</span>.field = field;    <span class="hljs-keyword">this</span>.type = type;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getField</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> field;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setField</span><span class="hljs-params">(String field)</span> </span>&#123;    <span class="hljs-keyword">this</span>.field = field;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> type;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(String type)</span> </span>&#123;    <span class="hljs-keyword">this</span>.type = type;  &#125;  <span class="hljs-keyword">private</span> String field;  <span class="hljs-keyword">private</span> String type;&#125;</code></pre><p>定义模板-UserEntity.java.vm</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> template;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> </span>&#123;    #foreach( $item in $list)<span class="hljs-keyword">private</span> $item.type $item.field    #end&#125;</code></pre><p>使用-Main</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.velocity;<span class="hljs-keyword">import</span> cn.hutool.extra.template.Template;<span class="hljs-keyword">import</span> cn.hutool.extra.template.TemplateConfig;<span class="hljs-keyword">import</span> cn.hutool.extra.template.TemplateEngine;<span class="hljs-keyword">import</span> cn.hutool.extra.template.TemplateUtil;<span class="hljs-keyword">import</span> com.google.common.collect.ImmutableList;<span class="hljs-keyword">import</span> org.example.velocity.model.pojo.ClassPOJO;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ImmutableList&lt;ClassPOJO&gt; list = ImmutableList.of(        <span class="hljs-keyword">new</span> ClassPOJO(<span class="hljs-string">"userId"</span>, <span class="hljs-string">"String"</span>),        <span class="hljs-keyword">new</span> ClassPOJO(<span class="hljs-string">"username"</span>, <span class="hljs-string">"String"</span>)    );    TemplateConfig config = <span class="hljs-keyword">new</span> TemplateConfig();    <span class="hljs-comment">//指定模板的路径位置</span>    config.setResourceMode(TemplateConfig.ResourceMode.CLASSPATH);    TemplateEngine engine = TemplateUtil.createEngine(config);<span class="hljs-comment">//选择模板</span>    Template template = engine.getTemplate(<span class="hljs-string">"template/UserEntity.java.vm"</span>);    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    map.put(<span class="hljs-string">"list"</span>, list);    String text = template.render(map);    System.out.println(text);    OutputStream outputStream = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;      outputStream = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"Test.java"</span>);    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;      e.printStackTrace();    &#125;    template.render(map, outputStream);  &#125;&#125;</code></pre><p>结果</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> template;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> </span>&#123;    <span class="hljs-keyword">private</span> String userId<span class="hljs-keyword">private</span> String username&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>其它</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5.策略模式在Thread和Runnable中的应用分析</title>
    <link href="/juc-actualCombat-1-5.html"/>
    <url>/juc-actualCombat-1-5.html</url>
    
    <content type="html"><![CDATA[<h1 id="策略模式案例"><a href="#策略模式案例" class="headerlink" title="策略模式案例"></a>策略模式案例</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>计算工资税率</p><h2 id="普通实现方式"><a href="#普通实现方式" class="headerlink" title="普通实现方式"></a>普通实现方式</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 税收计算器</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalculator</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 奖金</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> bonus;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 薪水</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> salary;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaxCalculator</span><span class="hljs-params">(<span class="hljs-keyword">double</span> bonus, <span class="hljs-keyword">double</span> salary)</span> </span>&#123;    <span class="hljs-keyword">this</span>.bonus = bonus;    <span class="hljs-keyword">this</span>.salary = salary;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcuate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calcTax();  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getBonus</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> bonus;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> salary;  &#125;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcTax</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>d;  &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalculatorMain</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    TaxCalculator taxCalculator = <span class="hljs-keyword">new</span> TaxCalculator(<span class="hljs-number">10000</span>d, <span class="hljs-number">200</span>d) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcTax</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> getSalary() * <span class="hljs-number">0.1</span> + getBonus() * <span class="hljs-number">0.15</span>;      &#125;    &#125;;  &#125;&#125;</code></pre><p>假设需求改动：税率需要修改，如果程序特别复杂就会付出很多的代价，首先这里需要改变方法的内部，不符合开闭原则，这样做肯定不合理，下面通过策略模式实现</p><h2 id="策略模式实现"><a href="#策略模式实现" class="headerlink" title="策略模式实现"></a>策略模式实现</h2><p> 定义一个计算策略接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 计算策略接口</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ICalculationStrategy</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">double</span> bonus)</span></span>;&#125;</code></pre><p>它的实现类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewCalculationStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculationStrategy</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">double</span> bonus)</span> </span>&#123;    <span class="hljs-keyword">return</span> salary * <span class="hljs-number">0.3</span> + bonus * <span class="hljs-number">0.3</span>;  &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCalculationStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ICalculationStrategy</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">double</span> bonus)</span> </span>&#123;    <span class="hljs-keyword">return</span> salary * <span class="hljs-number">0.1</span> + bonus * <span class="hljs-number">0.15</span>;  &#125;&#125;</code></pre><p>税收计算器-修改版</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 税收计算器</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalculator2</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 奖金</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> bonus;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 薪水</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> salary;  <span class="hljs-keyword">private</span> ICalculationStrategy calculationStrategy;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaxCalculator2</span><span class="hljs-params">(<span class="hljs-keyword">double</span> bonus, <span class="hljs-keyword">double</span> salary, ICalculationStrategy calculationStrategy)</span> </span>&#123;    <span class="hljs-keyword">this</span>.bonus = bonus;    <span class="hljs-keyword">this</span>.salary = salary;    <span class="hljs-keyword">this</span>.calculationStrategy = calculationStrategy;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCalculationStrategy</span><span class="hljs-params">(ICalculationStrategy calculationStrategy)</span> </span>&#123;    <span class="hljs-keyword">this</span>.calculationStrategy = calculationStrategy;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcuate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.calculationStrategy.calculate(salary, bonus);  &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaxCalculatorMain2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    TaxCalculator2 taxCalculator2 = <span class="hljs-keyword">new</span> TaxCalculator2(<span class="hljs-number">10000</span>, <span class="hljs-number">200</span>, <span class="hljs-keyword">new</span> SimpleCalculationStrategy());    System.out.println(taxCalculator2.calcuate());    taxCalculator2.setCalculationStrategy(<span class="hljs-keyword">new</span> NewCalculationStrategy());    System.out.println(taxCalculator2.calcuate());  &#125;&#125;</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实际上在<code>Thread</code>中也使用了这种方式，当你去调用<code>start</code>方法时，它去调用了Runnable接口，这和上面的策略模式是一样的做法，而通过继承<code>Thread</code>类重写<code>run</code>方法就是上面的<strong>普通实现方式</strong> </p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.采用多线程模拟银行排队叫号</title>
    <link href="/juc-actualCombat-1-4.html"/>
    <url>/juc-actualCombat-1-4.html</url>
    
    <content type="html"><![CDATA[<h1 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h1><p>有两种方法来创建一个新的执行线程。一是声明一个类是一类Thread。这类应重写类Thread的run方法。子类的一个实例可以被分配和启动。例如，一个线程计算素数大于规定值可以写成如下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;        <span class="hljs-keyword">long</span> minPrime;        PrimeThread(<span class="hljs-keyword">long</span> minPrime) &#123;            <span class="hljs-keyword">this</span>.minPrime = minPrime;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-comment">// compute primes larger than minPrime</span>             . . .        &#125;    &#125;</code></pre><p>下面的代码将创建一个线程并开始运行：</p><pre><code class="hljs java">PrimeThread p = <span class="hljs-keyword">new</span> PrimeThread(<span class="hljs-number">143</span>);    p.start();</code></pre><hr><p>创建一个线程是声明一个类实现Runnable接口的其他方式。该类实现run方法。那类的一个实例可以分配，作为一个参数传递Thread时创建，并开始。同样的例子在这个其他风格看起来像以下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeRun</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;      <span class="hljs-keyword">long</span> minPrime;      PrimeRun(<span class="hljs-keyword">long</span> minPrime) &#123;          <span class="hljs-keyword">this</span>.minPrime = minPrime;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// compute primes larger than minPrime</span>           . . .      &#125;  &#125;</code></pre><p>下面的代码将创建一个线程并开始运行：</p><pre><code class="hljs java">PrimeRun p = <span class="hljs-keyword">new</span> PrimeRun(<span class="hljs-number">143</span>);<span class="hljs-keyword">new</span> Thread(p).start();</code></pre><h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>前面介绍了2种创建线程的方式，它们到底有什么区别？通过这个案例来体现，现在有这么一个需求：</p><p>3个柜台、3个大屏幕，在大屏幕上会显示第几号，当一个人进去办理业务的时候首先要去抽一个号，对于这个号是怎么来的，它由前面的人办理完业务之后柜员按一下“下一位”这样的一个叫号设备，这里的3柜台，也就是程序中的3个线程并发去工作，号码从1-1000，到了1001就重新从1开始去叫</p><h2 id="继承Thread方式"><a href="#继承Thread方式" class="headerlink" title="继承Thread方式"></a>继承Thread方式</h2><p>创建一个售票窗口类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 售票窗口</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindow</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TicketWindow</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-keyword">this</span>.name = name;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (index &lt;= MAX) &#123;      System.out.println(<span class="hljs-string">"柜台："</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"当前的号码是："</span> + index++);    &#125;  &#125;&#125;</code></pre><p>测试代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 银行大厅</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    TicketWindow ticketWindow1 = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-string">"1号柜台"</span>);    TicketWindow ticketWindow2 = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-string">"2号柜台"</span>);    TicketWindow ticketWindow3 = <span class="hljs-keyword">new</span> TicketWindow(<span class="hljs-string">"3号柜台"</span>);    ticketWindow1.start();    ticketWindow2.start();    ticketWindow3.start();  &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs angelscript">柜台：<span class="hljs-number">1</span>号柜台当前的号码是：<span class="hljs-number">1</span>柜台：<span class="hljs-number">2</span>号柜台当前的号码是：<span class="hljs-number">1</span>柜台：<span class="hljs-number">2</span>号柜台当前的号码是：<span class="hljs-number">2</span>柜台：<span class="hljs-number">3</span>号柜台当前的号码是：<span class="hljs-number">1</span>...柜台：<span class="hljs-number">1</span>号柜台当前的号码是：<span class="hljs-number">50</span>柜台：<span class="hljs-number">3</span>号柜台当前的号码是：<span class="hljs-number">50</span>柜台：<span class="hljs-number">2</span>号柜台当前的号码是：<span class="hljs-number">50</span></code></pre><p>对于这种结果肯定是有问题的，预期希望：1号柜台叫号完 1号，2号柜台叫2号，3号柜台叫3号这样，对于上面<code>Bank</code>中创建3个不同的实例，它们的成员变量当然无法共享</p><h2 id="实现Runnable接口方式"><a href="#实现Runnable接口方式" class="headerlink" title="实现Runnable接口方式"></a>实现Runnable接口方式</h2><p><code>Runnable</code>接口实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TicketWindowRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAX = <span class="hljs-number">50</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">while</span> (index &lt;= <span class="hljs-number">50</span>) &#123;      System.out.println(Thread          .currentThread()          .getName() + <span class="hljs-string">"的号码是"</span> + (index++));    &#125;  &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter2;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/17</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bank2</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-keyword">final</span> TicketWindowRunnable ticketWindowRunnable = <span class="hljs-keyword">new</span> TicketWindowRunnable();    Thread thread1 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"一号窗口"</span>);    Thread thread2 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"二号窗口"</span>);    Thread thread3 = <span class="hljs-keyword">new</span> Thread(ticketWindowRunnable, <span class="hljs-string">"三号窗口"</span>);    thread1.start();    thread2.start();    thread3.start();  &#125;&#125;</code></pre><p>结果：</p><pre><code class="hljs java">一号窗口的号码是<span class="hljs-number">0</span>三号窗口的号码是<span class="hljs-number">2</span>三号窗口的号码是<span class="hljs-number">4</span>三号窗口的号码是<span class="hljs-number">5</span>二号窗口的号码是<span class="hljs-number">1</span>三号窗口的号码是<span class="hljs-number">6</span>一号窗口的号码是<span class="hljs-number">3</span>三号窗口的号码是<span class="hljs-number">8</span>二号窗口的号码是<span class="hljs-number">7</span>三号窗口的号码是<span class="hljs-number">10</span>一号窗口的号码是<span class="hljs-number">9</span>一号窗口的号码是<span class="hljs-number">13</span>一号窗口的号码是<span class="hljs-number">14</span>一号窗口的号码是<span class="hljs-number">15</span>一号窗口的号码是<span class="hljs-number">16</span>一号窗口的号码是<span class="hljs-number">17</span>一号窗口的号码是<span class="hljs-number">18</span>一号窗口的号码是<span class="hljs-number">19</span>一号窗口的号码是<span class="hljs-number">20</span>一号窗口的号码是<span class="hljs-number">21</span>一号窗口的号码是<span class="hljs-number">22</span>一号窗口的号码是<span class="hljs-number">23</span>一号窗口的号码是<span class="hljs-number">24</span>一号窗口的号码是<span class="hljs-number">25</span>三号窗口的号码是<span class="hljs-number">12</span>二号窗口的号码是<span class="hljs-number">11</span>二号窗口的号码是<span class="hljs-number">28</span>二号窗口的号码是<span class="hljs-number">29</span>二号窗口的号码是<span class="hljs-number">30</span>二号窗口的号码是<span class="hljs-number">31</span>二号窗口的号码是<span class="hljs-number">32</span>二号窗口的号码是<span class="hljs-number">33</span>二号窗口的号码是<span class="hljs-number">34</span>二号窗口的号码是<span class="hljs-number">35</span>二号窗口的号码是<span class="hljs-number">36</span>二号窗口的号码是<span class="hljs-number">37</span>二号窗口的号码是<span class="hljs-number">38</span>二号窗口的号码是<span class="hljs-number">39</span>二号窗口的号码是<span class="hljs-number">40</span>三号窗口的号码是<span class="hljs-number">27</span>三号窗口的号码是<span class="hljs-number">42</span>一号窗口的号码是<span class="hljs-number">26</span>三号窗口的号码是<span class="hljs-number">43</span>二号窗口的号码是<span class="hljs-number">41</span>三号窗口的号码是<span class="hljs-number">45</span>一号窗口的号码是<span class="hljs-number">44</span>三号窗口的号码是<span class="hljs-number">47</span>二号窗口的号码是<span class="hljs-number">46</span>二号窗口的号码是<span class="hljs-number">50</span>三号窗口的号码是<span class="hljs-number">49</span>一号窗口的号码是<span class="hljs-number">48</span></code></pre><blockquote><p>NOTES</p><p>这里一个问题：这里的叫号顺序不一样，这个是因为在多个线程操作同一个数据存在线程安全的问题，这个以后再说，这个地方的顺序问题暂时先不管</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现<code>Runnable</code>接口的作用为了将可执行的逻辑单元和线程控制分离开来，更好的体现面向对象思想</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.线程的生命周期以及start方法源码剖析</title>
    <link href="/juc-actualCombat-1-3.html"/>
    <url>/juc-actualCombat-1-3.html</url>
    
    <content type="html"><![CDATA[<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><h2 id="什么时候才是Thread"><a href="#什么时候才是Thread" class="headerlink" title="什么时候才是Thread"></a>什么时候才是Thread</h2><p>当你实例化一个<code>Thread</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread();</code></pre><p>如果在没有调用它的<code>start</code>之前，它其实不能称为<code>Thread</code>，只有<code>start</code>之后才能称为<code>Thread</code>，在它start之后是立刻返回的，在上一章的例子中<code>Thread</code>的run方法还没执行完，<code>main</code>就已经结束就是这个原因。</p><hr><h2 id="声明周期基本状态"><a href="#声明周期基本状态" class="headerlink" title="声明周期基本状态"></a>声明周期基本状态</h2><blockquote><p>一个线程必须经过好几种状态的切换，不管在JDK的并发包，线程其实代表的内只有这一个Thread类，不管是线程池、Callback、Future、ForkJoin，它们都是Thread才能代表它，所以Thread是一个务必掌握的知识</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/7126254-55d47d5ebef3b1e2.jpg" srcset="/img/loading.gif" alt="7126254-55d47d5ebef3b1e2"></p><center>图 1-1 Thread生命周期</center> <h3 id="新建状态（New）"><a href="#新建状态（New）" class="headerlink" title="新建状态（New）"></a>新建状态（New）</h3><p>当线程对象创建后，即进入新建状态，如：<code>Thread t = new MyThread();</code></p><blockquote><p>NOTES</p><p>这里只是实例化，它不属于Thread的声明周期，这个<code>new XXX对象</code>的状态是对象都有的</p></blockquote><h3 id="就绪状态（Runnable）"><a href="#就绪状态（Runnable）" class="headerlink" title="就绪状态（Runnable）"></a>就绪状态（Runnable）</h3><p>当调用线程对象的 start() 方法时，线程即进入就绪状态。处于就绪状态的线程只是说明此线程已经做好准备，随时等待 CPU 调度执行，并不是说执行了 start() 方法就立即执行</p><blockquote><p>NOTES</p><p>在start之后它才能称为一个线程</p></blockquote><h3 id="运行状态（Running）"><a href="#运行状态（Running）" class="headerlink" title="运行状态（Running）"></a>运行状态（Running）</h3><p>当 CPU 开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</p><blockquote><p>在Running状态过程中有可能<code>Runnable</code>,可能把执行权交给了其它线程，现在不能<code>Running</code>进入短暂的休息，因为多个线程之间切换是基于CPU做的，只不过它速度特别快，你看不出来，你以为它是同时跑了很多东西，它的切换速度在纳秒、微秒级看不出来有影响但是对CPU的调度来说它每一个时间点它只能执行一个任务，所以在<code>Running</code>的时候进行切换，它也就进入了<code>Runnable</code>状态</p></blockquote><h3 id="阻塞状态（Blocked）"><a href="#阻塞状态（Blocked）" class="headerlink" title="阻塞状态（Blocked）"></a>阻塞状态（Blocked）</h3><p>处于运行状态中的线程由于某种原因，暂时放弃对 CPU 的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才有机会再次被 CPU 调用以进入到运行状态。</p><blockquote><p>NOTES</p><p><code>Blocked</code>之后无法立即回到<code>Running</code>状态，它必须先到<code>Runnable</code>，比如在<code>run</code>方法中<code>sleep</code>，<code>sleep</code>之后是无法立即执行的，<code>sleep</code>之后它会进入<code>Runnable</code>状态，这个时候继续走<code>Runnable</code>的流程：随时等待CPU调度执行。</p></blockquote><hr><p>阻塞状态分类</p><ul><li>等待阻塞：运行状态中的线程执行 <code>wait ()</code> 方法，使本线程进入到等待阻塞状态；</li><li>同步阻塞：线程在获取 <code>synchronized</code> 同步锁失败（因为锁被其它线程占用），它会进入到同步阻塞状态；</li><li>其他阻塞：通过调用线程的 <code>sleep () 或 join ()</code> 或发出 I/O 请求时，线程会进入到阻塞状态。当 <code>sleep()</code> 状态超时、<code>join()</code> 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。</li></ul><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><ul><li>在<code>Running</code>正常结束之后线程是可以终结的，<code>Blocked</code>抢锁的时候你将它打断了，比如通过<code>wait</code>进行打断，它也可能会线程进入终结状态。</li><li>在<code>Runnable</code>过程中死了，也有可能出现终结状态</li></ul><h1 id="start方法源码剖析"><a href="#start方法源码剖析" class="headerlink" title="start方法源码剖析"></a>start方法源码剖析</h1><h2 id="JDK文档的介绍的实验"><a href="#JDK文档的介绍的实验" class="headerlink" title="JDK文档的介绍的实验"></a>JDK文档的介绍的实验</h2><p>导致该线程开始执行；java虚拟机调用这个线程的 run方法。<br>结果是，两个线程同时运行：当前线程（返回从电话到start法）和其他的线程（执行run法）。重复启动一个线程是不合法的。特别是，一个线程可能不会被重新启动，一旦它完成了执行</p><hr><p>1</p><p>上面说结果出现2个线程同时运行，是说你在<code>run main</code>的时候产生一个线程，然后你在 对<code>Thread</code>对象的<code>start</code>的时候也会算一个线程，在这个时候就会出现2个，比如说执行以下代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Instant start = Instant.now();  Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"readDatabase"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      print(Thread.currentThread().getName());    &#125;  &#125;;  Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"writeFile"</span>) &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      print(Thread.currentThread().getName());    &#125;  &#125;;  t1.start();  t2.start();  Instant end = Instant.now();  print(<span class="hljs-string">"main:"</span>+Thread.currentThread().getName());  print(<span class="hljs-string">"耗时-&gt;"</span> + Duration      .between(start, end)      .getSeconds() + <span class="hljs-string">"s"</span>);&#125;</code></pre><p>结果：</p><pre><code class="hljs avrasm"><span class="hljs-symbol">main:</span>mainwriteFilereadDatabase</code></pre><hr><p>2</p><p>重复启动一个线程是不合法的。特别是，一个线程可能不会被重新启动，如果重复<code>start</code>结果：<code>IllegalThreadStateException</code>  -如果线程已经启动。 </p><pre><code class="hljs java">t1.start();t2.start();t2.start();</code></pre><p>结果：</p><pre><code class="hljs css"><span class="hljs-selector-tag">readDatabase</span><span class="hljs-selector-tag">writeFile</span><span class="hljs-selector-tag">Exception</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">thread</span> "<span class="hljs-selector-tag">main</span>" <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalThreadStateException</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.start</span>(<span class="hljs-selector-tag">Thread</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:708)</span><span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.shui</span><span class="hljs-selector-class">.juc</span><span class="hljs-selector-class">.chapter1</span><span class="hljs-selector-class">.TryConcurrency</span><span class="hljs-selector-class">.main</span>(<span class="hljs-selector-tag">TryConcurrency</span><span class="hljs-selector-class">.java</span><span class="hljs-selector-pseudo">:39)</span></code></pre><h2 id="直接调用run"><a href="#直接调用run" class="headerlink" title="直接调用run"></a>直接调用run</h2><p>如果是直接调用run方法，它就会被视为一个普通类调用方法是一个意思，它不会像调用<code>start</code>那样去创建线程</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>Java应用程序的main函数是一一个线程，是被JVM启动的时候调用，线程的名字叫main</li><li>实现一个线程，必须创建<code>Thread</code>实例， <code>override run</code>方法， 并且调用<code>start</code>方法</li><li>在JVM启动后，实际上有多个线程，但是至少有一个非守护线程</li><li>当你调用一个线程<code>start</code>方法的时候，此时至少有两个线程，一个是调用你的线程，还有一个执行<code>run</code>方法的线程</li><li>线程的生命周期分为：<code>new, runnable, running, block, terminated</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.创建并启动线程</title>
    <link href="/juc-actualCombat-1-2.html"/>
    <url>/juc-actualCombat-1-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h1><blockquote><p>在Java的方法体中，假设某处地方耗时需要很长时间，那么就会造成后面全部等待，而后面的代码与上面的代码完全没有依赖关系，在这个时候使用多线程更合适，你可以对它们分别建立一个线程来并行执行。现在有一个功能：读取数据库的数据+写文件</p></blockquote><h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.juc.chapter1;<span class="hljs-keyword">import</span> java.time.Duration;<span class="hljs-keyword">import</span> java.time.Instant;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 认识多线程</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020-06-14 23:10:43</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TryConcurrency</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Instant start = Instant.now();    <span class="hljs-comment">//1、读数据库数据</span>    readDatabase();    <span class="hljs-comment">//2、写文件</span>    writeFile();    Instant end = Instant.now();    print(<span class="hljs-string">"耗时-&gt; "</span> + Duration        .between(start, end)        .getSeconds() + <span class="hljs-string">"s"</span>);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 读取数据库</span><span class="hljs-comment">   */</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readDatabase</span><span class="hljs-params">()</span> </span>&#123;    print(<span class="hljs-string">"读取数据库开始---"</span>);    <span class="hljs-keyword">try</span> &#123;      TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;    print(<span class="hljs-string">"读取数据库结束---"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeFile</span><span class="hljs-params">()</span> </span>&#123;    print(<span class="hljs-string">"写文件开始---"</span>);    <span class="hljs-keyword">try</span> &#123;      TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;      e.printStackTrace();    &#125;    print(<span class="hljs-string">"写文件结束---"</span>);  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Object object)</span> </span>&#123;    System.out.println(object);  &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs elm">读取数据库开始<span class="hljs-comment">---</span>读取数据库结束<span class="hljs-comment">---</span>写文件开始<span class="hljs-comment">---</span>写文件结束<span class="hljs-comment">---</span>耗时-&gt; <span class="hljs-number">6</span>s</code></pre><h2 id="并行执行实现"><a href="#并行执行实现" class="headerlink" title="并行执行实现"></a>并行执行实现</h2><p>并行执行实际上就是值多线程了，这里将JDK文档的实例贴出来：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimeThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;         <span class="hljs-keyword">long</span> minPrime;         PrimeThread(<span class="hljs-keyword">long</span> minPrime) &#123;             <span class="hljs-keyword">this</span>.minPrime = minPrime;         &#125;         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;             <span class="hljs-comment">// compute primes larger than minPrime</span>              . . .         &#125;     &#125;</code></pre><p>如果想使用多线程，只需要实现Thread类就可以了，这里把业务代码放到run方法就OK了。接下来，通过这种方式来看看效果，代码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Instant start = Instant.now();    Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"readDatabase"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//1、读数据库数据</span>        readDatabase();      &#125;    &#125;;    Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-string">"readDatabase"</span>) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//2、写文件</span>        writeFile();      &#125;    &#125;;    t1.start();    t2.start();    Instant end = Instant.now();    print(<span class="hljs-string">"耗时-&gt;"</span> + Duration        .between(start, end)        .getSeconds() + <span class="hljs-string">"s"</span>);  &#125;</code></pre><p>运行结果：</p><pre><code class="hljs elm">读取数据库开始<span class="hljs-comment">---</span>写文件开始<span class="hljs-comment">---</span>耗时-&gt; <span class="hljs-number">0</span>s写文件结束<span class="hljs-comment">---</span>读取数据库结束<span class="hljs-comment">---</span></code></pre><div class="note note-warning">            <p>WARNING</p><p>这里耗时0秒的原因是 main也是一个线程，对于它而言，它已经执行完了，从 “读取数据库开始—    \n 写文件开始—” 可以看到这里它没有等数据库结束才开始执行 写文件，而是直接执行了自己的。</p>          </div><h1 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h1><blockquote><p>通过上面的案例，认识了Thread类，通过它可以简单的实现并行执行，它这里有很多的学问，这里就来进一步的认识</p></blockquote><p>Thread是一个线程在执行一个程序。java虚拟机的应用程序可以有多个同时执行的线程。 </p><p>每一个线程都有一个优先权。具有更高优先级的线程在优先于较低优先级的线程中执行。每一个线程可能会或可能不会被标记为一个守护进程。在一些线程中运行的代码创建了一个新的Thread对象时，新线程的优先级被设置为等于创建线程的优先级，是守护线程的当且仅当创建线程是一个守护进程。</p><p>当一个java虚拟机启动时，通常有一个单一的非守护线程（通常调用方法命名为main某指定的类）。java虚拟机继续执行线程，直到发生以下情况：</p><ul><li>Runtime exit类的方法被调用和安全经理允许退出操作发生。 </li><li>非守护线程的所有线程都已经死了，要么返回从电话到run法或抛出一个异常传播到run方法。 </li></ul><h2 id="如何验证它有没有创建多个线程？"><a href="#如何验证它有没有创建多个线程？" class="headerlink" title="如何验证它有没有创建多个线程？"></a>如何验证它有没有创建多个线程？</h2><p>对于这个问题，这里推荐使用一个JDK提供的工具<strong>Jconsle</strong>，它可以对线程进行可视化，下面就来演示一下使用方式。</p><p>1）、为了方便演示，这里将readDatabase、writeFile的sleep修改到100秒</p><pre><code class="hljs java">TimeUnit.SECONDS.sleep(<span class="hljs-number">100</span>);</code></pre><p>2）、启动main，在到控制台输入:</p><pre><code class="hljs shell">jconsole</code></pre><p>3）、弹出jconsole工具选择对应的Class</p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200615003039106.png" srcset="/img/loading.gif" alt="image-20200615003039106" style="zoom: 80%;" /><p>4）、选择线程，这里就可以看到那2个线程了</p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200615003321805.png" srcset="/img/loading.gif" alt="image-20200615003321805" style="zoom: 50%;" /><blockquote><p>补充：这里其它是JVM的守护线程：</p><p>Reference Handler：引用句柄处理器</p><p>Finalizer：垃圾回收器</p><p>Signal Dispatcher：收集系统发布信号的</p><p>…</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.简单介绍什么是线程</title>
    <link href="/juc-actualCombat-1-1.html"/>
    <url>/juc-actualCombat-1-1.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/linraise/article/details/12979473" target="_blank" rel="noopener">原文链接</a></p><p>关于多进程和多线程，教科书上最经典的一句话是 “进程是资源分配的最小单位，线程是 CPU 调度的最小单位”。这句话应付考试基本上够了，但如果在工作中遇到类似的选择问题，那就没有那么简单了，选的不好，会让你深受其害。所以他也是面试者最喜欢考察的题目之一。</p><p>我们按照多个不同的维度，来看看多进程和多线程的对比（注：都是相对的，不是说一个好得不得了，另一个差的无法忍受）</p><table><thead><tr><th>维度</th><th>多进程</th><th>多线程</th><th>总结</th></tr></thead><tbody><tr><td>数据共享、同步</td><td>数据是分开的：共享复杂，需要用 IPC; 同步简单</td><td>多线程共享进程数据：共享简单；同步复杂</td><td>各有优势</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>创建销毁、切换</td><td>创建销毁、切换复杂，速度慢</td><td>占用内存少，切换简单，CPU 利用率高</td><td>线程占优</td></tr><tr><td>编程调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td><td>进程占优</td></tr><tr><td>可靠性</td><td>进程间不会相互影响</td><td>一个线程挂掉将导致整个进程挂掉</td><td>进程占优</td></tr><tr><td>分布式</td><td>适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单</td><td>适应于多核分布</td><td>进程占优</td></tr></tbody></table><p>然后我们来看下线程和进程间的比较</p><table><thead><tr><th>子进程继承父进程的属性</th><th>子线程继承主线程的属性</th></tr></thead><tbody><tr><td>实际用户 ID，实际组 ID，有效用户 ID，有效组 ID；<br/><br/>附加组 ID；<br/><br/>进程组 ID；<br/><br/>会话 ID；<br/><br/>控制终端；<br/><br/>设置用户 ID 标志和设置组 ID 标志；<br/><br/>当前工作目录；<br/><br/>根目录；<br/><br/>文件模式创建屏蔽字（umask）；<br/><br/>信号屏蔽和安排；<br/><br/>针对任一打开文件描述符的在执行时关闭（close-on-exec）标志；<br/><br/>环境；<br/><br/>连接的共享存储段；<br/><br/>存储映射；<br/><br/>资源限制；<br/></td><td>进程中的所有信息对该进程的所有线程都是共享的；<br/><br/>可执行的程序文本；<br/><br/>程序的全局内存；<br/><br/>堆内存；<br/><br/>栈；<br/><br/>文件描述符；<br/><br/>信号的处理是进程中所有线程共享的（注意：如果信号的默认处理是终止该进程那么即是把信号传给某个线程也一样会将进程杀掉）；<br/></td></tr><tr><td>父子进程之间的区别：</td><td>子线程特有的：</td></tr><tr><td>fork 的返回值 (=0 子进程)；<br/><br/>进程 ID 不同；<br/><br/>两个进程具有不同的父进程 ID；<br/><br/>子进程的 tms_utime,tms_stime,tms_cutime 以及 tms_ustime 均被设置为 0；<br/><br/>不继承父进程设置的文件锁；<br/><br/>子进程的未处理闹钟被清除；<br/><br/>子进程的未处理信号集设置为空集；<br/></td><td>线程 ID；<br/>一组寄存器值；<br/>栈<br/>调度优先级和策略；<br/>信号屏蔽字；<br/>errno 变量；<br/>线程私有数据；</td></tr></tbody></table><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/2018122721302863.jpg" srcset="/img/loading.gif" alt="img"></p><p>1）、需要频繁创建销毁的优先用线程<br>实例：web 服务器。来一个建立一个线程，断了就销毁线程。要是用进程，创建和销毁的代价是很难承受的;</p><p>2）、需要进行大量计算的优先使用线程<br>所谓大量计算，当然就是要消耗很多 cpu，切换频繁了，这种情况先线程是最合适的。<br>实例：图像处理、算法处理；</p><p>3）、强相关的处理用线程，若相关的处理用进程；<br>什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。<br>一般的 server 需要完成如下任务：消息收发和消息处理。消息收发和消息处理就是弱相关的任务，而消息处理里面可能又分为消息解码、业务处理，这两个任务相对来说相关性就要强多了。因此消息收发和消息处理可以分进程设计，消息解码和业务处理可以分线程设计；</p><p>4）、可能扩展到多机分布的用进程，多核分布的用线程；</p><p>5）、都满足需求的情况下，用你最熟悉、最拿手的方式。</p><div class="note note-warning">            <p> WARNING</p><p>至于” 数据共享、同步 “、“编程、调试”、“可靠性” 这几个维度的所谓的 “复杂、简单” 应该怎么取舍，只能说：没有明确的选择方法。一般有一个选择原则：如果多进程和多线程都能够满足要求，那么选择你最熟悉、最拿手的那个。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>JUC</category>
      
      <category>Java多线程编程实战</category>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】 Vmwrae中CentOS扩容</title>
    <link href="/linux-4.html"/>
    <url>/linux-4.html</url>
    
    <content type="html"><![CDATA[<p>文章转载：<a href="https://www.cnblogs.com/Sungeek/p/9084510.html" target="_blank" rel="noopener">链接地址</a></p><h1 id="查看CentOS的系统挂载点信息"><a href="#查看CentOS的系统挂载点信息" class="headerlink" title="查看CentOS的系统挂载点信息"></a>查看CentOS的系统挂载点信息</h1><pre><code class="hljs bash">~&gt; df -lh文件系统                 容量  已用  可用 已用% 挂载点devtmpfs                 979M     0  979M    0% /devtmpfs                    991M     0  991M    0% /dev/shmtmpfs                    991M  2.2M  989M    1% /runtmpfs                    991M     0  991M    0% /sys/fs/cgroup/dev/mapper/centos-root   13G  6.8G  5.8G   55% //dev/sda1               1014M  163M  852M   17% /boot...</code></pre><h1 id="扩展-VMWare-CentOS硬盘空间"><a href="#扩展-VMWare-CentOS硬盘空间" class="headerlink" title="扩展 VMWare-CentOS硬盘空间"></a>扩展 VMWare-CentOS硬盘空间</h1><p>​<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200531225705745.png" srcset="/img/loading.gif" alt="image-20200531225705745" style="zoom: 60%;" /></p><h1 id="对扩容的硬盘空间创建分区、格式化"><a href="#对扩容的硬盘空间创建分区、格式化" class="headerlink" title="对扩容的硬盘空间创建分区、格式化"></a>对扩容的硬盘空间创建分区、格式化</h1><pre><code class="hljs bash">~&gt; fdisk /dev/sda　　　　 p　　　　　　　查看已分区数量（我看到有两个 /dev/sda1 /dev/sda2） n　　　　　　　新增加一个分区p　　　　　　　分区类型我们选择为主分区 　　　　　　     分区号输入3（因为1,2已经用过了,sda1是分区1,sda2是分区2,sda3分区3） 回车　　　　　  默认（起始扇区） 回车　　　　　  默认（结束扇区） t　　　　　　　 修改分区类型 　　　　　　     选分区3 8e　　　　　 　修改为LVM（8e就是LVM）w　　　　　  　写分区表 q　　　　　  　完成，退出fdisk命令<span class="hljs-comment">#使用partprobe命令 或者重启机器 </span>~&gt; partprobe<span class="hljs-comment">#格式化分区</span>~&gt; mkfs.ext4 /dev/sda3</code></pre><h1 id="添加新-LVM-到已有的-LVM-组，实现扩容"><a href="#添加新-LVM-到已有的-LVM-组，实现扩容" class="headerlink" title="添加新 LVM 到已有的 LVM 组，实现扩容"></a>添加新 LVM 到已有的 LVM 组，实现扩容</h1><pre><code class="hljs bash">~&gt; lvm　　　　　　　　　　　　           <span class="hljs-comment">#进入lvm管理</span>lvm&gt;pvcreate /dev/sda3　　           <span class="hljs-comment">#这是初始化刚才的分区3</span>lvm&gt;vgextend centos /dev/sda3     <span class="hljs-comment">#将初始化过的分区加入到虚拟卷组centos (卷和卷组的命令可以通过 vgdisplay )</span>lvm&gt;vgdisplay -v或者vgdisplay查看free PE /Sitelvm&gt;lvextend -l+6143 /dev/mapper/centos-root　　<span class="hljs-comment">#扩展已有卷的容量（6143 是通过vgdisplay查看free PE /Site的大小）</span>lvm&gt;pvdisplay <span class="hljs-comment">#查看卷容量，这时你会看到一个很大的卷了</span>lvm&gt;quit 　<span class="hljs-comment">#退出</span></code></pre><p>上面只是卷扩容了，下面是文件系统的真正扩容，输入以下命令：</p><pre><code class="hljs bash">~&gt; xfs_growfs /dev/mapper/centos-root</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【React】 Styled-Component + Tailwind CSS + Tailwind Macro</title>
    <link href="/react-1.html"/>
    <url>/react-1.html</url>
    
    <content type="html"><![CDATA[<h3 id="创建React工程"><a href="#创建React工程" class="headerlink" title="创建React工程"></a>创建React工程</h3><pre><code class="hljs bash">npx create-react-app <span class="hljs-variable">$&#123;name&#125;</span></code></pre><p>接下来，按照以下步骤构建文件夹：</p><blockquote><p>这里只显示主要的地方</p></blockquote><pre><code class="hljs tree">├─babel-plugin-macros.config.js├─package.json├─postcss.config.js├─src|  ├─index.js|  ├─tailwind.config.js|  ├─styled|  |   ├─Form|  |   |  └index.js|  ├─page|  ├─component|  |     ├─App|  |     |  └index.jsx|  ├─asset|  |   ├─css|  |   |  ├─tailwind|  |   |  |    ├─global.css|  |   |  |    └index.css</code></pre><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><pre><code class="hljs bash">yarn add tailwindcss tailwind.macro@next styled-components  -Syarn add babel-plugin-macros  postcss-cli npm-run-all cross-env postcss-import -D</code></pre><h3 id="添加tailwind配置"><a href="#添加tailwind配置" class="headerlink" title="添加tailwind配置"></a>添加tailwind配置</h3><pre><code class="hljs bash">npx tailwind init src/tailwind.config.js</code></pre><p>tailwind.config.js</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;purge: [<span class="hljs-string">'./src/**/*.html'</span>,<span class="hljs-string">'./src/**/*.vue'</span>,<span class="hljs-string">'./src/**/*.jsx'</span>,<span class="hljs-string">'./src/**/*.js'</span>,],theme: &#123;&#125;,variants: &#123;&#125;,plugins: [],&#125;;</code></pre><p>postcss.config.js</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;plugins: [<span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-import'</span>),<span class="hljs-built_in">require</span>(<span class="hljs-string">'tailwindcss'</span>)(<span class="hljs-string">'./src/tailwind.config.js'</span>),<span class="hljs-built_in">require</span>(<span class="hljs-string">'autoprefixer'</span>),],&#125;;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>package.json</p><pre><code class="hljs json">"scripts": &#123;    "build:css": "cross-env NODE_ENV=production postcss src/asset/css/tailwind/global.css -o src/asset/css/tailwind/index.css",    "build:css-dev": "tailwind build src/asset/css/tailwind/global.css -o src/asset/css/tailwind/index.css",    "start:js": "react-scripts start",    "start": "npm-run-all build:css-dev start:js",    "build:js": "react-scripts build",    "build": "npm-run-all build:css build:js",    "test": "react-scripts test",    "eject": "react-scripts eject",    "serve": "serve.cmd -s  build"  &#125;</code></pre><p>src\asset\css\tailwind\global.css</p><pre><code class="hljs css"><span class="hljs-keyword">@tailwind</span> base;<span class="hljs-keyword">@tailwind</span> components;<span class="hljs-keyword">@tailwind</span> utilities;</code></pre><p>src\styled\Form\index.js</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">'styled-components'</span>;<span class="hljs-keyword">import</span> tw <span class="hljs-keyword">from</span> <span class="hljs-string">'tailwind.macro'</span>;<span class="hljs-keyword">const</span> StyledForm = styled.main.attrs(&#123;className: <span class="hljs-string">'flex flex-col h-screen justify-center items-center bg-gray-100'</span>,&#125;)<span class="hljs-string">`</span><span class="hljs-string">&amp; &#123;</span><span class="hljs-string">form &#123;</span><span class="hljs-string"><span class="hljs-subst">$&#123;tw<span class="hljs-string">`bg-white text-center rounded py-8 px-5 shadow max-w-xs`</span>&#125;</span></span><span class="hljs-string">&#125;</span><span class="hljs-string">input &#123;</span><span class="hljs-string"><span class="hljs-subst">$&#123;tw<span class="hljs-string">`border-gray-300 mb-4 w-full border-solid border rounded py-2 px-4`</span>&#125;</span></span><span class="hljs-string">&#125;</span><span class="hljs-string">button &#123;</span><span class="hljs-string"><span class="hljs-subst">$&#123;tw<span class="hljs-string">`bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 border border-blue-700 rounded`</span>&#125;</span></span><span class="hljs-string">&#125;</span><span class="hljs-string">&#125;</span><span class="hljs-string">`</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> StyledForm;</code></pre><p>src\component\App\index.jsx</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> StyledForm <span class="hljs-keyword">from</span> <span class="hljs-string">'../../styled/Form'</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> () =&gt; (&lt;StyledForm&gt;&lt;form&gt;&lt;input type=<span class="hljs-string">'text'</span> placeholder=<span class="hljs-string">'Full name'</span> /&gt;&lt;input type=<span class="hljs-string">'text'</span> placeholder=<span class="hljs-string">'Email'</span> /&gt;&lt;input type=<span class="hljs-string">'text'</span> placeholder=<span class="hljs-string">'Password'</span> /&gt;&lt;button&gt;Sign In&lt;<span class="hljs-regexp">/button&gt;</span><span class="hljs-regexp">&lt;/</span>form&gt;&lt;<span class="hljs-regexp">/StyledForm&gt;</span><span class="hljs-regexp">);</span></code></pre><p>src\index.js</p><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;<span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">'./component/App'</span>;<span class="hljs-keyword">import</span> <span class="hljs-string">'./asset/css/tailwind/index.css'</span>;ReactDOM.render(&lt;React.StrictMode&gt;&lt;App /&gt;&lt;<span class="hljs-regexp">/React.StrictMode&gt;,</span><span class="hljs-regexp">document.getElementById('root')</span><span class="hljs-regexp">);</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 OAuth2-学习笔记 】  2.OAuth进阶篇</title>
    <link href="/oauth2-2.html"/>
    <url>/oauth2-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="手动配置认证服务"><a href="#手动配置认证服务" class="headerlink" title="手动配置认证服务"></a>手动配置认证服务</h1><p>由于<code>AuthorizationServerConfig#configure(org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer)</code>需要配置<code>AuthenticationManager</code>，所以需要先配置<code>WebSecurityConfig</code>，来将<code>AuthenticationManager</code>注入到IOC中</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http        .formLogin()      .and()        .authorizeRequests()        .anyRequest()        .authenticated()      .and()        .csrf().disable();  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-meta">@SneakyThrows</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> AuthenticationManager <span class="hljs-title">authenticationManagerBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.authenticationManagerBean();  &#125;  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();  &#125;&#125;</code></pre><p>认证服务配置代码如下：</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;  <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;  <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    clients        .inMemory()        .withClient(<span class="hljs-string">"mcr"</span>)        .secret(<span class="hljs-string">"mcr"</span>);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    endpoints        .allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST)        .userDetailsService(userDetailsService)        .authenticationManager(authenticationManager);  &#125;&#125;</code></pre><p>以上这些代码是之前老的方式，在新的版本中这样是有问题的，当我去访问<code>/oauth/token</code>的时候它会报一个错误：</p><pre><code class="hljs xquery">java<span class="hljs-built_in">.lang</span>.IllegalArgumentException: There <span class="hljs-literal">is</span> no PasswordEncoder mapped <span class="hljs-keyword">for</span> the<span class="hljs-built_in"> id</span> <span class="hljs-string">"null"</span></code></pre><p>这里通过万能的搜索引擎知道它的问题——<a href="https://blog.csdn.net/Hello_World_QWP/article/details/81811462" target="_blank" rel="noopener">链接</a></p><hr><p>这里正确的打开方式：</p><pre><code class="hljs bash">private PasswordEncoder passwordEncoder;    @Override  public void configure(ClientDetailsServiceConfigurer clients) throws Exception &#123;    clients        .inMemory()        .withClient(<span class="hljs-string">"mcr"</span>)        👇关键代码        .secret(passwordEncoder.encode(<span class="hljs-string">"mcr"</span>));  &#125;</code></pre><h1 id="使用Redis存储Token"><a href="#使用Redis存储Token" class="headerlink" title="使用Redis存储Token"></a>使用Redis存储Token</h1><blockquote><p>这个在以前的Spring Security中是一样的，这里在复习下</p></blockquote><p>pom加入Redis依赖</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Redis--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><hr><p>yml</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">mcr.dev.com</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6380</span></code></pre><hr><p>AuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> RedisConnectionFactory connectionFactory;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">tokenStore</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisTokenStore(connectionFactory);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  endpoints...              👇关键代码      .tokenStore(tokenStore());&#125;</code></pre><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>图1</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/Diagram2.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>sys_user：略</li><li>sys_role：略</li><li>sys_user_role：略</li><li>sys_role_menu：略</li><li>sys_menu：这里的permission是一个权限标识，用它来判断用户是否能访问特定的接口</li></ul><h2 id="认证逻辑"><a href="#认证逻辑" class="headerlink" title="认证逻辑"></a>认证逻辑</h2><p>首先定义一个类继承Security提供的User类，个性化自己需要的属性</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.service;<span class="hljs-keyword">import</span> lombok.Getter;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;  <span class="hljs-meta">@Getter</span>  <span class="hljs-keyword">private</span> Integer id;  <span class="hljs-meta">@Getter</span>  <span class="hljs-keyword">private</span> Integer deptId;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrUser</span><span class="hljs-params">(Integer id, Integer deptId, String username, String password, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;    <span class="hljs-keyword">super</span>(username, password, authorities);    <span class="hljs-keyword">this</span>.id = id;    <span class="hljs-keyword">this</span>.deptId = deptId;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrUser</span><span class="hljs-params">(Integer id, Integer deptId, String username, String password, <span class="hljs-keyword">boolean</span> enabled, <span class="hljs-keyword">boolean</span> accountNonExpired, <span class="hljs-keyword">boolean</span> credentialsNonExpired, <span class="hljs-keyword">boolean</span> accountNonLocked, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;    <span class="hljs-keyword">super</span>(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, authorities);    <span class="hljs-keyword">this</span>.id = id;    <span class="hljs-keyword">this</span>.deptId = deptId;  &#125;&#125;</code></pre><hr><p>McrUserDetailsService：略</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.service;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-keyword">private</span> SysUserMapper userMapper;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String BCRYPT = <span class="hljs-string">"&#123;bcrypt&#125;"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        SysUser sysUser = userMapper.selectOneByUsername(username);        log.info(<span class="hljs-keyword">new</span> Gson().toJson(sysUser));        <span class="hljs-keyword">return</span> getMcrUser(username, sysUser);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> McrUser <span class="hljs-title">getMcrUser</span><span class="hljs-params">(String username, SysUser sysUser)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrUser(sysUser.getUserId(), sysUser.getDeptId(), username,                BCRYPT + sysUser.getPassword(), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,                StrUtil.equals(sysUser.getLockFlag(), <span class="hljs-string">"0"</span>),                AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));    &#125;&#125;</code></pre><h2 id="令牌增强"><a href="#令牌增强" class="headerlink" title="令牌增强"></a>令牌增强</h2><p>AuthorizationServerConfig（认证服务配置类）加入以下代码</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       endpoints               ...               .tokenEnhancer(tokenEnhancer());   &#125;   <span class="hljs-meta">@Bean</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> TokenEnhancer <span class="hljs-title">tokenEnhancer</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> (accessToken, authentication) -&gt; &#123;           McrUser user = (McrUser) authentication                   .getUserAuthentication()                   .getPrincipal();           <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; additionalInfo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">4</span>);           additionalInfo.put(<span class="hljs-string">"userId"</span>, user.getId());           additionalInfo.put(<span class="hljs-string">"deptId"</span>, user.getDeptId());           ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(additionalInfo);           <span class="hljs-keyword">return</span> accessToken;       &#125;;   &#125;</code></pre><hr><p>在访问<code>/oauth/token</code>的时候得到的数据变成了：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"059861b7-755c-4ebb-8869-d94b6314a977"</span>,    <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,    <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">43199</span>,    <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"server"</span>,    <span class="hljs-attr">"deptId"</span>: <span class="hljs-number">1</span>,    <span class="hljs-attr">"userId"</span>: <span class="hljs-number">1</span>&#125;</code></pre><hr><p>业务代码获取<code>McrUser</code>中的数据：</p><pre><code class="hljs java">  SecurityContext context = SecurityContextHolder.getContext();<span class="hljs-keyword">return</span> (McrUser) context        .getAuthentication()        .getPrincipal();</code></pre><p>可以将它封装为一个工具类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.common.util;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 安全工具类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@UtilityClass</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUtils</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取Authentication</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">getAuthentication</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SecurityContextHolder                .getContext()                .getAuthentication();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取用户</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> McrUser <span class="hljs-title">getUser</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;        Object principal = authentication.getPrincipal();        <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> McrUser) &#123;            <span class="hljs-keyword">return</span> (McrUser) principal;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取用户</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> McrUser <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;        Authentication authentication = getAuthentication();        <span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">return</span> getUser(authentication);    &#125;</code></pre><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><blockquote><p>实现功能：根据数据库中的数据，也就是<code>图1</code>中的<code>sys_menu</code>表的<code>permission</code>来控制特殊的接口</p></blockquote><p>在<code>Spring Security</code>中的<code>User类</code>的<code>authorities属性</code>就是用于接口访问权限控制的，在之前的编写的<code>McrUserDetailsService类</code>中：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> McrUser get<span class="hljs-constructor">McrUser(String <span class="hljs-params">username</span>, SysUser <span class="hljs-params">sysUser</span>)</span> &#123;        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">McrUser(<span class="hljs-params">sysUser</span>.<span class="hljs-params">getUserId</span>()</span>, sysUser.get<span class="hljs-constructor">DeptId()</span>, username,                BCRYPT + sysUser.get<span class="hljs-constructor">Password()</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>,                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StrUtil</span>.</span></span>equals(sysUser.get<span class="hljs-constructor">LockFlag()</span>, <span class="hljs-string">"0"</span>),                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorityUtils</span>.</span></span>comma<span class="hljs-constructor">SeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>)</span>);    &#125;</code></pre><p>这里给的是一个死的值，这里需要将它该为用<code>sys_menu的permission</code></p><hr><p>建立一个<code>UserInfo</code>来关联<code>sys_user</code>和<code>sys_menu的permission</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.common.model.dto;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> SysUser sysUser;    <span class="hljs-keyword">private</span> String[] permissions;&#125;</code></pre><hr><p>SysMenuMapper</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.common.mapper;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SysMenuMapper</span> </span>&#123;   <span class="hljs-function">List&lt;SysMenu&gt; <span class="hljs-title">findByRoleId</span><span class="hljs-params">(@Param(<span class="hljs-string">"roleId"</span>)</span> Integer roleId)</span>;&#125;</code></pre><p>SysMenuMapper.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"findByRoleId"</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">"BaseResultMap"</span>&gt;</span>        select *        from sys_menu m                 JOIN sys_role_menu rm ON m.menu_id = rm.menu_id        WHERE rm.role_id = #&#123;roleId,jdbcType=INTEGER&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.common.service.impl;<span class="hljs-meta">@Service</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SysUserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SysUserService</span> </span>&#123;  <span class="hljs-keyword">private</span> SysUserMapper userMapper;  <span class="hljs-keyword">private</span> SysMenuMapper menuMapper;  <span class="hljs-keyword">private</span> SysRoleMapper roleMapper;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 根据用户名查询用户和它的权限</span><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> username 用户名</span><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title">selectOneByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;    SysUser sysUser = userMapper.selectOneByUsername(username);    <span class="hljs-keyword">if</span> (sysUser == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    UserInfo userInfo = <span class="hljs-keyword">new</span> UserInfo();    Integer userId = sysUser.getUserId();    Set&lt;String&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    roleIdList.forEach(roleId -&gt; &#123;      List&lt;String&gt; permissionList = menuMapper          .findByRoleId(roleId)          .stream()          .filter(menu -&gt; StrUtil.isNotBlank(menu.getPermission()))          .map(SysMenu::getPermission)          .collect(Collectors.toList());      permissions.addAll(permissionList);    &#125;);    userInfo.setSysUser(sysUser);    userInfo.setPermissions(permissions.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">return</span> userInfo;  &#125;&#125;</code></pre><hr><p>McrUserDetailsService全部代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.service;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;  <span class="hljs-keyword">private</span> SysUserService userService;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String BCRYPT = <span class="hljs-string">"&#123;bcrypt&#125;"</span>;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;    UserInfo userInfo = userService.selectOneByUsername(username);    log.info(<span class="hljs-keyword">new</span> Gson().toJson(userInfo));    <span class="hljs-keyword">return</span> getMcrUser(username, userInfo);  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> McrUser <span class="hljs-title">getMcrUser</span><span class="hljs-params">(String username, UserInfo userInfo)</span> </span>&#123;    SysUser sysUser = userInfo.getSysUser();    Set&lt;String&gt; permissions = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(Arrays.asList(userInfo.getPermissions()));    List&lt;GrantedAuthority&gt; authorityList = AuthorityUtils.createAuthorityList(permissions.toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>]));    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrUser(sysUser.getUserId(), sysUser.getDeptId(), username,        BCRYPT + sysUser.getPassword(), <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">true</span>,        StrUtil.equals(sysUser.getLockFlag(), <span class="hljs-string">"0"</span>),        authorityList);  &#125;&#125;</code></pre><hr><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.component;<span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Component</span>(<span class="hljs-string">"pms"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PermissionService</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hashPermission</span><span class="hljs-params">(String permission)</span> </span>&#123;    Authentication authentication = SecurityContextHolder        .getContext()        .getAuthentication();    <span class="hljs-keyword">if</span> (authentication == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();    <span class="hljs-keyword">return</span> authorities        .stream()        .map(GrantedAuthority::getAuthority)        .filter(StringUtils::hasText)        .anyMatch(x -&gt; PatternMatchUtils.simpleMatch(permission, x));  &#125;&#125;</code></pre><p>这个类用于判断当前接口，用户是否可以访问。方法中的逻辑：从ThreadLocal中取permissions，看是否满足参数传递的值</p><hr><p>在IndexController中建立一个接口，并使用它</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/permissionTest"</span>)<span class="hljs-meta">@PreAuthorize</span>(<span class="hljs-string">"@pms.hashPermission('not')"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">permissionTest</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">"OK"</span>;&#125;</code></pre><p>这里的 <code>@PreAuthorize(&quot;@pms.hashPermission(&#39;not&#39;)&quot;)</code>会在<code>PermissionService#hashPermission</code>传递not值来验证</p><hr><p>在<code>Spring Security 5.x</code>中<code>@PreAuthorize</code>默认是不生效的，需要通过这个注解开启</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableGlobalMethodSecurity</span>(prePostEnabled = <span class="hljs-keyword">true</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;...&#125;</code></pre><hr><p>访问这个接口会得到以下信息：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"access_denied"</span>,    <span class="hljs-attr">"error_description"</span>: <span class="hljs-string">"不允许访问"</span>&#125;</code></pre><h2 id="数据库中的Client"><a href="#数据库中的Client" class="headerlink" title="数据库中的Client"></a>数据库中的Client</h2><p>对于之前的<code>clientId和secret</code>的定义方式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;   <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        clients                .inMemory()                .withClient(<span class="hljs-string">"mcr"</span>)                .secret(passwordEncoder.encode(<span class="hljs-string">"mcr"</span>))                .authorizedGrantTypes(<span class="hljs-string">"password"</span>,<span class="hljs-string">"refresh_token"</span>);    &#125;&#125;</code></pre><p>下面来实现从数据库中来取</p><hr><p>建表sql</p><pre><code class="hljs mysql">CREATE TABLE sys_oauth_client_details(  client_id               VARCHAR(32)   NOT NULL    PRIMARY KEY,  resource_ids            VARCHAR(256)  NULL,  client_secret           VARCHAR(256)  NULL,  scope                   VARCHAR(256)  NULL,  authorized_grant_types  VARCHAR(256)  NULL,  web_server_redirect_uri VARCHAR(256)  NULL,  authorities             VARCHAR(256)  NULL,  access_token_validity   INT           NULL,  refresh_token_validity  INT           NULL,  additional_information  VARCHAR(4096) NULL,  autoapprove             VARCHAR(256)  NULL)  COMMENT &#39;终端信息表&#39;;</code></pre><hr><p>Java代码（一把梭）</p><p>SecurityConstant：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.constant;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConstant</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 字段</span><span class="hljs-comment">   */</span>  String CLIENT_FIELDS = <span class="hljs-string">"client_id,"</span> +      <span class="hljs-string">"       CONCAT('&#123;noop&#125;', client_secret) AS client_secret,"</span> +      <span class="hljs-string">"       resource_ids,"</span> +      <span class="hljs-string">"       scope,"</span> +      <span class="hljs-string">"       authorized_grant_types,"</span> +      <span class="hljs-string">"       web_server_redirect_uri,"</span> +      <span class="hljs-string">"       authorities,"</span> +      <span class="hljs-string">"       access_token_validity,"</span> +      <span class="hljs-string">"       refresh_token_validity,"</span> +      <span class="hljs-string">"       additional_information,"</span> +      <span class="hljs-string">"       autoapprove"</span>;  String BASE_FIND_STATEMENT = <span class="hljs-string">"select "</span> + CLIENT_FIELDS      + <span class="hljs-string">" from sys_oauth_client_details"</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 默认的查询语句</span><span class="hljs-comment">   */</span>  String DEFAULT_FIND_STATEMENT = BASE_FIND_STATEMENT + <span class="hljs-string">" order by client_id"</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 按条件client_id 查询</span><span class="hljs-comment">   */</span>  String DEFAULT_SELECT_STATEMENT = BASE_FIND_STATEMENT + <span class="hljs-string">" where client_id = ?"</span>;&#125;</code></pre><p>AuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  JdbcClientDetailsService jdbcClientDetailsService = <span class="hljs-keyword">new</span> JdbcClientDetailsService(dataSource);  jdbcClientDetailsService.setFindClientDetailsSql(SecurityConstant.DEFAULT_FIND_STATEMENT);  jdbcClientDetailsService.setSelectClientDetailsSql(SecurityConstant.DEFAULT_SELECT_STATEMENT);  clients      .withClientDetails(jdbcClientDetailsService);&#125;</code></pre><h2 id="自定义响应"><a href="#自定义响应" class="headerlink" title="自定义响应"></a>自定义响应</h2><blockquote><p>我刚来到一家公司上班，公司用的<code>Spring Security</code>做权限认证，这里我遇见了一个问题：请求登录接口、Token过期的数据格式修改一下。于是就有了这一章节</p></blockquote><h3 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h3><p>自定响应内容就需要先了解Spring Security常见的异常都有哪些？这里列出常见的几个：</p><ul><li>UsernameNotFoundException（用户不存在）</li><li>DisabledException（用户已被禁用）</li><li>BadCredentialsException（坏的凭据）</li><li>LockedException（账户锁定）</li><li>AccountExpiredException （账户过期）</li><li>CredentialsExpiredException（证书过期）<br>…</li></ul><h3 id="从哪下手？"><a href="#从哪下手？" class="headerlink" title="从哪下手？"></a>从哪下手？</h3><p><code>TokenEndpoint</code>提供了<code>/oauth/token</code>请求，在这个请求中对一些情况抛出异常，对于这些异常，它自己也做了异常的捕获，代码如下：</p><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler</span>(HttpRequestMethodNotSupportedException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">OAuth2Exception</span>&gt; <span class="hljs-title">handleHttpRequestMethodNotSupportedException</span>(<span class="hljs-title">HttpRequestMethodNotSupportedException</span> <span class="hljs-title">e</span>) <span class="hljs-title">throws</span> <span class="hljs-title">Exception</span> </span>&#123;<span class="hljs-comment">//...</span>    <span class="hljs-keyword">return</span> getExceptionTranslator().translate(e);&#125;<span class="hljs-meta">@ExceptionHandler</span>(Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">OAuth2Exception</span>&gt; <span class="hljs-title">handleException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) <span class="hljs-title">throws</span> <span class="hljs-title">Exception</span> </span>&#123;<span class="hljs-comment">//...</span><span class="hljs-keyword">return</span> getExceptionTranslator().translate(e);&#125;<span class="hljs-meta">@ExceptionHandler</span>(ClientRegistrationException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">OAuth2Exception</span>&gt; <span class="hljs-title">handleClientRegistrationException</span>(<span class="hljs-title">Exception</span> <span class="hljs-title">e</span>) <span class="hljs-title">throws</span> <span class="hljs-title">Exception</span> </span>&#123;<span class="hljs-comment">//...</span><span class="hljs-keyword">return</span> getExceptionTranslator().translate(<span class="hljs-keyword">new</span> BadClientCredentialsException());&#125;<span class="hljs-meta">@ExceptionHandler</span>(OAuth2Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">ResponseEntity</span>&lt;<span class="hljs-title">OAuth2Exception</span>&gt; <span class="hljs-title">handleException</span>(<span class="hljs-title">OAuth2Exception</span> <span class="hljs-title">e</span>) <span class="hljs-title">throws</span> <span class="hljs-title">Exception</span> </span>&#123;<span class="hljs-comment">//...</span><span class="hljs-keyword">return</span> getExceptionTranslator().translate(e);&#125;</code></pre><p>从这些异常处理器中都能看最后的代码都是<code>return getExceptionTranslator().translate(e);</code>，它是做什么的？这里接着看它调用的这个方法<code>translate</code></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Translates exceptions into HTTP Responses.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; The error model that will be used as the HTTP Response body.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WebResponseExceptionTranslator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-function">ResponseEntity&lt;T&gt; <span class="hljs-title">translate</span><span class="hljs-params">(Exception e)</span> <span class="hljs-keyword">throws</span> Exception</span>;&#125;</code></pre><p>Translates exceptions into HTTP Responses.-&gt;将异常转换为响应。这里说的很清楚了，实际上是只要编写一个类实现接口中的方法就能实现自定义的响应。方法中的内容要怎么写？可以参考它的默认实现类：</p><p>DefaultWebResponseExceptionTranslator</p><hr><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>首先编写一个McrAuth2ExceptionSerializer，这里的代码不做过多介绍，关于<code>fasterxml.jackson</code>有很多内容要讲，我以后会系统的来对这个学习。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.component;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuth2ExceptionSerializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StdSerializer</span>&lt;<span class="hljs-title">McrAuth2Exception</span>&gt; </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">McrAuth2ExceptionSerializer</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">super</span>(McrAuth2Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;  &#125;      <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(McrAuth2Exception e, JsonGenerator gen, SerializerProvider serializerProvider)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    gen.writeStartObject();    gen.writeObjectField(<span class="hljs-string">"code"</span>, <span class="hljs-number">1</span>);    gen.writeObjectField(<span class="hljs-string">"msg"</span>, e.getMessage());    gen.writeObjectField(<span class="hljs-string">"data"</span>, e.getErrorCode());    gen.writeEndObject();  &#125;&#125;</code></pre><p>自定义异常基类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">McrAuth2Exception</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OAuth2Exception</span> </span>&#123;  <span class="hljs-meta">@Getter</span>  <span class="hljs-keyword">private</span> String errorCode;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrAuth2Exception</span><span class="hljs-params">(String msg, String errorCode)</span> </span>&#123;    <span class="hljs-keyword">super</span>(msg);    <span class="hljs-keyword">this</span>.errorCode = errorCode;  &#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrAuth2Exception</span><span class="hljs-params">(String msg)</span> </span>&#123;    <span class="hljs-keyword">super</span>(msg);  &#125;&#125;</code></pre><p>访问被拒绝的异常</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 访问被拒接</span><span class="hljs-comment"> */</span><span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ForbiddenException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">McrAuth2Exception</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ForbiddenException</span><span class="hljs-params">(String msg, Throwable t)</span> </span>&#123;    <span class="hljs-keyword">super</span>(msg);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOAuth2ErrorCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"access_denied"</span>;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHttpErrorCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> HttpStatus.FORBIDDEN.value();  &#125;&#125;</code></pre><p>无效的异常</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 无效的异常</span><span class="hljs-comment"> */</span><span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">InvalidException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">McrAuth2Exception</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InvalidException</span><span class="hljs-params">(String msg, Throwable t)</span> </span>&#123;<span class="hljs-keyword">super</span>(msg);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOAuth2ErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"invalid_exception"</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHttpErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">426</span>;&#125;&#125;</code></pre><p>不允许的方法</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 不允许的方法</span><span class="hljs-comment"> */</span><span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">MethodNotAllowed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">McrAuth2Exception</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MethodNotAllowed</span><span class="hljs-params">(String msg, Throwable t)</span> </span>&#123;<span class="hljs-keyword">super</span>(msg);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOAuth2ErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"method_not_allowed"</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHttpErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HttpStatus.METHOD_NOT_ALLOWED.value();&#125;&#125;</code></pre><p>服务错误</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 服务错误</span><span class="hljs-comment"> */</span><span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ServerErrorException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">McrAuth2Exception</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerErrorException</span><span class="hljs-params">(String msg, Throwable t)</span> </span>&#123;<span class="hljs-keyword">super</span>(msg);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOAuth2ErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"server_error"</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHttpErrorCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR.value();&#125;&#125;</code></pre><p>未经授权的异常</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.exception;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 未经过授权的异常</span><span class="hljs-comment"> */</span><span class="hljs-meta">@JsonSerialize</span>(using = McrAuth2ExceptionSerializer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">UnauthorizedException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">McrAuth2Exception</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnauthorizedException</span><span class="hljs-params">(String msg, Throwable t)</span> </span>&#123;    <span class="hljs-keyword">super</span>(msg);  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOAuth2ErrorCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"unauthorized"</span>;  &#125;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHttpErrorCode</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> HttpStatus.UNAUTHORIZED.value();  &#125;&#125;</code></pre><hr><p><code>WebResponseExceptionTranslator实现类</code>：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.component;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrResponseExceptionTranslator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebResponseExceptionTranslator</span> </span>&#123;  <span class="hljs-keyword">private</span> ThrowableAnalyzer throwableAnalyzer = <span class="hljs-keyword">new</span> DefaultThrowableAnalyzer();  <span class="hljs-meta">@Override</span>  <span class="hljs-meta">@SneakyThrows</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">translate</span><span class="hljs-params">(Exception e)</span> </span>&#123;    Throwable[] causeChain = throwableAnalyzer.determineCauseChain(e);    Exception ase = (AuthenticationException) throwableAnalyzer.getFirstThrowableOfType(AuthenticationException<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class">        <span class="hljs-title">causeChain</span>)</span>;    <span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> handleOAuth2Exception(<span class="hljs-keyword">new</span> UnauthorizedException(e.getMessage(), e));    &#125;    ase = (AccessDeniedException) throwableAnalyzer        .getFirstThrowableOfType(AccessDeniedException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;    <span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> handleOAuth2Exception(<span class="hljs-keyword">new</span> ForbiddenException(ase.getMessage(), ase));    &#125;    ase = (InvalidGrantException) throwableAnalyzer        .getFirstThrowableOfType(InvalidGrantException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;    <span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> handleOAuth2Exception(<span class="hljs-keyword">new</span> InvalidException(ase.getMessage(), ase));    &#125;    ase = (HttpRequestMethodNotSupportedException) throwableAnalyzer        .getFirstThrowableOfType(HttpRequestMethodNotSupportedException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;    <span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> handleOAuth2Exception(<span class="hljs-keyword">new</span> MethodNotAllowed(ase.getMessage(), ase));    &#125;    ase = (OAuth2Exception) throwableAnalyzer.getFirstThrowableOfType(        OAuth2Exception<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;    <span class="hljs-keyword">if</span> (ase != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">return</span> handleOAuth2Exception((OAuth2Exception) ase);    &#125;    <span class="hljs-keyword">return</span> handleOAuth2Exception(<span class="hljs-keyword">new</span> ServerErrorException(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), e));  &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> ResponseEntity&lt;OAuth2Exception&gt; <span class="hljs-title">handleOAuth2Exception</span><span class="hljs-params">(OAuth2Exception e)</span> </span>&#123;    <span class="hljs-keyword">int</span> status = e.getHttpErrorCode();    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();    headers.set(HttpHeaders.CACHE_CONTROL, <span class="hljs-string">"no-store"</span>);    headers.set(HttpHeaders.PRAGMA, <span class="hljs-string">"no-cache"</span>);    <span class="hljs-keyword">if</span> (status == HttpStatus.UNAUTHORIZED.value() || (e <span class="hljs-keyword">instanceof</span> InsufficientScopeException)) &#123;      headers.set(HttpHeaders.WWW_AUTHENTICATE, String.format(<span class="hljs-string">"%s %s"</span>, OAuth2AccessToken.BEARER_TYPE, e.getSummary()));    &#125;    <span class="hljs-comment">// 客户端异常直接返回客户端,不然无法解析</span>    <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ClientAuthenticationException) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(e, headers,          HttpStatus.valueOf(status));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(<span class="hljs-keyword">new</span> McrAuth2Exception(e.getMessage(), e.getOAuth2ErrorCode()), headers,        HttpStatus.valueOf(status));  &#125;&#125;</code></pre><p>在TokenEndpoint上绑定上<code>McrResponseExceptionTranslator</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;<span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    endpoints<span class="hljs-comment">//...       </span>        👇关键代码        .exceptionTranslator(<span class="hljs-keyword">new</span> McrResponseExceptionTranslator());  &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>OAuth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 OAuth2-学习笔记 】  1.Hello OAuth2</title>
    <link href="/oauth2-1.html"/>
    <url>/oauth2-1.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Spring Security 已经更新到5.X了，我为了不被抛太远决定重新学习Spring Security 5.x中的OAuth</p></blockquote><p>创建一个spring boot工程</p><p>pom如下：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mcr<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>auth<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>OAuth Learn<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-comment">&lt;!--  &lt;dependency&gt;</span><span class="hljs-comment">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><span class="hljs-comment">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><span class="hljs-comment">            &lt;version&gt;2.1.2&lt;/version&gt;</span><span class="hljs-comment">        &lt;/dependency&gt;</span><span class="hljs-comment">        &lt;dependency&gt;</span><span class="hljs-comment">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><span class="hljs-comment">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><span class="hljs-comment">            &lt;scope&gt;runtime&lt;/scope&gt;</span><span class="hljs-comment">        &lt;/dependency&gt;--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><hr><p>yml：</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">4444</span><span class="hljs-attr">security:</span>  <span class="hljs-attr">oauth2:</span>    <span class="hljs-attr">client:</span>      <span class="hljs-attr">client-id:</span> <span class="hljs-string">mcr</span>      <span class="hljs-attr">client-secret:</span> <span class="hljs-string">mcr</span></code></pre><hr><p>Web安全配置：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.crypto.factory.PasswordEncoderFactories;<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfig</span> </span>&#123;  <span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();  &#125;&#125;</code></pre><p>这里的<code>PasswordEncoderFactories.createDelegatingPasswordEncoder()</code>的解释这里说的很清楚：<a href="https://www.cnblogs.com/Irving/p/9579025.html" target="_blank" rel="noopener">链接</a></p><hr><p>认证服务配置类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorizationServerConfig</span> </span>&#123;&#125;</code></pre><hr><p>资源服务配置类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.config;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResourceServerConfig</span> </span>&#123;&#125;</code></pre><hr><p>这里自定义一个UserDetailsService，将密码设置为123方便做测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.security.service;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;<span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;  <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;    log.info(<span class="hljs-string">"账号为-&gt;&#123;&#125;进行了验证"</span>, username);    String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));  &#125;&#125;</code></pre><hr><p>业务相关代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.auth.common.controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;  <span class="hljs-meta">@GetMapping</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello OAuth!"</span>;  &#125;&#125;</code></pre><hr><p>上面的<code>AuthorizationServerConfig</code>配置类会提供一些请求，这里我通过请求工具类进行访问一下<code>oauth/token</code>这个请求路径，它是授权模式中的一种，具体其它的可参考 <a href="https://github.com/jeansfish/RFC6749.zh-cn/blob/master/SUMMARY.md" target="_blank" rel="noopener">OAuth2.0授权模式</a>，这里我使用的是密码模式，通过IDEA来访问：</p><pre><code class="hljs http">POST http://localhost:4444/oauth/token<span class="hljs-attribute">Authorization</span>: Basic bWNyOm1jcg==<span class="hljs-attribute">Content-Type</span>: multipart/form-data; boundary=WebAppBoundary--WebAppBoundary<span class="hljs-attribute">Content-Disposition</span>: form-data; name="grant_type"<span class="hljs-attribute">password</span><span class="hljs-attribute">--WebAppBoundary</span><span class="hljs-attribute">Content-Disposition</span>: form-data; name="username"<span class="hljs-attribute">test</span><span class="hljs-attribute">--WebAppBoundary</span><span class="hljs-attribute">Content-Disposition</span>: form-data; name="password"<span class="hljs-attribute">123</span><span class="hljs-attribute">--WebAppBoundary</span><span class="hljs-attribute">Content-Disposition</span>: form-data; name="scope"<span class="hljs-attribute">server</span><span class="hljs-attribute">--WebAppBoundary--</span></code></pre><p>结果：</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"13a3d723-71df-4608-8457-718b001d96ce"</span>,  <span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,  <span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"d0fee4d9-1100-4d8c-922f-06de543ac5bf"</span>,  <span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">43118</span>,  <span class="hljs-attr">"scope"</span>: <span class="hljs-string">"server"</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>OAuth</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】 Linux中的一些命令</title>
    <link href="/linux-3.html"/>
    <url>/linux-3.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录一些容易忘记的命令</p></blockquote><h1 id="查看端口和pid"><a href="#查看端口和pid" class="headerlink" title="查看端口和pid"></a>查看端口和pid</h1><pre><code class="hljs bash">~&gt; netstat  -luntp | grep 6379</code></pre><h1 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h1><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><h3 id="忽略第1行，只查1列"><a href="#忽略第1行，只查1列" class="headerlink" title="忽略第1行，只查1列"></a>忽略第1行，只查1列</h3><pre><code class="hljs bash">~&gt; docker images | awk <span class="hljs-string">'NR &gt; 1'</span> | awk <span class="hljs-string">'&#123; print $1 &#125;'</span>redismcr.harbor.com/library/redismcr.harbor.com/library/mysqlmysqlmcr.harbor.com/library/mysqlanapsix/alpine-java</code></pre><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><pre><code class="hljs bash">~&gt; ps -ef | grep redis-serverroot      51475      1  0 22:18 ?        00:00:00 redis-server *:6370 [cluster]root      51479      1  0 22:18 ?        00:00:00 redis-server *:6371 [cluster]root      51483      1  0 22:18 ?        00:00:00 redis-server *:6372 [cluster]root      51487      1  0 22:18 ?        00:00:00 redis-server *:6373 [cluster]root      51492      1  0 22:19 ?        00:00:00 redis-server *:6374 [cluster]root      51497      1  1 22:19 ?        00:00:00 redis-server *:6375 [cluster]root      51502  44468  0 22:19 pts/0    00:00:00 grep --color=auto redis-server<span class="hljs-comment">#打印PID</span>~&gt; ps -ef | grep redis-server | grep 637 | awk <span class="hljs-string">'&#123;print $2&#125;'</span>514755147951483514875149251497<span class="hljs-comment">#使用xargs</span>~&gt; ps -ef | grep redis-server | grep 637 | awk <span class="hljs-string">'&#123;print $2&#125;'</span> | → 关键位置 xargs <span class="hljs-built_in">kill</span></code></pre><h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>将6379全部替换为6380</p><pre><code class="hljs bash">&gt; sed <span class="hljs-string">'s/6379/6380/g'</span> redis-6379.conf  &gt; redis-6380.conf</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nginx】 4-深度学习篇</title>
    <link href="/nginx-4.html"/>
    <url>/nginx-4.html</url>
    
    <content type="html"><![CDATA[<h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是动静分离？"><a href="#什么是动静分离？" class="headerlink" title="什么是动静分离？"></a>什么是动静分离？</h3><p>通过中间件将动态请求和静态请求分离。</p><h3 id="为什么要使用动静分离？"><a href="#为什么要使用动静分离？" class="headerlink" title="为什么要使用动静分离？"></a>为什么要使用动静分离？</h3><p>对于服务端而言减少不必要的请求消耗，我一些静态请求的资源不需要后端的CPU运算，对于客户端而言我请求静态资源不用复杂的运算了那么就可以减少请求的等待时间。</p><p>没有动静分离的请求流程：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200213091855952-1581556745386.png" srcset="/img/loading.gif" alt="image-20200213091855952"></p><p>一个请求首先去会去请求中间件，由中间件把请求转给程序框架执行对应的加载，程序框架去执行运算对应的程序获取相关的数据资源。如果每一次请求都需要这些关系对于请求的消耗和响应都会受到影响。</p><p>对于静态请求而言其实不需要程序框架，通过中间件执行从硬盘里获取到这个静态资源就可以了。</p><h2 id="场景演示"><a href="#场景演示" class="headerlink" title="场景演示"></a>场景演示</h2><p>这里准备了一个<code>Spring Boot</code>的jar包，提供了一个动态的请求</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.demo.web.controller;<span class="hljs-keyword">import</span> cn.hutool.core.util.RandomUtil;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Shui</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/demo"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoController</span> </span>&#123;  <span class="hljs-meta">@GetMapping</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> RandomUtil.randomInt(<span class="hljs-number">999</span>);  &#125;&#125;</code></pre><p>这里将它启动</p><pre><code class="hljs bash">/opt/app&gt; lscache  code1  code2  code3  demo.jar/opt/app&gt; nohup  java -jar demo.jar &gt; info.log &amp;</code></pre><p>等会我们演示的时候会访问的页面，它的内容为：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>动静分离测试<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"dynamic"</span>&gt;</span>Load...<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://dev001.com/image/test.png"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://code.jquery.com/jquery-3.4.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">$(() =&gt; &#123;</span><span class="javascript">  $.<span class="hljs-keyword">get</span>('http://dev001.com/demo', (data) =&gt; &#123;</span><span class="javascript">    $(<span class="hljs-string">'#dynamic'</span>).text(data);</span>  &#125;, () =&gt; &#123;<span class="actionscript">    alert(<span class="hljs-string">'动态请求失败'</span>);</span>  &#125;);&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><blockquote><p>这里的img访问的属于静态资源，而通过jquery Ajajx访问的是动态资源,这个html文件放在<code>/opt/app/code</code>中</p></blockquote><p>上面这个页面的图片是在这里：</p><pre><code class="hljs bash">/opt/app/code/image&gt; lstest.png</code></pre><p>test_mysite.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span> ;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">access_log</span>  /var/log/nginx/host.access.log  main;    <span class="hljs-attribute">root</span> /opt/app/code;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/demo</span> &#123;        <span class="hljs-attribute">proxy_pass</span> http://localhost:8080;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.html$</span> &#123;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.(jpg|png|gif)$</span> &#123;        <span class="hljs-attribute">expires</span> <span class="hljs-number">1h</span>;        <span class="hljs-attribute">gzip</span> <span class="hljs-literal">on</span>;    &#125;&#125;</code></pre><h1 id="Rewrite规则"><a href="#Rewrite规则" class="headerlink" title="Rewrite规则"></a>Rewrite规则</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>实现url重写以及重定向</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>1）、URL访问跳转，支持开发设计</p><ul><li>页面跳转</li><li>兼容性支持：版本升级的时候为支持老的版本为了兼容部分老的版本或者老的用户这个时候需要系统老的请求路径使得能访问到。</li><li>展示效果等：对于复杂的URL如果展示的过于复杂这样对于页面展示路径就是大长串，我们可以使用<code>rewrite规则</code>将其精简缩略</li></ul><p>2）、SEO优化</p><p>我们知道对于谷歌、百度这种搜索引擎优化，搜索的效率还排名是依赖与URL路径的，如果我们的路径过于复杂不符合谷歌、百度这些规则的话，这个时候对搜索引擎的录入存在一些问题，在这个时候我们可以依赖于<code>Nginx</code>来让我们后端的接口静态的改写以符合对应搜索引擎的搜索规范</p><p>3）、维护</p><p>后台维护、流量转发</p><p>4）、安全</p><p>我们用到<code>rewrite规则</code>可以实现伪静态，所谓伪静态就是将真实的动态页面进行伪装让黑客进行访问抓取的时候感觉不出来这是一个动态页面</p><h3 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h3><p>对于<code>rewrite</code>它依赖于<code>ngx_http_rewrite_module</code>这个模块，详细的配置可以参考<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">文档</a>。核心的配置语法这里列出来如下：</p><table><thead><tr><th align="left">Syntax:</th><th><code>**rewrite** *regex* *replacement* [*flag*];</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>server</code>, <code>location</code>, <code>if</code></td></tr></tbody></table><ul><li>regex：正则表达式，需要去改写的路径</li><li>replacement：目标要替换成哪个URL或者对应的路径</li><li>flag：标识</li></ul><p>实例：</p><pre><code class="hljs nginx"><span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)$</span> /pages/maintain.html <span class="hljs-literal">break</span>;</code></pre><blockquote><p>这里意思是所有的请求都会重定向到<code>/pages/maintain.html</code>，后面的break是标识符</p></blockquote><h3 id="rewrite正则表达式"><a href="#rewrite正则表达式" class="headerlink" title="rewrite正则表达式"></a>rewrite正则表达式</h3><table><thead><tr><th>符号</th><th>介绍</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>*</td><td>最少链接数，哪个机器连接数少就分发</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于<code>[^0-9]</code>。</td></tr><tr><td>\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td></tr><tr><td>\S</td><td>匹配一个非空白字符</td></tr><tr><td>\w</td><td>匹配一个单字字符（字母、数字或者下划线），等价于 <code>[A-Za-z0-9_]</code></td></tr><tr><td>\W</td><td>匹配一个非单字字符,等价于 <code>[^A-Za-z0-9_]</code></td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的介绍</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>[c]</td><td>匹配单个字符串c</td></tr><tr><td>[a-z]</td><td>匹配a-z小写字母的任意一个</td></tr><tr><td>\</td><td>转义字符。例如你想匹配<code>index.php</code>跳转到前端页面，就是这么来写：<code>rewrite index\.php$ /pages/maintain.html break;</code></td></tr><tr><td>()</td><td>用于匹配括号之间的内容，通过<code>$1</code>、<code>$2</code>调用。例如：<br /><code>rewrite ^(.*)$ /msie/$1 break;</code>，这里的括号部分的内容会放在<code>$1</code>中</td></tr></tbody></table><blockquote><p>由于正则表达式在编程语言中是通用的，想了解更多可以参考<code>Javascript</code>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式文档</a></p></blockquote><p>对于正则表达式，这里介绍一个Linux测试工具“pcretest”，它能够测试表达式，使用方式参考<a href="https://blog.csdn.net/xiao__jia__jia/article/details/84934552" target="_blank" rel="noopener">文章</a></p><h3 id="rewrite规则中的flag"><a href="#rewrite规则中的flag" class="headerlink" title="rewrite规则中的flag"></a>rewrite规则中的flag</h3><p>flag能标记rewrite对应的类型，它的类型如下：</p><table><thead><tr><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td>last</td><td>停止rewrite检测</td></tr><tr><td>break</td><td>停止rewrite检测</td></tr><tr><td>redirect</td><td>返回302临时重定向，地址栏会显示跳转后的地址</td></tr><tr><td>permanent</td><td>返回301永久重定向，地址栏会显示跳转后的地址</td></tr></tbody></table><h2 id="last和break的区别"><a href="#last和break的区别" class="headerlink" title="last和break的区别"></a>last和break的区别</h2><p>test_rewrite.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;    <span class="hljs-attribute">server_name</span> localhost;    <span class="hljs-attribute">access_log</span> /var/log/nginx/host.access.log main;    <span class="hljs-attribute">root</span> /opt/app/code;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/break</span> &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/break</span> /test/ <span class="hljs-literal">break</span>;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/last</span> &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/last</span> /test/ <span class="hljs-literal">last</span>;    &#125;    <span class="hljs-attribute">location</span> /test/ &#123;        <span class="hljs-attribute">default_type</span> application/json;        <span class="hljs-attribute">return</span> <span class="hljs-number">200</span> <span class="hljs-string">'&#123;"status","success"&#125;'</span>;    &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; curl localhost/<span class="hljs-built_in">test</span>/&#123;<span class="hljs-string">"status"</span>,<span class="hljs-string">"success"</span>&#125;~&gt; curl localhost/<span class="hljs-built_in">break</span>&lt;html&gt;&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;~&gt; curl localhost/last&#123;<span class="hljs-string">"status"</span>,<span class="hljs-string">"success"</span>&#125;</code></pre><p>上面可以看到访问这个<code>break</code>是404，它将会去<code>root</code>定义的<code>/opt/app/code</code>去查找对应的访问路径是否存在，在这个目录中是没有test这个目录的，所以它这里会出现404。</p><p><code>last</code>这里则是新建一个请求，也就是说它会重新请求一次服务端的地址。</p><h2 id="redirect和permanent的区别"><a href="#redirect和permanent的区别" class="headerlink" title="redirect和permanent的区别"></a>redirect和permanent的区别</h2><p>test_rewrite.conf中加入：</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/redirect</span> &#123;      <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/redirect</span> https://www.baidu.com <span class="hljs-literal">redirect</span>;  &#125;  <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/permanent</span> &#123;      <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/permanent</span> https://www.baidu.com <span class="hljs-literal">permanent</span>;  &#125;</code></pre><p>测试描述</p><blockquote><p>由于不太方便写，这里就来说一说它们的区别</p></blockquote><p>它们2个都能成功跳转到百度上去，当将Nginx关闭时，去访问<code>localhost/permanent</code>还是能够跳转到百度的，但是访问<code>localhost/redirect</code>会响应404，这是因为<code>permanent</code>会通过<code>Cookie</code>告诉客户端也就是浏览器该跳转到哪里，即使我们Nginx服务停掉了，浏览器下一次去访问<code>localhost/permanent</code>是直接跳转到百度上去的，而<code>localhost/redirect</code>则是需要先在Nginx发送一次请求而这个时候Nginx是关的。</p><h2 id="场景实战"><a href="#场景实战" class="headerlink" title="场景实战"></a>场景实战</h2><h3 id="遇见多层级目录的页面"><a href="#遇见多层级目录的页面" class="headerlink" title="遇见多层级目录的页面"></a>遇见多层级目录的页面</h3><pre><code class="hljs bash">/opt/app/code/11/22/33&gt; ls<span class="hljs-built_in">test</span>-1.html...<span class="hljs-built_in">test</span>-233.html</code></pre><blockquote><p>假设我给Nginx的conf的<code>root</code>设置的是<code>/opt/app/code</code>那么用户想来访问这个<code>test-233.html</code>就需要这样：<code>localhost/11/22/33/test-233.html</code>，这里通过rewrite将它的访问修改一下吧</p></blockquote><p>test_rewrite2.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span> default_server;    <span class="hljs-attribute">server_name</span> localhost;    <span class="hljs-attribute">access_log</span> /var/log/nginx/host.access.log main;    <span class="hljs-attribute">root</span> /opt/app/code;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(\d+)-(\d+)-(\d+)-test-(\d+)\.html</span> /<span class="hljs-variable">$1</span>/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$3</span>/test-<span class="hljs-variable">$4</span>.html <span class="hljs-literal">break</span>;    &#125;&#125;</code></pre><p>结果</p><pre><code class="hljs bash">curl http://dev001.com/11-22-33-test-233.htmlrewrite <span class="hljs-built_in">test</span></code></pre><h3 id="如果是谷歌浏览器转发到百度上"><a href="#如果是谷歌浏览器转发到百度上" class="headerlink" title="如果是谷歌浏览器转发到百度上"></a>如果是谷歌浏览器转发到百度上</h3><p>test_rewrite2.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(\d+)-(\d+)-(\d+)-test-(\d+)\.html</span> /<span class="hljs-variable">$1</span>/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$3</span>/test-<span class="hljs-variable">$4</span>.html <span class="hljs-literal">break</span>;        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_user_agent</span> <span class="hljs-regexp">~* Chrome)</span>&#123;            <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/nginx</span> https://www.baidu.com <span class="hljs-literal">redirect</span>;        &#125;    &#125;</code></pre><h3 id="文件不存在处理"><a href="#文件不存在处理" class="headerlink" title="文件不存在处理"></a>文件不存在处理</h3><blockquote><p>如果请求的文件路径存在就访问对应的文件，如果不存在就跳转百度上</p></blockquote><p>test_rewrite2.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;        <span class="hljs-comment">#...</span>        <span class="hljs-attribute">if</span> (!-f <span class="hljs-variable">$request_filename</span>) &#123;            <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(.*)$</span> https://www.baidu.com/s?wd=<span class="hljs-variable">$1</span> <span class="hljs-literal">redirect</span>;        &#125;    &#125;</code></pre><p>结果：</p><pre><code class="hljs bash">~&gt; curl http://dev001.com/11-22-33-test-233.htmlrewrite <span class="hljs-built_in">test</span>~&gt; curl http://dev001.com/11-22-33-hahah-100.html&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="rewrite规则书写"><a href="#rewrite规则书写" class="headerlink" title="rewrite规则书写"></a>rewrite规则书写</h2><h3 id="Rewrite规则优先级"><a href="#Rewrite规则优先级" class="headerlink" title="Rewrite规则优先级"></a>Rewrite规则优先级</h3><ol><li>执行server块的rewrite指令：对于网站维护页，我们需要把所有请求都重定向到一个请求的时候，加在对应的server下面，或者http下面</li><li>执行location匹配</li><li>执行选定的location中的rewrite</li></ol><h3 id="优雅的Rewrite规则书写"><a href="#优雅的Rewrite规则书写" class="headerlink" title="优雅的Rewrite规则书写"></a>优雅的Rewrite规则书写</h3><p>在<code>Apache Tomcat</code>的规则里面，Nginx的写法也是可以支持的</p><pre><code class="hljs nginx">RewriteCond %&#123;HTTP_HOST&#125; nginx.org<span class="hljs-attribute">RewriteRule</span> (.*)</code></pre><p>在Nginx中的写法</p><pre><code class="hljs nginx">server&#123;<span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> www.nginx.org nginx.org;  <span class="hljs-attribute">if</span> (<span class="hljs-variable">$http_host</span>=nginx.org) &#123;    <span class="hljs-attribute">rewrite</span> (.*) http://www.nginx.org<span class="hljs-variable">$1</span>;  &#125;...&#125;</code></pre><p>对于这种写法，官方更加推荐这样：</p><pre><code class="hljs nginx">server&#123;  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;  <span class="hljs-attribute">server_name</span> nginx.org;  <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^</span> http://www.nginx.org<span class="hljs-variable">$request_uri</span>?;&#125;</code></pre><blockquote><p>这里只需要加1行就搞定了，对与rewrite规则，我们书写得优雅以及后端的性能书面整洁性都是非常有学问的</p></blockquote><h1 id="进阶高级模块"><a href="#进阶高级模块" class="headerlink" title="进阶高级模块"></a>进阶高级模块</h1><h2 id="secure-link"><a href="#secure-link" class="headerlink" title="secure_link"></a>secure_link</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>详细可以参考<a href="https://nginx.org/en/docs/http/ngx_http_secure_link_module.html" target="_blank" rel="noopener">官网文档</a></p></blockquote><p><strong>作用</strong></p><ul><li>制定并允许检查请求的链接的真实性以及保护资源免遭未经授权的访问</li><li>限制链接生效周期</li></ul><hr><p><strong>配置语法</strong></p><table><thead><tr><th align="left">Syntax:</th><th><code>**secure_link** *expression*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><blockquote><p>定义一个带有变量的字符串，从中将提取链接的校验和值和生存期。</p></blockquote><table><thead><tr><th align="left">Syntax:</th><th><code>**secure_link_md5** *expression*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><blockquote><p>定义一个表达式，将为其计算MD5哈希值并将其与请求中传递的值进行比较。</p></blockquote><hr><p><strong>常见场景</strong></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200213201449276.png" srcset="/img/loading.gif" alt="image-20200213201449276"></p><ol><li>客户端下载某个文件，第1步：点击下载按钮，这里会向服务端发起一次请求；</li><li>服务端收到请求的时候，会生成一个下载地址响应给客户端，生成的这个地址是经过一串秘钥以及相应的信息和过期时间加密的，以图中的请求地址为例，这里用到了md5字符串的加密，它是不可匿的，所以客户端获取了加密串它也解密不出来，只有服务端才能对应匹配，这个请求地址中还有一个<code>expires</code>，这个是用于设置过期时间的，它这里是一个时间戳，代表这个请求会在什么时候过期；</li><li>这个时候完成校验，如果校验通过了下载资源，如果没有通过就返回相关错误码。</li></ol><h3 id="实现资源请求验证"><a href="#实现资源请求验证" class="headerlink" title="实现资源请求验证"></a>实现资源请求验证</h3><p>这里准备了一个文件：</p><pre><code class="hljs bash">~/opt/app/code/download&gt;  lsfile.txt</code></pre><p>md5url.sh：用于模拟服务端返回的加密下载请求地址</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">Auth:shui</span>servername="dev001.com"download_file="/download/file.txt"time_num=$(date -d "2020-10-18 00:00:00" +%s)secret_num="mcr"res=$(echo -n "$&#123;time_num&#125;$&#123;download_file&#125; $&#123;secret_num&#125;" | openssl md5 -binary | openssl base64 | tr +/ -_ | tr -d = )echo "http://$&#123;servername&#125;$&#123;download_file&#125;?md5=$&#123;res&#125;&amp;expires=$&#123;time_num&#125;"</code></pre><p>test_safe_down.conf（nginx的配置）</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> localhost;    <span class="hljs-attribute">root</span> /opt/app/code;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">secure_link</span> <span class="hljs-variable">$arg_md5</span>,<span class="hljs-variable">$arg_expires</span>;        <span class="hljs-attribute">secure_link_md5</span> <span class="hljs-string">"<span class="hljs-variable">$secure_link_expires</span><span class="hljs-variable">$uri</span> mcr"</span>;        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$secure_link</span> = <span class="hljs-string">""</span>) &#123;            <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;        &#125;        <span class="hljs-attribute">if</span> (<span class="hljs-variable">$secure_link</span> = <span class="hljs-string">"0"</span>) &#123;            <span class="hljs-attribute">return</span> <span class="hljs-number">410</span>;        &#125;    &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt;./md5url.sh http://dev001.com/download/file.txt?md5=xjbPG9i92jvZWIYZLWVdLQ&amp;expires=1602950400</code></pre><blockquote><p>将<code>md5url.sh</code> 中获取的地址拿到浏览器中运行看下结果是可以正常访问的，你试着改写它们的值看能否正常访问，如果访问失败就实现功能了</p></blockquote><h2 id="geoip"><a href="#geoip" class="headerlink" title="geoip"></a>geoip</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><strong>作用</strong></p><p>比如这么个场景：一个企业有2个服务器，一个在国内一个在国外，它2个站点上是放着不同的信息，它想国内的用户访问的是国内服务器的IP，国外的用户去访问国外服务器的IP，这个时候就可以使用geoip来解决这个问题。它的作用：<strong>基于IP地址匹配MaxMind GeoIP二进制文件，读取IP所在地域信息。</strong></p><p><code>MaxMind</code>在搜索引擎上就可以下载，geoip这个模块就是用来读取<code>MaxMind</code>开放的IP库信息，然后获取到基于IP对应的地域信息。</p><p><strong>安装</strong></p><blockquote><p>暂无</p></blockquote><h1 id="HTTPS服务"><a href="#HTTPS服务" class="headerlink" title="HTTPS服务"></a>HTTPS服务</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><h3 id="为什么需要HTTPS？"><a href="#为什么需要HTTPS？" class="headerlink" title="为什么需要HTTPS？"></a>为什么需要HTTPS？</h3><p>原因：HTTP不安全</p><ul><li>传输数据被中间人盗用、信息泄露</li><li>数据内容劫持、篡改</li></ul><h3 id="HTTPS协议的实现"><a href="#HTTPS协议的实现" class="headerlink" title="HTTPS协议的实现"></a>HTTPS协议的实现</h3><p>1）、对传输内容进行加密以及身份验证</p><p>2）、对称加密和非对称加密</p><p>对称加密：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200214111011728.png" srcset="/img/loading.gif" alt="image-20200214111011728"></p><p>发送方进行数据的加密，接受放进行数据的解密，发送方用的是加密秘钥，接收方用的是解密的秘钥，这个就是对称加密，对称加密的特点是加密秘钥和解密秘钥可以是一样的，数据在发送方用同一个秘钥拿出来进行加密以后进行发送，传输的中间就是密文的，在通过接受方用到同一个密码串进行解密成为明文进行读取。对称加密的特点是加密秘钥和解密秘钥是一样的。</p><p>非对称加密：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200214111621080.png" srcset="/img/loading.gif" alt="image-20200214111621080"></p><p>这里加密秘钥和解密秘钥是2个不一样的，但是只有我们常说公钥和私钥，公钥用于加密，私钥用于解密，一串公钥对应一串私钥只有通过公钥加密的东西才能与之对应规定的私钥才能解密，所以服务端（接收方）一般保留私钥，发送方保留公钥，所以可以知道非对称加密是2串不同的秘钥，这个就是和对称加密的区别</p><hr><p>3）、HTTPS加密协议原理</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200214112047266.png" srcset="/img/loading.gif" alt="image-20200214112047266"></p><p>HTTPS同时用到了加密和对称加密、非对称加密。当用户端发起SSL连接的时候，它进行的是非对称加密，非对称加密将公钥发送给客户端以后，客户端用对应的公钥加密它接下来要进行对称加密的密码，用非对称加密的公钥加密这个密码并发送到服务端，这样的话它们前面这个非对称加密的作用就是为了对称加密后面传输数据进行前期的验证以及加密的传输。这里就有疑问了，为什么HTTPS要选择非对称和对称同时使用？</p><p>—这个主要是对称加密和非对称加密的优缺点有关系，非对称加密往往对于连接要求更高，服务端发送一个公钥给客户端，如果多次连接的情况下这样对性能是有损耗的，对称加密对于性能来说更多简单，所以在第一次进行安全的验证以后，完全就可以利用到对称加密就可以了。</p><hr><p>4）、中间人伪装客户端和服务端</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200214114257164.png" srcset="/img/loading.gif" alt="image-20200214114257164"></p><p>HTTPS对于中间人的劫持它是怎么防范的呢？</p><p>有了对称加密和非对称加密按道理中间人是不会劫持到的，但是现在中间人的劫持手段是非常高明的，它既可以伪装客户端进行劫持也能伪装服务端对客户端的数据进行劫持，也就是说它可能在前边进行握手的时候完全对客户端向服务端发的数据包进行劫持伪装，并且在服务端发送给客户端数据的时候也能伪装服务端进行劫持，这样的话就能完全伪装中间人对多次连接进行劫持，这个的话是解决不了这种中间人技术的劫持的问题的。</p><p>怎么办呢？这个时候就用到了HTTPS的CA证书</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200214114533277.png" srcset="/img/loading.gif" alt="image-20200214114533277"></p><p>服务端向客户端之前是发送的公证，对于对称加密而言，对于HTTPS这个时候发给客户端的是一个<code>CA签名证书</code>，有了这个<code>CA签名证书</code>，中间人的劫持作用就没有了，因为客户端会另外对这个<code>CA签名证书</code>进行校验，中间人是无法生成一个能够进行匹配<code>CA签名证书</code>的校验的，因为客户端会<code>CA签名证书</code>进行校验，它将和第三方签名机构进行校验，如果校验成功就会利用对应的公钥加密，因为<code>CA签名证书</code>包含了对应的公钥，如果验证失败客户端将终止这一次会话，对于中间人这样的方式就无法实现了，因为这个签名的证书是放在服务端之前就已经和第三方机构进行对应的签名和对应的授权。客户端在真正的进行连接的时候还需要进行一次校验，中间人的劫持就无法实现。HTTPS它的安全性对于中间人劫持这种可能性就能完全预防掉，其原理就用到了<code>CA签名证书</code>。</p><h3 id="证书签名生成CA证书"><a href="#证书签名生成CA证书" class="headerlink" title="证书签名生成CA证书"></a>证书签名生成CA证书</h3><blockquote><p>这里介绍的是自签证书的类型，对于读者想去通过证书去寻求跟第三方公司或者公司进行签发的对应的证书在后面的章节会去介绍流程的，为什么呢？1、因为实际的场景不太符合，因为我们去找公司去签发的话是需要对应的要出钱，每个公司提交的信息是不太一样的，是需要一定时间的，所以这个章节没有讲到关于公司的签发；2、我们需要公司的签发证书的话不是一个非常难的事情，只要我们学会了整体证书的秘钥的生成以及请求文件的生成以自签文件的过程和HTTPS的原理，我们想去寻求任意一家公司进行公司证书的签名这是非常简单的事情。</p></blockquote><p>1）、生成秘钥和CA证书</p><p>准备工作：</p><p>首先确认系统中是否有openssl</p><pre><code class="hljs bash">~&gt; openssl  versionOpenSSL 1.0.2k-fips  26 Jan 2017</code></pre><p>确认Nginx是否有http_ssl_module </p><pre><code class="hljs bash">~&gt; nginx -V--with-http_ssl_module</code></pre><p>步骤：</p><ul><li>生成key秘钥</li><li>生成证书签名请求文件（csr文件）</li></ul><blockquote><p>有了csr文件以后就可以将秘钥和csr文件一并打包发送对应的签名机构，关于你的网站域名以及对应相关公司的信息，去进行CA证书的签名，让第三方的结构来给你进行对应的签名，它将返回给你对应的CA证书</p></blockquote><ul><li>对于目前学习阶段没有必要去向第三方结构签名的情况，这里就自己来签名生成这个签名文件（CA文件）</li></ul><h2 id="场景演示-1"><a href="#场景演示-1" class="headerlink" title="场景演示"></a>场景演示</h2><p>生成HTTPS签名证书</p><pre><code class="hljs bash">/etc/nginx&gt; mkdir ssl_key<span class="hljs-comment">#mcr.key:key文件名</span><span class="hljs-comment">#1024：位数越高精度就越高</span>/etc/nginx/ssl_key&gt; openssl genrsa -idea -out mcr.key 1024Enter pass phrase <span class="hljs-keyword">for</span> mcr.key: 123456Verifying - Enter pass phrase <span class="hljs-keyword">for</span> mcr.key: 123456/etc/nginx/ssl_key&gt; lsmcr.key</code></pre><p>存储HTTPS签名证书密码文件</p><pre><code class="hljs bash">/etc/nginx/ssl_key&gt; <span class="hljs-built_in">echo</span> 123456 &gt; mcr.pass</code></pre><p>生成csr证书签名请求文件</p><pre><code class="hljs bash">/etc/nginx/ssl_key&gt; openssl   req -new -key mcr.key  -out mcr.csrEnter pass phrase <span class="hljs-keyword">for</span> mcr.key: 123456<span class="hljs-comment">#这里如果是给三方结构做签名要按照要求来写，因为这里我们是自签名的，所以比较随意</span>Country Name (2 letter code) [XX]: CNState or Province Name (full name) []:beijingLocality Name (eg, city) [Default City]:beijingOrganization Name (eg, company) [Default Company Ltd]:CNOrganizational Unit Name (eg, section) []:mcrCommon Name (eg, your name or your server<span class="hljs-string">'s hostname) []: dev001.com</span><span class="hljs-string">Email Address []:shui@163.com</span><span class="hljs-string"></span><span class="hljs-string">#csr文件如果要进行更改，另外的一个密码，如果没严格要求的话，可以不输入</span><span class="hljs-string">A challenge password []: </span><span class="hljs-string">An optional company name []:mcr</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">/etc/nginx/ssl_key&gt;  ls</span><span class="hljs-string">mcr.csr  mcr.keymcr.pass</span></code></pre><p>将这2个文件2包发送给签名机构进行对应的权威签名请求，对于公司而言大部分是这么做的，对于个人而言是基于这2个文件来建立自签名证书</p><pre><code class="hljs bash"><span class="hljs-comment">#-days：表示签名证书过期时间，对于过期时间而言如果默认没有写的话是在一个月左右就会过期，当你的网站上线以后很多客户端也有了对应的证书的请求，通过相应的证书文件，你的CA证书过期了这是非常有问题的，这样就会导致你的小问题一个参数没加导致因为过期了就需要重新发送版本，这对于企业来说是需要避免的，所以读者在实际的情况下面一定要加入好自己的过期时间</span>/etc/nginx/ssl_key&gt; openssl  x509 -req -days 3650 -<span class="hljs-keyword">in</span>  mcr.csr  -signkey mcr.key  -out mcr.crt  Enter pass phrase <span class="hljs-keyword">for</span> mcr.key: 123456/etc/nginx/ssl_key&gt;  lsmcr.crt  mcr.csr  mcr.keymcr.pass</code></pre><p>就下来就是需要Nginx进行配置了，这里列出它相关核心的配置语法：</p><ul><li>开启SSL</li></ul><p>| Syntax:  | <code>**ssl** on | off;</code> |<br>| :——- | ——————- |<br>| Default: | <code>ssl off;</code>          |<br>| Context: | <code>http</code>, <code>server</code>    |</p><ul><li>SSL证书文件</li></ul><table><thead><tr><th align="left">Syntax:</th><th><code>**ssl_certificate** *file*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code></td></tr></tbody></table><ul><li>SSL证书密码文件</li></ul><table><thead><tr><th align="left">Syntax:</th><th><code>**ssl_certificate_key** *file*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code></td></tr></tbody></table><ul><li>http签名证书 的密码文件</li></ul><table><thead><tr><th align="left">Syntax:</th><th><code>**ssl_password_file** *file*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code></td></tr></tbody></table><p>test_https.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;    <span class="hljs-attribute">server_name</span> <span class="hljs-number">192.168.202.151</span> dev001.com    ssl <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssl_certificate</span> /etc/nginx/ssl_key/mcr.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl_key/mcr.key;    <span class="hljs-attribute">ssl_password_file</span> /etc/nginx/ssl_key/mcr.pass;    <span class="hljs-attribute">index</span> index.html;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">root</span> /opt/app/code;    &#125;&#125;</code></pre><h2 id="配置苹果要求的openssl后台HTTPS服务"><a href="#配置苹果要求的openssl后台HTTPS服务" class="headerlink" title="配置苹果要求的openssl后台HTTPS服务"></a>配置苹果要求的openssl后台HTTPS服务</h2><p>配置苹果要求的证书</p><ul><li>服务器所有的连接使用TLS1.2以上版本（openssl 1.0.2）</li><li>HTTPS证书必须使用SHA256以上的哈希算法签名</li><li>HTTPS证书必须使用RSA 2048位或者ECC 256位以上公钥算法</li><li>使用前向加密技术</li></ul><p>查看openssl版本是否满足要求，这里如果不满足自行搜索引擎升级下</p><pre><code class="hljs bash">~&gt; oenssl versionOpenSSL 1.0.2k-fips  26 Jan 2017</code></pre><p>查看当前自签证书加密算法类型</p><pre><code class="hljs bash">~&gt; openssl x509 -noout -text -<span class="hljs-keyword">in</span> ./mcr.crtSignature Algorithm: sha256WithRSAEncryption Subject Public Key Info:            Public Key Algorithm: rsaEncryption                Public-Key: (1024 bit)</code></pre><blockquote><p>这里使用的是<code>sha2</code>算法类型所以没有满足苹果的要求，另外位数也没有满足这里是1024</p></blockquote><p>所以这里需要重新生成一个自签证书，这里有另一种方式生成，不需要一步一步的去生成了，而且这种方式Nginx是不需要配置<code>ssl_password_file</code>的</p><pre><code class="hljs bash">/etc/nginx/ssl_key&gt; openssl req -days 36500 -x509 -sha256  -nodes -newkey rsa:2048 -keyout mcr.key -out mcr_apple.crt</code></pre><p>test_https.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;    <span class="hljs-attribute">server_name</span> <span class="hljs-number">192.168.202.151</span> dev001.com    ssl <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssl_certificate</span> /etc/nginx/ssl_key/mcr_apple.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl_key/mcr.key;    <span class="hljs-attribute">index</span> index.html;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">root</span> /opt/app/code;    &#125;&#125;</code></pre><p>现在即使不配置<code>ssl_password_file</code>在<code>nginx reload</code>的时候也不需要输入密码，这个密码是干嘛呢？这里来说明下：</p><pre><code class="hljs bash">openssl req -days 36500 -x509 -sha256  -nodes -newkey rsa:2048 -keyout mcr.key -out mcr_apple.crt</code></pre><p>这个配置中加了一个<code>-keyout</code>选项，它会同时生成一个新的<code>mcr.key</code></p><pre><code class="hljs bash">/etc/nginx/ssl_key&gt; ll-rw-r--r--. 1 root root 1387 2月  14 19:47 mcr_apple.crt-rw-r--r--. 1 root root 1704 2月  14 19:47 mcr.key...</code></pre><p>从上面的shell终端中可以看到它们生成的时间是一样的，重新生成新的文件，对应于上一章节一个个生成，单独生成key文件的方式，我们如果想直接生成一个没有保护码的怎么办呢？</p><pre><code class="hljs bash">/etc/nginx/ssl_key&gt; openssl  rsa -<span class="hljs-keyword">in</span> ./mcr.key -out ./mcr_new.key</code></pre><blockquote><p>这里通过拷贝的方式去掉密码</p></blockquote><h2 id="HTTPS服务优化"><a href="#HTTPS服务优化" class="headerlink" title="HTTPS服务优化"></a>HTTPS服务优化</h2><p>对比HTTP，HTTPS的劣势，前面章节提到HTTPS的建立原理，HTTPS的建立是需要在HTTP之前建立SSL握手，SSL认证就会多一次连接，对于服务端就会需要对应的认证，这个是消耗服务端CPU资源和IO资源的，所以服务端而言我轻量级服务论性能上更愿意去处理HTTP请求，为什么大家还要去推荐HTTPS呢？因为我们后端的服务新型的架构不断的产生，对于Nginx我们可以进行水平的扩容以及负载均衡的出现，服务器的硬件的提升，导致我们对于性能的损耗往往不会特别关注，而是更多的去权衡安全，安全是更为重要的，所以在这种权衡关系下面，HTTPS得到了广泛的应用，但是我们也需要去考虑性能的优化，让单个服务器承载更多的并发，处理更多的请求。</p><p>优化方式：</p><ul><li>激活keepalive长连接：一次连接能够处理更多的请求这样的话建立握手的次数就会少，这对于服务端的性能就能有效的优化</li><li>设置ssl session缓存：把部分的信息内容放到缓存里面去，这样的话让服务器处理起来CPU的资源更少和处理更加快速</li></ul><p>test_https.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl;    <span class="hljs-attribute">server_name</span> <span class="hljs-number">192.168.202.151</span> dev001.com    ssl <span class="hljs-literal">on</span>;  <span class="hljs-comment">#共享缓存配置10兆，大约能够存储8k-10k的session会话</span>    <span class="hljs-attribute">ssl_session_cache</span> shared:SSL:<span class="hljs-number">10m</span>;  <span class="hljs-comment">#session会话过期时间：10分钟</span>    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">10m</span>;        <span class="hljs-attribute">ssl_certificate</span> /etc/nginx/ssl_key/mcr_apple.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/nginx/ssl_key/mcr.key;    <span class="hljs-attribute">index</span> index.html;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">root</span> /opt/app/code;    &#125;&#125;</code></pre><h1 id="与Lua的开发"><a href="#与Lua的开发" class="headerlink" title="与Lua的开发"></a>与Lua的开发</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>是一个简洁、轻量、可扩展的脚本语言。它的解释器比shell还小，它依赖与C语言的扩展性，所以只要用C语言封装的对应模块都可以实现它的封装扩展</p><h3 id="Nginx-Lua优势"><a href="#Nginx-Lua优势" class="headerlink" title="Nginx+Lua优势"></a>Nginx+Lua优势</h3><p>在大部分功能需求上面，我们用Nginx、Java、PHP都能实现对应的功能场景，但是结合Nginx+Lua我觉得最主要的要求就是提高高并发的场景。Nginx是利用内核epo模型，它是非阻塞IO方式，利用这种方式能够快速增大请求并发，Lua是一个轻量级脚本语言实现，功能单一，而且高并发这种接口我们选择Nginx+Lua开发十分常见，比如说我们前端需要统计用户IP地址信息，需要统计每个用户的访问次数，需要做对应安全的功能，都可以用Nginx+Lua来实现。 </p><h3 id="Lua的基本语法"><a href="#Lua的基本语法" class="headerlink" title="Lua的基本语法"></a>Lua的基本语法</h3><p>首先需要确保系统上面有lua的解释器</p><pre><code class="hljs bash">~&gt; yum install lua</code></pre><p>它的注释分为2种</p><ul><li>行注释：–</li><li>块注释：–[[  代码块  ]]</li></ul><p>对于变量的话它支持：</p><ul><li>a=’alo\n123”’</li><li>a=”alo\n123&quot;“</li><li>a=‘\97lo\10\04923”’</li><li>a= [[alo123”]]</li></ul><p>对于布尔类型只有nil和false是false，数字0啊，‘’空字符串(‘\0’)都是true</p><p>lua中的变量如果没有特殊说明，全是全局变量</p><p>语句介绍</p><p>while</p><pre><code class="hljs lua">sum = <span class="hljs-number">0</span>num = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> num &lt;= <span class="hljs-number">100</span> <span class="hljs-keyword">do</span>    sum = sum + num    num = num + <span class="hljs-number">1</span><span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(<span class="hljs-string">"sum="</span>, sum)</code></pre><p>for</p><pre><code class="hljs lua">sum = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, <span class="hljs-number">100</span> <span class="hljs-keyword">do</span>    sum = sum + i<span class="hljs-keyword">end</span><span class="hljs-built_in">print</span>(sum)</code></pre><p>if-else</p><pre><code class="hljs lua"><span class="hljs-keyword">if</span> age == <span class="hljs-number">40</span> <span class="hljs-keyword">and</span> sex == <span class="hljs-string">"Male"</span> <span class="hljs-keyword">then</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"大于40男人"</span>)<span class="hljs-keyword">elseif</span> age &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">and</span> sex ~= <span class="hljs-string">"Female"</span> <span class="hljs-keyword">then</span>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"非女儿而其大于60"</span>)<span class="hljs-keyword">else</span>    <span class="hljs-keyword">local</span> age = <span class="hljs-built_in">io</span>.<span class="hljs-built_in">read</span>()    <span class="hljs-built_in">print</span>(<span class="hljs-string">"你的年龄:"</span> .. age)<span class="hljs-keyword">end</span></code></pre><h2 id="Nginx与Lua的开发环境"><a href="#Nginx与Lua的开发环境" class="headerlink" title="Nginx与Lua的开发环境"></a>Nginx与Lua的开发环境</h2><p>对于Nginx而言，Nginx默认是不知道Lua扩展模块的</p><ul><li>LuaJIT：跟Lua一样是一个解释器，只是它比Lua跟高效些</li><li>ngx_devel_kit和lua-nginx-module</li><li>重新 编译Nginx</li></ul><p>扩展模块步骤：</p><blockquote><p>这里博主没有搭建成功，这里博主不再使用官网提供的Nginx，而是参考<a href="https://openresty.org/cn/" target="_blank" rel="noopener">官网</a>搭建的，它这里的Nginx默认支持Lua</p></blockquote><h2 id="Nginx调用Lua的指令及Nginx的Luaaip接口"><a href="#Nginx调用Lua的指令及Nginx的Luaaip接口" class="headerlink" title="Nginx调用Lua的指令及Nginx的Luaaip接口"></a>Nginx调用Lua的指令及Nginx的Luaaip接口</h2><p>对于一个请求过来，首先是通过Nginx服务，Nginx服务再来调用对应的Lua指令，这个章节来说下有哪些常见得调用Lua指令。</p><p>Nginx的可插拔模块坏加载执行，共11个处理阶段，在每个阶段都可以调用Lua的指令，对于能调用的指令如下：</p><table><thead><tr><th>指令</th><th>介绍</th></tr></thead><tbody><tr><td>set_by_lua<br />set_by_lua_file</td><td>设置Nginx变量，可以实现复杂的赋值逻辑</td></tr><tr><td>access_by_lua<br />access_by_lua_file</td><td>请求访问阶段处理，用于访问控制</td></tr><tr><td>content_by_lua<br />content_by_lua_file</td><td>内容处理器，接受请求处理并输出响应</td></tr></tbody></table><p>Lua在交互过程中也需要去调用Lua指令，通过Nginx的Lua API：</p><table><thead><tr><th>api</th><th>介绍</th></tr></thead><tbody><tr><td>ngx.var</td><td>nginx变量</td></tr><tr><td>ngx.req.get_hearders</td><td>获取请求头</td></tr><tr><td>ngx.req.get_uri_args</td><td>获取url请求参数</td></tr><tr><td>ngx.redirect</td><td>重定向</td></tr><tr><td>ngx.print</td><td>输出响应内容体</td></tr><tr><td>ngx.say</td><td>通ngx.print，但是会最后输出一个换行符</td></tr><tr><td>ngx.header</td><td>输出响应头</td></tr><tr><td>…</td><td></td></tr></tbody></table><h2 id="实战场景-灰度发布"><a href="#实战场景-灰度发布" class="headerlink" title="实战场景-灰度发布"></a>实战场景-灰度发布</h2><h3 id="什么是灰度发布？"><a href="#什么是灰度发布？" class="headerlink" title="什么是灰度发布？"></a>什么是灰度发布？</h3><p>按照一定的关系区别,分部分的代码进行上线，使代码的发布能平滑过渡上线，所以灰度发布就是让部分、少量的用户能够先体验到，这样不至于影响整体，所以按照什么关系来进行灰度发布是很重要的。</p><h3 id="灰度发布方式"><a href="#灰度发布方式" class="headerlink" title="灰度发布方式"></a>灰度发布方式</h3><p>1）、用户的信息cookie等信息区别</p><p>指定某一个用户可以访问，其他的用户就访问不同的场景，这个是基于用户不同信息进行对应的区分</p><p>2）、根据用户的ip地址</p><p>获取到对应的ip做区分，但是ip地址颗粒度会跟广一些，因为有很多局域网是共用一个ip</p><p>…</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>这里选择使用ip的方式来实现，这里我会准备2个<code>spring boot</code>打包的<code>jar</code>：</p><p>服务1：8080</p><p>服务2：9090</p><p>它们两分别放一部分代码，对于服务1而言，放的是相关测试的代码，就是我们要准备新更改的一部分代码，服务器2而言放的是老的代码，我们新更改代码在服务1做的更改以后我们只允许部分的IP来进行对应的访问，如果它是匹配的话，它是按照IP地址进行匹配，如果匹配让它访问服务1的<code>spring boot jar</code>。</p><p>对于以上这个逻辑是怎么实现的呢？就是通过Nginx+Lua来实现的，所以Nginx和Lua需要存储用户IP的关系，它需要去调用一个列表，然后判断这个IP和用户过来的IP是否匹配，如果匹配的话才让它去访问对应新功能的代码，所以这里要存储对应的IP列表的话，可以选择使用<code>Memcache</code>，这里通过Lua去调用<code>Memcache</code>去取IP列表，看用户的IP是否是<code>Memcache</code>所存的列表里面，如果已存在就让这个用户就访问服务器1，如果不匹配就让这个用户去访问服务2。</p><h3 id="实现具体步骤"><a href="#实现具体步骤" class="headerlink" title="实现具体步骤"></a>实现具体步骤</h3><p>在开始之前来介绍一下服务1和服务2的区别，</p><p>服务器1：</p><pre><code class="hljs bash">~&gt; curl localhost:8080/demo1~&gt; curl localhost:8080/demo/v22~&gt; curl localhost:80808080</code></pre><p>服务2：</p><pre><code class="hljs bash">~&gt; curl localhost:9090/demo9~&gt; curl localhost:9090/demo/v2&#123;<span class="hljs-string">"timestamp"</span>:<span class="hljs-string">"2020-02-16T12:42:53.563+0000"</span>,<span class="hljs-string">"status"</span>:404,<span class="hljs-string">"error"</span>:<span class="hljs-string">"Not Found"</span>,<span class="hljs-string">"message"</span>:<span class="hljs-string">"No message available"</span>,<span class="hljs-string">"path"</span>:<span class="hljs-string">"/demo/v2"</span>&#125;~&gt; curl localhost:90909090</code></pre><blockquote><p>服务器有中能够正常访问<code>/demo/v2</code>，它这里的代码属于最新的，访问<code>/demo</code>响应的是1，在老的代码中，也就是9090这个端口服务2，访问它这里的<code>/demo</code>响应9，并且在它这里是没有<code>/demo/v2</code>接口的，这个接口是新加上去的</p></blockquote><hr><p>这里我使用redis来存储IP列表，安装的方式可以在我Redis第一章中找到，这里不做太多的介绍。</p><p>首先将本地IP存储到Redis中，值给的是1</p><pre><code class="hljs bash">~&gt; redis-cli <span class="hljs-built_in">set</span> 127.0.0.1 1</code></pre><p>这里是关于Nginx的配置，dep.conf：</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8081</span>;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">location</span> /hello &#123;        <span class="hljs-attribute">default_type</span> <span class="hljs-string">'text/plain'</span>;        <span class="hljs-attribute">content_by_lua</span> <span class="hljs-string">'ngx.say("hello,lua")'</span>;    &#125;    <span class="hljs-attribute">location</span> /myip &#123;        <span class="hljs-attribute">default_type</span> <span class="hljs-string">'text/plain'</span>;        <span class="hljs-attribute">content_by_lua</span> <span class="hljs-string">'</span><span class="hljs-string">        clientIP=ngx.req.get_headers()["Host"];</span><span class="hljs-string">        ngx.say("IP:",clientIP)'</span>;    &#125;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">default_type</span> <span class="hljs-string">'text/html'</span>;        <span class="hljs-attribute">content_by_lua_file</span> /opt/app/lua/dep.lua;        <span class="hljs-comment">#        add_after_body $http_x_forwarded_for;</span>    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-variable">@server</span>&#123;        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:9090;    &#125;    <span class="hljs-attribute">location</span> <span class="hljs-variable">@server_test</span>&#123;        <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;    &#125;&#125;</code></pre><p>这里的<code>/</code>中引入了一个<code>dep.lua</code>文件，它的内容如下：</p><pre><code class="hljs lua">clientIP = ngx.req.get_headers()[<span class="hljs-string">"X-Real-IP"</span>];<span class="hljs-keyword">if</span> clientIP == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>    clientIP = ngx.req.get_headers()[<span class="hljs-string">"http_x_forwarded_for"</span>]<span class="hljs-keyword">end</span><span class="hljs-keyword">if</span> clientIP == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span>    clientIP = ngx.var.remote_addr<span class="hljs-keyword">end</span><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">"resty.redis"</span>);<span class="hljs-comment">--local redis = require "redis"</span><span class="hljs-comment">-- 创建一个redis对象实例。在失败，返回nil和描述错误的字符串的情况下</span><span class="hljs-keyword">local</span> redis_instance = redis:new();<span class="hljs-comment">--设置后续操作的超时（以毫秒为单位）保护，包括connect方法</span>redis_instance:set_timeout(<span class="hljs-number">1000</span>)<span class="hljs-comment">--建立连接</span><span class="hljs-keyword">local</span> ip = <span class="hljs-string">'127.0.0.1'</span><span class="hljs-keyword">local</span> port = <span class="hljs-number">6379</span><span class="hljs-comment">--尝试连接到redis服务器正在侦听的远程主机和端口</span><span class="hljs-keyword">local</span> ok, err = redis_instance:connect(ip, port)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">"connect redis error : "</span>, err)    <span class="hljs-keyword">return</span> close_redis(redis_instance);<span class="hljs-keyword">end</span><span class="hljs-comment">--Redis身份验证</span><span class="hljs-comment">--local auth,err = redis_instance:auth("");</span><span class="hljs-comment">--if not auth then</span><span class="hljs-comment">--    ngx.say("failed to authenticate : ",err)</span><span class="hljs-comment">--end</span><span class="hljs-keyword">local</span> res, <span class="hljs-built_in">error</span> = redis_instance:get(clientIP)<span class="hljs-keyword">if</span> res == <span class="hljs-string">"1"</span> <span class="hljs-keyword">then</span>    ngx.exec(<span class="hljs-string">"@server_test"</span>)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span>ngx.exec(<span class="hljs-string">"@server"</span>)</code></pre><blockquote><p>上面这些代码的逻辑是这样的：</p><ol><li>获取发请求的客户端IP</li><li>通过这个IP在Redis中进行查询</li><li>如果查询到了为1就去执行<code>@server_test</code>,没查询到则去执行<code>@server</code>，这里的<code>@server_test、@server</code>也就是dep.conf中定义的location，它会被执行，这样一来就实现了前面所介绍的场景了</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】 Linux中的常见问题</title>
    <link href="/linux-2.html"/>
    <url>/linux-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP服务端口没有权限"><a href="#HTTP服务端口没有权限" class="headerlink" title="HTTP服务端口没有权限"></a>HTTP服务端口没有权限</h1><p> 系统启动 Nginx 后，报 [emerg] bind () to 0.0.0.0:XXXX failed (13: Permission denied) 错误的处理方式，分为两种：</p><p>第一种：端口小于 1024 的情况：</p><pre><code class="hljs bash">[emerg] <span class="hljs-built_in">bind</span>() to 0.0.0.0:80 failed (13: Permission denied)</code></pre><p>原因是 1024 以下端口启动时需要 root 权限，所以 sudo nginx 即可。</p><p>第二种：端口大于 1024 的情况：</p><pre><code class="hljs bash">[emerg] <span class="hljs-built_in">bind</span>() to 0.0.0.0:8380 failed (13: Permission denied)</code></pre><p>这种情况，需要如下操作：</p><p>首先，查看 http 允许访问的端口：</p><pre><code class="hljs bash">semanage port -l | grep http_port_thttp_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000</code></pre><p>其次，将要启动的端口加入到如上端口列表中</p><pre><code class="hljs bash">semanage port -a -t http_port_t  -p tcp 8090</code></pre><p>如此即可解决如上问题。</p><p>cenos7 安装 semanage 命令参考：<a href="https://blog.csdn.net/RunSnail2018/article/details/81185653" target="_blank" rel="noopener">https://blog.csdn.net/RunSnail2018/article/details/81185653</a></p><h1 id="yum找不到"><a href="#yum找不到" class="headerlink" title="yum找不到"></a>yum找不到</h1><pre><code class="hljs bash">~&gt; sudo yum install epel-release~&gt; yum update</code></pre><h1 id="开机自启shell脚本"><a href="#开机自启shell脚本" class="headerlink" title="开机自启shell脚本"></a>开机自启shell脚本</h1><p>shell脚本中一定要假如的内容：</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#chkconfig: 2345 80 90</span><span class="hljs-comment">#description:auto_run</span>....</code></pre><p>shell脚本需要存放的位置：<code>/etc/rc.d/init.d</code></p><pre><code class="hljs bash">chkconfig  -add nginx_start.shchkconfig  nginx_start.sh  on</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nginx】 3.场景实践篇</title>
    <link href="/nginx-3.html"/>
    <url>/nginx-3.html</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx作为静态资源web服务"><a href="#Nginx作为静态资源web服务" class="headerlink" title="Nginx作为静态资源web服务"></a>Nginx作为静态资源web服务</h1><h2 id="静态资源类型"><a href="#静态资源类型" class="headerlink" title="静态资源类型"></a>静态资源类型</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200127224411585.png" srcset="/img/loading.gif" alt="image-20200127224411585"></p><p> nginx可以作为静态服务，它能接收客户端静态资源的请求，像html、flv、jpg这些都是可以的，它能返回给客户端相应内容。这种方式经常会用在处理请求、动静分离的场景；</p><p><strong>静态资源类型：</strong></p><table><thead><tr><th>类型</th><th>种类</th></tr></thead><tbody><tr><td>浏览器端渲染</td><td>HTML、CSS、JS</td></tr><tr><td>图片</td><td>JPEG、GIF、PNG</td></tr><tr><td>视频</td><td>FLV、MPEG</td></tr><tr><td>文件</td><td>TXT、等任意下载文件</td></tr></tbody></table><h2 id="CDN场景"><a href="#CDN场景" class="headerlink" title="CDN场景"></a>CDN场景</h2><p>CDN：内容分发网络，这里的网络是内容分发的逻辑性网络。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200127225519660.png" srcset="/img/loading.gif" alt="image-20200127225519660"></p><p><strong>什么是CDN？</strong><br>北京的一个用户想要请求一个文件，这个文件放在新疆的机器上，新疆离北京的距离是非常远的，那么想获取这个文件就需要一定时间了；怎么办？假设这个存储中心在新疆，这里就用到CDN分发网路技术，把那个请求的文件进行分发，发送给不同的地区机器，每个不同地区机器装一个代理，北京用户来说，通过智能DNS技术把它的请求动态定位到背景的代理上进行请求，这样就不用请求之前新疆的节点了，这个地方对于用户来说就节省了很多的时间，对于CDN技术来说我们要求的是这个传输 延时的最小化。静态资源适用于这种场景，所以nginx作为每一个节点，资源存储中心节点以及代理前端节点起了一个非常承上启下的web server作用</p><h2 id="配置语法"><a href="#配置语法" class="headerlink" title="配置语法"></a>配置语法</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p>Syntax：sendfile on | off;<br>Default：sendfile off;<br>Context：http，server，location，if in location</p><blockquote><p>引读：——with-file-aio异步文件读取</p></blockquote><h3 id="tcp-nopush"><a href="#tcp-nopush" class="headerlink" title="tcp_nopush"></a>tcp_nopush</h3><p>Syntax：tcp_nopush on | off;<br>Default：tcp_nopush off;<br>Context：http，server，location</p><blockquote><p>作用: sendfile开启的情况下,提高网络包的传输效率。nopush是说不着急把包响应给客户端，举个例子：我们要去发送一个包裹，如果有10个包裹我们一天发一个，这样的话可能要10次快递员来进行发送，这里可以换一种方式，把10个包裹整理的放到一天，一次性给它发送出去，叫一个快递员一次性来接，这样的话对网络传输来说就非常高效了，所以这个<code>tcp_no_push</code>把多个包进行一个整合一次性发送出去给客户端，这个对于大文件是推荐的</p></blockquote><h3 id="tcp-nodelay"><a href="#tcp-nodelay" class="headerlink" title="tcp_nodelay"></a>tcp_nodelay</h3><p>Syntax：tcp_nodelay on | off;<br>Default：tcp_nodelay on;<br>Context：http，server，location</p><blockquote><p>作用：keepalive连接下，提高网络包的传输实时性。这个与上面<code>tcp_nopush</code>相反，数据包尽量不要等待直接发送给客户端，它用于实时性要求高的场景。这里有一个要求：传输的连接必须在keepalive长连接的模式下才能够生效</p></blockquote><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><strong>压缩文件</strong></p><p>Syntax：gzip on | off;<br>Default：gzip  off;<br>Context：http，server，location，if in location</p><blockquote><p>作用：压缩传输。对于文件的压缩是非常重要的，因为我们要减小传输的时间，一个大的包如果要经过传输比例达到百分之30以上的压缩比例的话，我们的资源带宽和传输实时性是非常好的，所以我们要对Nginx进行自带资源里面来，这种请求和响应的时候经量要到它的压缩的方式来减少不必要的网络资源消耗</p></blockquote><p><strong>压缩比</strong></p><p>Syntax：gzip_comp_level level;<br>Default：gzip_comp_level 1;<br>Context：http，server，location</p><blockquote><p>对一个文件进行压缩，如果压缩的越高的话，那么它的文件就能压缩的比率更大，所以文件也就压缩的更小那么传输的文件也就更小，这样的话好处是压缩减少的越多但是也会带来一些问题，比如：我压缩本身就要耗服务端的性能，所以在这个地方的选择上面我们需要根据自己实际情况来选择它压缩的级别</p></blockquote><p> <strong>控制http协议版本</strong></p><p>Syntax：gzip_http_version1.01.1;<br>Default：gzip_http_version1.1;<br>Context：http，server，location</p><p><strong>扩展Nginx压缩模块</strong></p><p>http_gzip_static_module：预读gzip功能</p><blockquote><p>比方说，客户端访问<code>1.html</code>文件，它会在它的家目录里面先去找<code>1.html.gz</code>文件看是否存在，因为<code>1.html.gz</code>是gzip的预压缩文件，如果有的话先把<code>1.html.gz</code>文件返回给客户端，所以它去磁盘中找同名的gz文件是否存在，这样能节省压缩时间，但是它对硬盘有要求，因为它要预先压缩好</p></blockquote><p>http_gunzip_module：应用支持gunzip的压缩方式</p><blockquote><p>这个模块用得很少，它是为了解决很少一部分浏览器里面无法支持gzip，如果遇见部分浏览器无法用到gzip压缩的话就可以使用它来解决</p></blockquote><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="1-图片压缩"><a href="#1-图片压缩" class="headerlink" title="(1)图片压缩"></a>(1)图片压缩</h3><p>在/opt/app/code/images目录中准备了一张图片</p><pre><code class="hljs bash">/opt/app/code/images&gt; lsbg.png</code></pre><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(jpg|gif|png)$</span> &#123;                <span class="hljs-comment">#gzip on;</span>                <span class="hljs-attribute">gzip_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;                <span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">2</span>;                <span class="hljs-attribute">gzip_types</span> text/plain application/javascript applicaiton/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;                <span class="hljs-attribute">root</span> /opt/app/code/images;        &#125;</code></pre><p>没开启gzip的图片的响应头</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200128135354132.png" srcset="/img/loading.gif" alt="image-20200128135354132"></p><p>开启之后</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200128135631040.png" srcset="/img/loading.gif" alt="image-20200128135631040"></p><h3 id="2-文件压缩"><a href="#2-文件压缩" class="headerlink" title="(2)文件压缩"></a>(2)文件压缩</h3><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(txt|xml)$</span> &#123;                <span class="hljs-comment">#gzip on;                               </span>               <span class="hljs-attribute">gzip_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;                <span class="hljs-attribute">gzip_comp_level</span> <span class="hljs-number">1</span>;                <span class="hljs-attribute">gzip_types</span> text/plain application/javascript applicaiton/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;                <span class="hljs-attribute">root</span> /opt/app/code/doc;&#125;</code></pre><p>未使用gzip的文件大小</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200128140435370.png" srcset="/img/loading.gif" alt="image-20200128140435370"></p><p>使用gzip的文件大小</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200128140501065.png" srcset="/img/loading.gif" alt="image-20200128140501065"></p><h3 id="3-预压缩"><a href="#3-预压缩" class="headerlink" title="(3)预压缩"></a>(3)预压缩</h3><pre><code class="hljs bash">/opt/app/code/download&gt; lsbg.png/opt/app/code/download&gt; gzip bg.png/opt/app/code/download&gt; lsbg.png.gz</code></pre><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/download</span>&#123;                <span class="hljs-comment">#gzip_static on;</span>                <span class="hljs-attribute">tcp_nopush</span> <span class="hljs-literal">on</span>;                <span class="hljs-attribute">root</span> /opt/app/code;&#125;</code></pre><ul><li>没有开启gzip_static：访问<code>/download/bg.png</code>会报404错误</li><li>开启gzip_static：能正常访问</li></ul><h2 id="跨站访问"><a href="#跨站访问" class="headerlink" title="跨站访问"></a>跨站访问</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>跨站访问是什么？</p><p>浏览器会禁止网站进行跨站访问，例如：</p><p><a href="http://www.a.com这个网站通过像`AJAX`技术访问http://www.b.com，这样就是所谓的跨站访问，对于浏览器来说是禁止的。" target="_blank" rel="noopener">http://www.a.com这个网站通过像`AJAX`技术访问http://www.b.com，这样就是所谓的跨站访问，对于浏览器来说是禁止的。</a></p><hr><p><strong>为什么浏览器禁止跨域访问？</strong></p><ul><li>(1)不安全，容易出现CSRF攻击！</li></ul><p>跨站攻击形成原理：</p><p>​    一般一个用户去访问一个正规的网站A，网站A会返回对应的cookie信息，cookie信息存放在客户端，当这个用户不小心点到了非法网站，这个时候非法网站就可以给客户端发送一些response带有恶意请求让用户去请求网站A，这样就形成了跨站访问，所以这种跨站访问浏览器进行封闭，为什么阻止了为什么这里还要 学 Nginx跨站访问呢？</p><p>──安全归安全，一些企业的情况、一些历史原因、开发设计、网站设计、业务的形态，往往会需要对一些资源打开跨站，因为有的时候不一定只需要一个域名，有的时候需要用到多个域名，这个时候就需要使用Nginx打开访问设置。</p><p><strong>浏览器设置和Nginx服务端有什么关系？</strong></p><p>浏览器端是指它会判断一个头信息：response的头中有没有<code>Access-Control-Allow-Origin</code>，如果服务端允许跨站访问，那么浏览器端就不会去限制。</p><p><strong>Nginx配置</strong></p><p>Syntax：add_header name value [always];<br>Default：——<br>Context：http，server，location，if in location</p><blockquote><ul><li>name：头的名字。我们要打开跨站的话就是<code>Access-Control-Allow-Origin</code></li><li>value：对应哪一些站点允许对应的值来进行访问，允许全部站点：*</li></ul></blockquote><h3 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h3><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(htm|html)$</span> &#123; <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *; <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS; <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization'</span>;  <span class="hljs-attribute">root</span> /opt/app/code/doc;&#125;</code></pre><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>1）、目的</p><p>防止资源被盗用；</p><p>例如：</p><ul><li>在一些正常服务下面我们希望是一些合法的用户来访问我们网站，我不希望竞争对手来爬取网站的资源，然后把我的资源都放到竞争对手去了</li><li>大部分没用的用户来请求我的网站，是必对我网站的性能对应请求造成了额外的损耗</li></ul><p>防盗链就能解决以上问题。防盗链的机制有很多种，这是一门非常高的技术要求，简单的防盗链技术，Nginx都支持，这个章节就简单的实现</p><hr><p>2）、防盗链设置思路</p><p>首要方式：区别哪些请求是非常正常的用户请求。对于那些不正常的用户进行阻止不让它来访问，对于正常的用户保证一定能请求到不能作为非正常用户处理</p><hr><p>3）、基于http_refer防盗链配置模块</p><p>Syntax:    valid_referers none | blocked | server_names | string …;<br>Default:    —<br>Context:    server, location</p><hr><p>4）、什么是http_refer？</p><p>在nginx.conf中就有使用过它</p><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">log_format</span>  main   <span class="hljs-string">'<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] "<span class="hljs-variable">$request</span>" '</span>                      <span class="hljs-string">'<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> "<span class="hljs-variable">$http_referer</span>" '</span>                      <span class="hljs-string">'"<span class="hljs-variable">$http_user_agent</span>" "<span class="hljs-variable">$http_x_forwarded_for</span>"'</span>;                       ....                     &#125;</code></pre><p>举个例子</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"http://dev001.com/test.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"test"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>这个html加载了一个图片，这个图片则是通过Nginx代理的，配置如下</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ \.(jpg|gif|png)$</span> &#123;                <span class="hljs-attribute">root</span> /opt/app/code/images;&#125;</code></pre><p>将这个页面也用nginx代理</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> = /test.html&#123;              <span class="hljs-attribute">root</span> /opt/app/code;&#125;</code></pre><p>在浏览器中访问/test.html,日志输出为：</p><pre><code class="hljs bash">~&gt; tail -f  /var/<span class="hljs-built_in">log</span>/nginx/access.log192.168.202.1 - - [03/Feb/2020:18:20:21 +0800] <span class="hljs-string">"GET /test.html HTTP/1.1"</span> 200 181 <span class="hljs-string">"-"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"</span> <span class="hljs-string">"-"</span>192.168.202.1 - - [03/Feb/2020:18:20:21 +0800] <span class="hljs-string">"GET /test.png HTTP/1.1"</span> 200 11164706 <span class="hljs-string">"http://dev001.com/test.html"</span> <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36"</span> <span class="hljs-string">"-"</span></code></pre><p>这里可以看到第一次请求的：test.html,可以看到这里的”-“ 是一个空信息。</p><p>第二个请求的是图片，它这里不是”-“ 而是”<a href="http://dev001.com/test.html&quot;。这个就是对应前面说的日志输出中用到的`http_referer`，它来记录上一次的请求。" target="_blank" rel="noopener">http://dev001.com/test.html&quot;。这个就是对应前面说的日志输出中用到的`http_referer`，它来记录上一次的请求。</a></p><hr><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>通过以上介绍知道了<code>http_referer</code>以后，来说下 对于场景防盗链的限制，我们限制防盗链是为了防止我们的网站被一些动态资源比如图片、视频、文件资源，被别的网站使用，那么我们这里就可以拿上面说的<code>http_referer</code>信息来判断是否是我们网站，不是我们网站的话我们就应该给它阻止掉。</p><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ .*\.(jpg|gif|png)$</span> &#123;                <span class="hljs-attribute">valid_referers</span> <span class="hljs-literal">none</span> <span class="hljs-literal">blocked</span> <span class="hljs-number">192.168.202.151</span>;                <span class="hljs-attribute">if</span> (<span class="hljs-variable">$invalid_referer</span>)&#123;                        <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;                &#125;                <span class="hljs-attribute">root</span> /opt/app/code/images;&#125;</code></pre><blockquote><p>valid_referers：允许一些referer信息访问</p><p>none：允许没有带referer</p><p>blocked：referer信息不是标准的http这种方式，允许一些没有协议信息的这种过来的请求</p><p>192.168.202.151：只允许通过这个IP来访问</p></blockquote><p>在浏览器中访问<a href="http://dev001.com/test.html的结果：" target="_blank" rel="noopener">http://dev001.com/test.html的结果：</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200205110046152.png" srcset="/img/loading.gif" alt="image-20200205110046152"></p><p>在浏览器中访问<a href="http://192.168.202.151/test.html的结果" target="_blank" rel="noopener">http://192.168.202.151/test.html的结果</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200205110124230.png" srcset="/img/loading.gif" alt="image-20200205110124230"></p><h1 id="Nginx作为代理服务"><a href="#Nginx作为代理服务" class="headerlink" title="Nginx作为代理服务"></a>Nginx作为代理服务</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>1）什么是代理？</p><p>办一些事情无法直接去和对应的人员去联系，这个时候就需要一个第三方的代理服务或者人员来帮我们实现，代理在我们日常生活中必不可少。比如说我们有很多的钱，我们需要去谈金融这一块，往往会找一个第三方的代理公司来代理理财；代理收货，比如说我们在淘宝上买了很多东西，我们不在家的时候，快递员会把物品放到驿站、收货柜里面，等我们回来再去取，这样就是代理收货。</p><hr><p>2）代理应用在互联网</p><p>在互联网的请求里面也是一样的道理，客户端无法向服务端直接发起请求的时候它就需要用到代理，代理就实现了客户端和服务端之间的一个通信，客户端首先会请求代理， 代理会把请求给服务端，服务端再通过代理返回。</p><hr><p>3）Nginx实现代理服务</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200205130951441.png" srcset="/img/loading.gif" alt="image-20200205130951441"></p><p>Nginx来实现代理服务就可以实现很多协议的代理例如图中的：</p><ul><li>HTTP</li><li>ICMP\POP\IMAP：邮件收发、收发信协议</li><li>HTTPS：HTTP加密</li><li>PTMP：流媒体常用格式</li></ul><hr><p>4）正向代理</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200205132746368.png" srcset="/img/loading.gif" alt="image-20200205132746368"></p><p> 客户端请求代理服务，代理服务请求服务端。正向代理会用到哪些场景？比如一个公司所有电脑没法上网，但是只有一台机器可以上网的时候我们往往会在浏览器里面需要配置一个代理的地址，通过这台代理的服务器去向公网，这个是早期公司里面经常会这么去做，另外一个常见的是翻墙了，去通过国外的代理去搜索想要看的网站或者信息等等。Nginx就可以作为正向代理服务。</p><hr><p>5）反向代理</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200205132805413.png" srcset="/img/loading.gif" alt="image-20200205132805413"></p><p>客户端往往去请求网站的时候，那么你不知道它后端有多少个服务器，那么请求的往往是一个代理，这个代理会发给对应的服务器，这个服务器再返回给客户端</p><hr><p>6）代理区别</p><p>正向代理和反向代理的区别：</p><ol><li>区别在于代理的对象不一样；</li><li>正想代理代理的对象是客户端：比如说我们想去返回Google，我们要把代理服务器设到代理服务器地址，之后就能访问了，说白正向代理是为客户端服务的；</li><li>反向代理代理的对象是服务端：是为服务端，我们不需要关心服务端是哪个服务器，我们要请求的具体是哪个服务器；反向代理就放在服务端，它会去帮我们去处理请求。</li></ol><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="配置语法-1"><a href="#配置语法-1" class="headerlink" title="配置语法"></a>配置语法</h3><p>Syntax:    proxy_pass URL;<br>Default:    —<br>Context:    location, if in location,limit_except</p><p><a href="http://www.nginx.cn/doc/standard/httpproxy.html" target="_blank" rel="noopener">文档地址</a></p><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;                <span class="hljs-attribute">proxy_pass</span> https://www.baidu.com;&#125;</code></pre><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;      <span class="hljs-attribute">resolver</span> <span class="hljs-number">192.168.1.1</span>; <span class="hljs-comment">#指定DNS服务器IP地址  </span>    <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;      <span class="hljs-attribute">location</span> / &#123;          <span class="hljs-attribute">proxy_pass</span> http://<span class="hljs-variable">$http_host</span><span class="hljs-variable">$request_uri</span>; <span class="hljs-comment">#设定代理服务器的协议和地址  </span>    &#125;  &#125;</code></pre><h2 id="配置语法补充"><a href="#配置语法补充" class="headerlink" title="配置语法补充"></a>配置语法补充</h2><p>代理模块中提供了很多的配置项，详情请参考<a href="http://www.nginx.cn/doc/standard/httpproxy.html" target="_blank" rel="noopener">文档</a></p><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>Syntax:    proxy_buffering on | off;<br>Default:<br>proxy_buffering on;<br>Context:    http, server, location</p><blockquote><p>Nginx服务中去转发请求的时候，往往会接受到一部分的是头信息，Nginx如果把以上配置项打开，那么它将尽可能的把所有请求的信息收集完，然后再返回给客户端，这个起到了一个缓冲区的概念，它减少IO损耗，但是这样也有一些问题的，例如：这个打开的话默认是存在内存里面的，当内存不够的情况下它可能会存在硬盘的临时目录中，这里<code>proxy_buffer_size、proxy_buffers、proxy_busy_buffers_size</code>参数是用来控制的。</p></blockquote><h3 id="跳转重定向"><a href="#跳转重定向" class="headerlink" title="跳转重定向"></a>跳转重定向</h3><p>Syntax:    proxy_redirect default;<br>proxy_redirect off;<br>proxy_redirect redirect replacement;<br>Default:    proxy_redirect default;<br>Context:    http, server, location</p><blockquote><p>当我们用Nginx作为代理服务器去代理后端服务返回是一个301的重定向地址的时候，这里的 http 301是一个重定向，它会把我们请求重定向到另外的地址里面返回给客户端，所以如果是这种场景下面用一到这个配置项起到一个什么作用呢？当后端返回这个301地址是我们前端所无法访问到的或者是说需要用到Nginx来把服务端返回给客户端301这个地址需要做重写的时候，我们就用到了这个配置项，一般情况下我们只要把它配置成默认的就可以不会有太大的问题，但是在一些特殊场景里面也会去使用它。</p></blockquote><h3 id="头信息"><a href="#头信息" class="headerlink" title="头信息"></a>头信息</h3><p>Syntax:    proxy_set_header field value;<br>Default:    proxy_set_header Host $proxy_host;<br>proxy_set_header Connection close;<br>Context:    http, server, location</p><blockquote><p>头信息配置用的比较多，常见是在把Nginx作为代理服务器但是后端是需要读取一些头信息，这些头信息是不准确的，在Nginx作为访问控制里面它的remote address这个信息就在后端的服务器里面因为走了代理，所以后端就没法读取对应的消息了。这里可以使用<code>proxy_set_header</code>，这上面的配置意思是说发给后端服务器里面会增加一个对应的头，把对应的信息用新的头携带到后端让后端能读取到。</p><p>扩展：</p><ul><li>proxy_hide_header：隐藏头不给后端访问到，应用在一些需要信息隐藏安全性的考虑；</li><li>proxy_set_body：在body中填加字符串</li></ul></blockquote><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>Syntax:    proxy_cookie_domain off;<br>proxy_cookie_domain domain replacement;<br>Default:    proxy_cookie_domain off;<br>Context:    http, server, location</p><blockquote><p>TCP请求的连接超时。当TCP请求连接超时，当建立完连接以后就有另外的超时：</p><ul><li>prxy_read_timeout：已经建立后连接的时候，在Nginx在为代理和后端的服务让它会等待多长时间，如果超过这个时间就认为是超时的</li><li>proxy_send_time：服务端请求完了再发送给客户端发送给客户端的超时时间</li></ul></blockquote><h2 id="配置规范"><a href="#配置规范" class="headerlink" title="配置规范"></a>配置规范</h2><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;                <span class="hljs-attribute">proxy_pass</span>  http://mcr.free.idcfengye.com;                <span class="hljs-attribute">proxy_redirect</span> default;                <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;                <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;                  <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">30</span>;                <span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">60</span>;                <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">60</span>;                <span class="hljs-attribute">proxy_buffer_size</span> <span class="hljs-number">32k</span>;                <span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">on</span>;                <span class="hljs-attribute">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">128k</span>;                <span class="hljs-attribute">proxy_busy_buffers_size</span> <span class="hljs-number">256k</span>;                <span class="hljs-attribute">proxy_max_temp_file_size</span> <span class="hljs-number">256k</span>;        &#125;</code></pre><ul><li>proxy_redirect：通常使用默认的。在后端返回301信息的时候，我们需要做对应的改写的时候需要用到它来对后端返回的信息做调试；</li><li>proxy_set_header：把Nginx代理往后端服务的发送请求的时候添加的头信息，一般会加上<code>Host</code>和<code>X-Real-IP</code>，这里添加X-Real-IP的意义：后端通过代理的方式是无法获取真实的用户IP的，往往做用户访问限制、IP的一些功能定位就需要获取用户的IP信息，这里就需要使用它了；</li><li>proxy_connect_timeout：TCP超时时间；</li><li>proxy_buffer_size：Nginx作为缓冲区的读取头信息的大小，一般不会特别大；</li><li>proxy_buffering：打开，这个时候Nginx会尽可能的去缓冲区里面等待读取后端响应的信息响应给前端，这样做的好处是能减少服务器的IO；</li><li>proxy_buffers：上面这个配置打开了，就要设置对应的大小，因为buffer是放在内存里面的；</li><li>proxy_max_temp_file_size：<code>proxy_buffers</code>和<code>proxy_max_temp_file_size</code>用得差不多的时候，就会存在临时文件里面去，这里是给临时文件限制的大小</li></ul><hr><p>以上的配置项特别的多，在企业中会经常使用它，这里可以将它放在一个通用的文件里面</p><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;                <span class="hljs-attribute">proxy_pass</span>  http://mcr.free.idcfengye.com;  <span class="hljs-attribute">include</span>proxy_params;&#125;</code></pre><p>在/etc/nginx中创建一个<code>proxy_params</code>文件，内容：</p><pre><code class="hljs nginx"><span class="hljs-attribute">proxy_redirect</span> default;<span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">30</span>;<span class="hljs-attribute">proxy_send_timeout</span> <span class="hljs-number">60</span>;<span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">60</span>;<span class="hljs-attribute">proxy_buffer_size</span> <span class="hljs-number">32k</span>;<span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">on</span>;<span class="hljs-attribute">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-number">128k</span>;<span class="hljs-attribute">proxy_busy_buffers_size</span> <span class="hljs-number">256k</span>;<span class="hljs-attribute">proxy_max_temp_file_size</span> <span class="hljs-number">256k</span>;</code></pre><h1 id="Nginx作为负载均衡服务"><a href="#Nginx作为负载均衡服务" class="headerlink" title="Nginx作为负载均衡服务"></a>Nginx作为负载均衡服务</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><p>1）为什么需要负载均衡服务</p><p>再原始的部署模型往往选择最简单的部署模型：点对点服务，随着企业的业务增长以及客户带来的海量请求，给我们服务端造成了海量的并发导致服务响应不能及时，这个时候我们需要不断扩容我们的后端服务，扩容后端服务对于我们前端就需要有一个负载均衡来均分请求来提升后端吞吐量，对于请求而言，负载均衡就能很好的均摊请求。</p><p>对于一个点的服务，如果服务挂掉了那么整体服务就挂掉了，但是有了负载均衡服务我们即使一个点挂了其他的点还可以正常使用，这里挂掉的点把它剔除就可以了，这样的部署方式可以让后端服务很好的实现高可用。</p><hr><p>2）GSLB</p><p>说到负载均衡这里按照范围分为一个类：GSLB与SLB</p><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200209165634931.png" srcset="/img/loading.gif" alt="image-20200209165634931"></p><p>GSLB是按照影响范围来定的，GSLB是一个全局负载均衡，它的节点比较庞大，地域范围非常广，往往按照国家、省为单位来进行全局负载均衡。举个例子：比如张三这个用户在北京，它不可能都去请求<code>应用服务中心节点</code>，它先去请求调度节点，调度节点返回给张三对应的地址，张三请求对应的应用服务，这里的应用服务也就集中在北京，所以这是一个边缘的应用服务节点，而没有去请求这个<code>应用服务中心节点</code>，这样的话张三既满足了访问请求也没有给服务端造成了很大的压力。</p><p>另外一个新疆的用户也是同样的道理，它只访问对应的应用服务，通过调度的节点来实现整体的负载均衡，调度节点又会有整体的调度节点进行控制，所以全局的负载均衡有了这2套中心的节点，加上边缘的调度节点和应用服务节点就能完成一个<code>GSLB全局负载均衡</code>的实现</p><hr><p>3）SLB</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200209171100105.png" srcset="/img/loading.gif" alt="image-20200209171100105"></p><p>往往接触最多的是<code>SLB</code>，SLB在地域里面区分或者逻辑单元区分它是非常小的，往往这个调度节点和它的服务节点在一个逻辑单元里面或者是说在一个地域里面，那么它的小的逻辑地域决定它对部分服务的实时性、响应性是非常好的；在海量用户的请求过来以后它同样是请求调度节点，调度节点把它的请求转发给后端对应的服务节点，服务节点再转发给调度节点，调度节点再响应给客户，这样也能实现一个均衡的作用，Nginx就是一个典型的<code>SLB</code></p><p>4）分为四层负载均衡和七层负载均衡</p><p>往往企业也不好用到<code>GSLB</code>而会用到一些云服务或者第三方设备，但是对于<code>SLB</code> 来说我们会需要用到。</p><p>对于负载均衡除了地域划分以外还可以按照网络的模型也就是<code>OSI</code>模型可以分为常用的2个概念负载均衡，一个是我们常见的4层负载均衡，所谓4层负载均衡就是在<code>OSI</code>模型里面的传输层，传输层已经能支持到TCP IP协议的控制的，所以它只需要对客户端的请求TCP IP协议的包转发，就可以实现负载均衡，它的好处是性能非常快只需要最顶层进行运用处理，而不需要进行一些复杂的逻辑，只需要进行包的转发就可以了。</p><p>对应的就是7层负载均衡，它是在应用层，所以它可以完成应用方面的协议的请求，比如说http的负载均衡它可以实现http信息的改写、头信息的改写、安全应用规则的控制以及转发Layer等规则， 所以在应用层的服务里面我们可以在里面做的内容就更多。Nginx就是一个典型的7层负载均衡的SLB</p><hr><p>5）Nginx负载均衡</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/asdfzxc-1581257182079.png" srcset="/img/loading.gif" alt="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/asdfzxc.png"></p><p>Nginx在实现负载均衡原理就是用到了<code>proxy_pass</code>，proxy_pass就是上一章讲过的代理模块的和核心配置，它把所有请求代理转发到对应后端服务器上，只这里实现负载均衡是它不是转发到一台而是一组虚拟的服务池，它称为<code>upstream server</code>，<code>upstream server</code>可以定义它所有的服务器的单元，比如这个<code>upstream server</code>组里面有服务1、2、3，它们3个都可以提供类似的服务，所以我们将它们放到一个虚拟的<code>upstream server</code>组里面来，在这个<code>upstream server</code>组里面它实现了对于3台服务器不断的轮询，这样所有用户过来请求的时候就会通过<code>upstream</code>模块分发到不同的服务上实现负载均衡这样的一个概念，所以在proxy_pass和upstream是2个核心的配置语法</p><hr><p>6）配置语法</p><p>Syntax: upstream name {…}<br>Default:—<br>Context：http</p><p><a href="https://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">参考文档</a></p><h2 id="演示-负载均衡"><a href="#演示-负载均衡" class="headerlink" title="演示-负载均衡"></a>演示-负载均衡</h2><p>首先通过Nginx准备3个服务，端口分别是：<code>8001、8003、8004</code>，在opt/app目录中对应了<code>code1、code2、code3</code>目录，每个目录都有一个<code>index.html</code>，内容分别是<code>code1、code2、code3</code>；在它们的配置放在<code>/etc/nginx/conf.d</code>目录中</p><pre><code class="hljs bash">/etc/nginx/conf.d &gt; lsserver1.conf  server2.conf  server3.conf</code></pre><p><strong>配置内容：</strong></p><p>server1.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8001</span>;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">root</span>        /opt/app/code1;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">index</span> index.html;    &#125;&#125;</code></pre><p>server2.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8003</span>;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">root</span>        /opt/app/code2;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">index</span> index.html;    &#125;&#125;</code></pre><p>server3.conf</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8004</span>;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">root</span>        /opt/app/code3;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">index</span> index.html;    &#125;&#125;</code></pre><p>upstream_test.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span>;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span> ;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">access_log</span>  /var/log/nginx/test_proxy.access.log  main;    <span class="hljs-attribute">location</span> / &#123;    <span class="hljs-comment">#这里的http://mcr的mcr是上面的upstream的key</span>        <span class="hljs-attribute">proxy_pass</span>  http://mcr;        <span class="hljs-attribute">include</span> proxy_params;    &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode2~&gt; curl  http://localhostcode1~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode1</code></pre><h2 id="介绍-server参数"><a href="#介绍-server参数" class="headerlink" title="介绍-server参数"></a>介绍-server参数</h2><p>前面的负载均衡通到过<code>upstream</code>，它还有一些配置项，在这个章节中说明。</p><p>1）、upstream举例</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">server</span> backend1.example.com weight=<span class="hljs-number">5</span>;    <span class="hljs-attribute">server</span> backend2.example.com:<span class="hljs-number">8080</span>;    <span class="hljs-attribute">server</span> unix:/temp/backend3;    <span class="hljs-attribute">server</span> backend1.example.com:<span class="hljs-number">8080</span> backup;    <span class="hljs-attribute">server</span> backend2.example.com:<span class="hljs-number">8080</span> backup;&#125;</code></pre><ul><li>weight：权重，对于轮询而言加入这个词的值越大那么影响它的权重就越大，分配个它的几率就越高；</li><li>backup：备份服务</li></ul><hr><p>2）、后端服务器在负载均衡调度中的状态</p><table><thead><tr><th>词</th><th>介绍</th></tr></thead><tbody><tr><td>down</td><td>当前的server暂时不参与负载均衡</td></tr><tr><td>backup</td><td>预留的备份服务</td></tr><tr><td>max_fails</td><td>允许请求失败的次数</td></tr><tr><td>fail_timeout</td><td>经过max_fails失败后，服务暂停的时间</td></tr><tr><td>max_conns</td><td>限制最大的接收的连接数</td></tr></tbody></table><h2 id="演示-backup状态"><a href="#演示-backup状态" class="headerlink" title="演示-backup状态"></a>演示-backup状态</h2><p>这里在上一次演示的<code>upstream_test.conf</code>文件中加入这些参数,这里列出了修改部分：</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span> down; <span class="hljs-comment">#不提供服务</span>    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span> backup; <span class="hljs-comment">#备份节点</span>    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span> max_fails=<span class="hljs-number">1</span> fail_timeout=<span class="hljs-number">10s</span>; <span class="hljs-comment">#失败次数：1次，超时时间：10秒</span>&#125;</code></pre><p>这里我们会发现，只请求响应全是<code>code3</code></p><pre><code class="hljs nginx">~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3</code></pre><p>接下来将这个8004端口的服务通过防火墙拦截不对外提供服务</p><pre><code class="hljs bash">~&gt; iptables -I INPUT -p tcp --dport 8004 -j DROP</code></pre><p>这里因为8004端口被拦截掉了，所以再10秒种是请求不到的，这里因为失败次数为1，那么Nginx就认为这个服务挂掉了，它会使用8003这个端口的服务，所有响应内容是：code2</p><pre><code class="hljs bash">~&gt; curl  http://localhostcode2~&gt; curl  http://localhostcode2~&gt; curl  http://localhostcode2~&gt; curl  http://localhostcode2</code></pre><h2 id="介绍-轮询策略"><a href="#介绍-轮询策略" class="headerlink" title="介绍-轮询策略"></a>介绍-轮询策略</h2><p>我们都知道Nginx默认的轮询是基于请求的实现的，比如说我第1个请求是在code1上，第2个请求是在code2上，第3个请求是在code3，我们不断的请求它就不断的轮询，这个小的章节里给大家介绍Nginx轮询策略，因为我们光知道Nginx默认的轮询的规则是完全无法满足实际的配置需求的。</p><p>1）、调度算法</p><table><thead><tr><th>调度名</th><th>介绍</th></tr></thead><tbody><tr><td>轮询</td><td>按时间顺序逐一分配到不同的后端服务器</td></tr><tr><td>加权轮询</td><td>weight值越大，分配到的访问几率越高</td></tr><tr><td>ip_hash</td><td>每个请求按访问IP的hash结果分配，这样来自同哪个一个IP的固定访问一个后端服务器</td></tr><tr><td>url_hash</td><td>按照访问的URL的hash结果来分配请求，是每个URL定向到一个后端服务器</td></tr><tr><td>least_conn</td><td>最少链接数，哪个机器连接数少就分发</td></tr><tr><td>hash关键数值</td><td>hash自定义的key</td></tr></tbody></table><h2 id="演示-加权轮询"><a href="#演示-加权轮询" class="headerlink" title="演示-加权轮询"></a>演示-加权轮询</h2><p>演示之前将前面的防火墙拦截的8004端口放开    </p><pre><code class="hljs bash">~&gt; iptables  -F</code></pre><p>upstream_test.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span> ;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span> weight=<span class="hljs-number">5</span>;&#125;</code></pre><p>下面的测试可以看的响应内容大部分都来自于8004端口的服务</p><pre><code class="hljs bash">~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode1~&gt; curl  http://localhostcode2</code></pre><h2 id="演示-ip-bash方式"><a href="#演示-ip-bash方式" class="headerlink" title="演示-ip_bash方式"></a>演示-ip_bash方式</h2><p><code>加权轮询和轮询</code>的方式都是通过请求来进行分配的，我们如果不想依赖请求想保证对与一些<code>Cookie、Session</code>一致，也就是每一次用户请求如果基于请求来那么可以就会打到不同的服务器上，导致用户登录的<code>Cookie</code>信息验证出现一些问题容易出现掉线，这样的话就需要用另外的方式，不基于请求来做轮询而是基于ip_hash的方式，ip_hash这种方式就能够基于用户的IP来计算它的hash值，然后把每一个固定的IP都打到同一台服务器上去，这样就解决了对于不同的请求然后打到不同的服务器上的问题。</p><p>配置的内容写在<code>upstream_test.conf</code>文件中</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    ip_hash;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span> ;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span>;&#125;</code></pre><p>下面测试中可以看到，它的响应内容都是一样的</p><pre><code class="hljs bash">~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3~&gt; curl  http://localhostcode3</code></pre><p><strong>问题</strong></p><blockquote><p>这里有个问题，不管你是怎么请求，它都是轮询一台服务器上，所以这个是因为ip_hash的策略它会基于客户的<code>remote address</code>来做hash，如果是同一个<code>remote address</code>过来的话它就会定位一台服务器上去，但是这种方式也存在缺陷，如果<code>remote address</code>是走代理方式的话然后前端再走一层代理，那Nginx取到的<code>remote address</code>不是用户真实的IP，这样的话就无法基于用户真实的IP来做对应的轮询，用户过来请求始终会定位一台机器上，所以在这一块的缺陷我们在后续的版本里面就出来了新的方式基于url的hash</p></blockquote><h2 id="url-hash和hash的方式"><a href="#url-hash和hash的方式" class="headerlink" title="url_hash和hash的方式"></a>url_hash和hash的方式</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>在前面介绍的轮询中无论是轮询、加权轮询还是ip_hash方式它们都无法解决一些问题，比如说我想要固定的IP请求固定的内容让固定的IP按照IP来分配。</p><p>另外一个问题：我们在缓存的场景里面服务器1缓存了一部分资源，服务器2缓存了一部分资源，当一个用户来先访问服务器1以后它会先缓存住它缓存的内容，再一次请求的时候假设它跳到了服务器2，这样的话它看到的是另外一部分内容，那么它看到的第1部分内容和第2部分内容是不一致的，想要固定用户每一次过来请求或者是说它请求的内容都能看到是一致的，这个怎么办呢？所以它需要用到另外一些hash的策略。</p><p>在Nginx后续的版本里面就推出来了hash关键数值自定义hash key的方式。</p><hr><h3 id="url-hash配置语法"><a href="#url-hash配置语法" class="headerlink" title="url_hash配置语法"></a>url_hash配置语法</h3><p>Syntax：hash key [consistent];<br>Default：—<br>Context：upstream </p><p>This directive appeared in versoin 1.7.2</p><hr><h3 id="演示url-hash"><a href="#演示url-hash" class="headerlink" title="演示url_hash"></a>演示url_hash</h3><p>准备工作：在<code>/opt/app/code{1-3}</code>中分别创建<code>url{1~3}.html</code></p><p>这些<code>urlx.html</code>的内容为：</p><pre><code class="hljs txt">Server:$&#123;这里是机器的编号&#125;  Url:$&#123;文件的1~3&#125;</code></pre><p>检验是否能正常访问能响应内容就OK了</p><pre><code class="hljs bash">~&gt; curl http://dev001.com/url1.htmlServer:1  Url:1</code></pre><p>upstream_test.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$request_uri</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span> ;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span>;&#125;</code></pre><p>测试不太明显，这里就不测试了</p><hr><h3 id="hash说明"><a href="#hash说明" class="headerlink" title="hash说明"></a>hash说明</h3><p>前面演示了url_hash的方式，但是在实际场景里面这里的url会有很大一长串，不然说这个地址：<a href="http://dev001.com/url1.html?testId=1&amp;userId=23" target="_blank" rel="noopener">http://dev001.com/url1.html?testId=1&amp;userId=23</a>,   这里我想针对URL中的某一个值，例如这个里面的testId的值，这里就用到了hash的轮询方式，首先说下它的一个配置语法：</p><table><thead><tr><th align="left">Syntax:</th><th><code>**hash** *key* [consistent];</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>upstream</code></td></tr></tbody></table><p>注意：This directive appeared in version 1.7.2.</p><p>想实现这个场景，我们需要在服务端加一个判断语句把对应的值用正则表达式提取出来，然后把自定义的进行hash就可以了</p><h1 id="Nginx作为缓存服务"><a href="#Nginx作为缓存服务" class="headerlink" title="Nginx作为缓存服务"></a>Nginx作为缓存服务</h1><h2 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h2><h3 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200211221403716.png" srcset="/img/loading.gif" alt="image-20200211221403716"></p><p>如果缓存放在服务端称呼它为<code>服务端缓存</code> ，服务端缓存最常用的就是<code>Redis、Memcached</code>来存储<code>key-value</code>类型数据。</p><p>当缓存放到代理、中间件上面就称呼为代理缓存，它的内容是同服务端获取到的，然后在缓存到本地直接给客户端使用，这样的话缓存是放在Nginx这一端。</p><p>客户端缓存是缓存再浏览器上面，浏览器上面的缓存是从服务端过来的，只是说给前端缓存了一份，让用户自己就能访问自己，所以我们称呼为客户端缓存。</p><hr><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p>Nginx代理缓存的流程是什么样子的呢？请看下图：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200211221904322.png" srcset="/img/loading.gif" alt="image-20200211221904322"></p><p>首先客户端先去请求Nginx，第一次请求的时候如果Nginx中没有缓存，那么它会向服务器发起请求服务器返回对应的数据，Nginx对服务器返回的这个数据进行缓存，然后再返回给客户端，这是在没有缓存的情况下，当用户再一次发起同一个url的请求的时候，那么请求这个数据a，Nginx已经缓存过这个数据了，所以它就直接可以返回给客户端，而不需要去服务端进行请求了，这个就是代理缓存的模式。</p><h3 id="配置语法-2"><a href="#配置语法-2" class="headerlink" title="配置语法"></a>配置语法</h3><h4 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h4><p>在定义<code>proxy_cache</code>之前先要定义<code>proxy_cache_path</code></p><p>| Syntax:  | <code>**proxy_cache_path** *path* [levels=*levels*] [use_temp_path=on|off] keys_zone=*name*:*size* [inactive=*time*] [max_size=*size*] [manager_files=*number*] [manager_sleep=*time*] [manager_threshold=*time*] [loader_files=*number*] [loader_sleep=*time*] [loader_threshold=*time*] [purger=on|off] [purger_files=*number*] [purger_sleep=*time*] [purger_threshold=*time*];</code> |<br>| :——- | ———————————————————— |<br>| Default: | —                                                            |<br>| Context: | <code>http</code>                                                       |</p><p>它用来设置目录空间大小以及名字，用来存放对应的缓存文件的，所以我们先要定义好对应的路径，这里有很多的配置项，后面介绍一些常用的配置项。</p><p>| Syntax:  | <code>**proxy_cache** *zone* | off;</code> |<br>| :——- | ——————————- |<br>| Default: | <code>proxy_cache off;</code>              |<br>| Context: | <code>http</code>, <code>server</code>, <code>location</code>    |</p><p>这里的<code>zone</code>是<code>proxy_cache_path</code>那个key，表示它调用哪个path</p><h4 id="缓存过期周期"><a href="#缓存过期周期" class="headerlink" title="缓存过期周期"></a>缓存过期周期</h4><table><thead><tr><th align="left">Syntax:</th><th><code>**proxy_cache_valid** [*code* ...] *time*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><h4 id="缓存的维度"><a href="#缓存的维度" class="headerlink" title="### 缓存的维度"></a>### 缓存的维度</h4><table><thead><tr><th align="left">Syntax:</th><th><code>**proxy_cache_key** *string*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>proxy_cache_key $scheme$proxy_host$request_uri;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><h2 id="场景配置演示"><a href="#场景配置演示" class="headerlink" title="场景配置演示"></a>场景配置演示</h2><p>准备工作：</p><p>这里的配置联和上次负载均衡的配置使用的<code>8001、8003、8004</code>端口</p><pre><code class="hljs bash">~&gt; netstat  -anp | grep 800*tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      2179/nginx: master  tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      2179/nginx: master  tcp        0      0 0.0.0.0:8003            0.0.0.0:*               LISTEN      2179/nginx: master  tcp        0      0 0.0.0.0:8004            0.0.0.0:*               LISTEN      2179/nginx: master</code></pre><p> 配置文件：</p><p>cache_test.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">upstream</span> mcr&#123;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8001</span>;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8003</span> ;    <span class="hljs-attribute">server</span> dev001.com:<span class="hljs-number">8004</span>;&#125;<span class="hljs-attribute">proxy_cache_path</span> /opt/app/cache levels=<span class="hljs-number">1</span>:<span class="hljs-number">2</span> keys_zone=mcr_cache:<span class="hljs-number">10m</span> max_size=<span class="hljs-number">10g</span> inactive=<span class="hljs-number">60m</span> use_temp_path=<span class="hljs-literal">off</span>;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span> ;    <span class="hljs-attribute">server_name</span>  localhost;    <span class="hljs-attribute">access_log</span>  /var/log/nginx/test_proxy.access.log  main;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">proxy_cache</span> mcr_cache;        <span class="hljs-attribute">proxy_pass</span>  http://mcr;        <span class="hljs-attribute">proxy_cache_valid</span> <span class="hljs-number">200</span> <span class="hljs-number">304</span> <span class="hljs-number">12h</span>;        <span class="hljs-attribute">proxy_cache_valid</span> any <span class="hljs-number">10m</span>;        <span class="hljs-attribute">proxy_cache_key</span> <span class="hljs-variable">$host</span><span class="hljs-variable">$uri</span><span class="hljs-variable">$is_args</span><span class="hljs-variable">$args</span>;        <span class="hljs-attribute">add_header</span> Nginx-Cache <span class="hljs-variable">$upstream_cache_status</span>;        <span class="hljs-attribute">proxy_next_upstream</span> <span class="hljs-literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;        <span class="hljs-attribute">include</span> proxy_params;    &#125;&#125;</code></pre><p>proxy_cache_path</p><ul><li>levels：我们的这些缓存文件不会总放在一个目录，需要做分级，这里一般都是使用<code>1：2</code>做一个2级目录的分级；</li><li>keys_zone：定义的zone空间的名字，在<code>location</code>中的<code>proxy_cache</code>调用的就是这个名字。后面的<code>10m</code>表示大小，表示开辟空间的这个key的大小，一般<code>1m</code>可以存放8k个key，这里10m=80k</li><li>max_size：这个目录控制它最大是多大。当目录空间用满以后Nginx会触发淘汰规则把一些不常用的淘汰掉</li><li>inactive：表示不活跃的，后面的<code>60m</code>不是兆是时间单位它这里表示60分钟，在60分钟之内如果这个缓存文件没有被访问过就会把它清理掉</li><li>use_temp_path：存放临时文件，一般建议给它关闭，如果你把它打开的话它会另外建立一个目录和cache目录2个目录在更新缓存的时候容易出现性能上的损耗</li></ul><p>location</p><ul><li>proxy_cache：调用上面说的这个zone</li><li>proxy_cache_valid 200 304 12h：表示对于200返回的头信息或者304头信息它是会12个小时过期</li><li>proxy_cache_valid any 10m：除了200、203以外的10分钟过期</li><li><code>proxy_cache_key $host$uri$is_args$args</code>：重新把<code>proxy_cache_key</code>进行了重新定义，把默认改为了以host维度+url+is_args+args对应的参数给它加入进来作为缓存的key</li><li>add_header Nginx-Cache $upstream_cache_status：增加一个头信息，一会在演示的时候能很明显的看出来，返回客户端的response里面会告诉客户端是否命中，通过这个头信息就能清楚的看出来</li><li>proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504：如果当我们的后端其中的一台服务器出现500、502、503、504、不正常的头返回、超时、有错误的时候我们就让它跳过这一台去访问下一台，避免我们因为单台服务器如果是有这个问题对于前端的产生影响，所以这个参数我们在缓存里面给大家一起配上这个参数</li></ul><hr><p>测试：</p><pre><code class="hljs bash">~&gt; curl http://localhostcode1~&gt; curl http://localhostcode1~&gt; curl http://localhostcode1</code></pre><p>这里可以看到它的响应内容一直都是code1，看上去好像没有负载均衡啊，其实这里因为它把这些响应内容缓存起来了，当下一次访问的时候就是直接从缓存中去取</p><pre><code class="hljs bash">/opt/app/cache&gt; rm -rf *~&gt; curl http://localhostcode2</code></pre><p>这里将缓存文件删除掉，响应内容变成为了code2，因为没有缓存，所以是从服务器去取的。</p><p>这里将<code>location</code>中的<code>proxy_cache</code>的值改为<code>off</code>，再去请求来看下没有缓存的情况下：</p><pre><code class="hljs bash">~&gt; curl http://localhostcode1~&gt; curl http://localhostcode2~&gt; curl http://localhostcode3</code></pre><h2 id="场景配置补充说明"><a href="#场景配置补充说明" class="headerlink" title="场景配置补充说明"></a>场景配置补充说明</h2><h3 id="如何清除指定缓存？"><a href="#如何清除指定缓存？" class="headerlink" title="如何清除指定缓存？"></a>如何清除指定缓存？</h3><ul><li>rm -rm 缓存目录内容</li><li>第三方扩展模块<code>ngx_cache_purge</code></li></ul><h3 id="如何让部分页面不缓存？"><a href="#如何让部分页面不缓存？" class="headerlink" title="如何让部分页面不缓存？"></a>如何让部分页面不缓存？</h3><blockquote><p>在一些场景中比如登录页面，或者是用户不能缓存的页面，那么我们是不是需要让部分页面不缓存呢？以下配置就能够实现</p></blockquote><table><thead><tr><th align="left">Syntax:</th><th><code>**proxy_no_cache** *string* ...;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td>—</td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>这个配置能让哪一些url是不会去缓存的。</p><p>这里举个例子，这里根据前面的配置文件<code>cache_test.conf</code>加入以下内容：</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment">#...</span>    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_uri</span> <span class="hljs-regexp">~ ^/(url3|login|register|password\/reset))</span>&#123;        <span class="hljs-attribute">set</span> <span class="hljs-variable">$cookie_nocache</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-comment">#...</span>        <span class="hljs-attribute">proxy_no_cache</span> <span class="hljs-variable">$cookie_nocache</span> <span class="hljs-variable">$arg_nocache</span> <span class="hljs-variable">$arg_comment</span>;        <span class="hljs-attribute">proxy_no_cache</span> <span class="hljs-variable">$http_pragma</span> <span class="hljs-variable">$http_authorization</span>;    &#125;&#125;</code></pre><p>这里的server部分中的if，如果请求是url3，那么这里的cookie_nocache变量的值设为1，在<code>location</code>中的第1个proxy_no_cache就能够生效就不去缓存当前这个url3的请求了</p><pre><code class="hljs bash"><span class="hljs-comment">#被缓存的情况</span>~&gt; curl localhostcode1~&gt; curl localhostcode1~&gt; curl localhost<span class="hljs-comment">#不被缓存的情况</span>~&gt; curl localhost/url3.htmlServer:2  Url:3~&gt; curl localhost/url3.htmlServer:3  Url:3~&gt; curl localhost/url3.htmlServer:2  Url:3~&gt; curl localhost/url3.htmlServer:2  Url:3~&gt; curl localhost/url3.htmlServer:1  Url:3</code></pre><h2 id="分片请求"><a href="#分片请求" class="headerlink" title="分片请求"></a>分片请求</h2><p>早期版本的Nginx对于缓存功能不是特别全，对于稍大的文件分片请求是不能支持的，在<code>1.9版本</code>以后提供的<code>slice模块</code>就实现了大文件的分片请求，它的配置语法如下：</p><table><thead><tr><th align="left">Syntax:</th><th><code>**slice** *size*;</code></th></tr></thead><tbody><tr><td align="left">Default:</td><td><code>slice 0;</code></td></tr><tr><td align="left">Context:</td><td><code>http</code>, <code>server</code>, <code>location</code></td></tr></tbody></table><p>slice size：表示我对一个大文件请求的时候我要切割成多大小的碎片去均匀的请求后端。</p><p>请求图示如下：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200212125648461.png" srcset="/img/loading.gif" alt="image-20200212125648461"></p><p>前端请求过来，它会把这个文件第一次请求后端去获取到这个文件的大小，然后根据这个大小以及我们定义<code>size</code>大小然后进行切片以分割成不同小的请求同时去请求后端，这样的话就形成了一个一个小的请求形成到前端的话就是一个个独立的缓存文件。</p><p>优势：</p><p>每个子请求收到的数据都会形成一个独立文件，一个请求断了，其它请求不受影响</p><p>缺点：</p><p>当文件很大或者<code>slice</code>很小的时候就会形成很多个小的请求，我们都知道一次请求就会造成操作系统的一个文件距离和建立一次连接而导致操作系统建立很多个文件距离和多个连接，可能出现损耗过多的情况</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nginx】 2.基础篇</title>
    <link href="/nginx-2.html"/>
    <url>/nginx-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="hljs bash">~&gt; yum install  -y nginx~&gt; nginx -v~&gt; nginx version: nginx/1.16.1</code></pre><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><pre><code class="hljs bash">nginx -tc /etc/nginx/nginx.conf<span class="hljs-comment">#检查配置是否正常</span>nginx -s reload -c /etc/nginx/nginx.conf <span class="hljs-comment">#重新加载并加载指定配置文件</span></code></pre><h1 id="目录和配置语法"><a href="#目录和配置语法" class="headerlink" title="目录和配置语法"></a>目录和配置语法</h1><p><strong>安装目录介绍</strong></p><pre><code class="hljs bash">~&gt; rpm -ql nginx/etc/logrotate.d/nginx/etc/nginx/fastcgi.conf/etc/nginx/fastcgi.conf.default/etc/nginx/fastcgi_params/etc/nginx/fastcgi_params.default/etc/nginx/koi-utf...</code></pre><blockquote><p>通过上面的命令来查看它安装之后放的位置,下面介绍一下一些重要的文件</p></blockquote><p>/etc/logrotate.d/nginx</p><blockquote><p>日志轮转，用于logrote服务的日志切割</p></blockquote><p>/etc/nginx/nginx.conf</p><blockquote><p>主要配置，启动的时候，主要读它</p></blockquote><p>/etc/nginx/conf.d/default.conf</p><blockquote><p>默认加载的配置</p></blockquote><p>/etc/nginx/fastcgi_params</p><blockquote><p>再用PHP这种fastcgi模式的时候，就需要加载fastcgi这个文件</p></blockquote><p>/etc/nginx/fastcgi_params</p><p>/etc/nginx/uwsgi_params</p><p>/etc/nginx/uwsgi_params</p><blockquote><p>cig配置相关、fastcgi配置</p></blockquote><p>/etc/nginx/koi-utf</p><p>/etc/nginx/koi-win</p><p>/etc/nginx/win-utf</p><blockquote><p>编码转换映射文件</p></blockquote><p>/etc/nginx/mime.types</p><blockquote><p>配置http协议的Content-Type与扩展对应关系。在HttpResponse中会有一个Content-Type，它描述数据的类型，比如是图片的话Content-Type会是一个JPG、GIF。Nginx要把Content-Type和它对应的扩展名建立一个对应关系就在这个配置文件，当Nginx要处理一些它不能识别的类型时，我们可以在这里去添加</p></blockquote><p>/usr/lib/systemd/system/nginx-debug.service</p><p>/usr/lib/systemd/system/nginx.service.d</p><p>/etc/sysconfig/nginx</p><p>/etc/sysconfig/nginx-debug</p><blockquote><p>用于配置出系统守护进程管理器管理方式</p></blockquote><p>/usr/lib64/nginx/modules</p><p>/etc/nginx/modules</p><blockquote><p>Nginx模块目录</p></blockquote><p>/usr/sbin/nginx</p><p>/usr/sbin/nginx-debug</p><blockquote><p>Nginx服务的启动管理的终端命令</p></blockquote><p>/usr/share/doc/nginx-1.16.1</p><p>/usr/share/doc/nginx-1.16.1/README</p><p>/usr/share/man/man8/nginx.8.gz</p><blockquote><p>Nginx的手册和帮助文件</p></blockquote><p>/var/cache/nginx</p><blockquote><p>Nginx的缓存目录</p></blockquote><p>/var/log/nginx</p><blockquote><p>Nginx的日志目录    </p></blockquote><h1 id="编译配置参数"><a href="#编译配置参数" class="headerlink" title="编译配置参数"></a>编译配置参数</h1><p><strong>安装编译参数</strong></p><p>prefix=/etc/nginx            主目录<br>–sbin-path =/usr/sbin/nginx        执行命令<br>-modules-path =/usr/lib64/nginx/modules        模块<br>-conf-path =/etc/nginx/nginx.conf        配置文件<br>–error-log-path=/var/log/nginx/error.log        错误日志目录<br>http-log-path=/var/log/nginx/access.log        访问日志<br>–pid -path =/var/run/nginx.pid        pid文件<br>-lock-path=/var/run/nginx.lock        锁</p><p>–http-client-body-temp-path=/var/cache/nginx/client_temp        </p><p>http-proxy-temp-path=/var/cache/nginx/proxy_temp        </p><p>http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp</p><p>http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp</p><p>http-scgi-temp-path=/var/cache/nginx/scgi_temp</p><hr><p>–user=nginx、–group=nginx        设定Nginx进程启动的用户和用户组</p><p>–with-cc-opt=parameters        设置额外的参数将被添加到CFLAGS变量</p><p> –with-ld-opt=parameters        设置附加的参数，链接系统库</p><h1 id="默认配置语法"><a href="#默认配置语法" class="headerlink" title="默认配置语法"></a>默认配置语法</h1><h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><table>  <tr>    <td>user</td>    <td>设置nginx服务的系统使用用户</td>  </tr>  <tr>    <td>worker_processes</td>    <td>工作进程数，一般与CPU保持一致</td>  </tr>  <tr>    <td>error_log</td>    <td>nginx的错误日志</td>  </tr>  <tr>    <td>pid</td>    <td>nginx服务启动时候pid</td>  </tr></table><p><strong>events</strong></p><table>  <tr>    <td>worker_connections</td>    <td>每个进程允许最大连接数</td>  </tr>  <tr>    <td>use</td>    <td>工作进程数</td>  </tr></table><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><pre><code class="hljs nginx">http&#123;    <span class="hljs-attribute">include</span>             /etc/nginx/mime.types;    <span class="hljs-comment">#日志类型</span>  <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">'<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] "<span class="hljs-variable">$request</span>" '</span>                      <span class="hljs-string">'<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> "<span class="hljs-variable">$http_referer</span>" '</span>                      <span class="hljs-string">'"<span class="hljs-variable">$http_user_agent</span>" "<span class="hljs-variable">$http_x_forwarded_for</span>"'</span>;  <span class="hljs-comment">#日志路径</span>  <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;  <span class="hljs-attribute">sendfile</span>            <span class="hljs-literal">on</span>;  <span class="hljs-comment">#客户端与服务端的超时时间</span>  <span class="hljs-attribute">keepalive_timeout</span>   <span class="hljs-number">65</span>;  <span class="hljs-attribute">include</span> /etc/nginx/conf.d/ <span class="hljs-regexp">*.conf</span>;  <span class="hljs-section">server</span> &#123;        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span> default_server;        <span class="hljs-attribute">listen</span>       [::]:<span class="hljs-number">80</span> default_server;        <span class="hljs-comment">#IP地址、域名</span>        <span class="hljs-attribute">server_name</span>  _;        <span class="hljs-attribute">root</span>         /usr/share/nginx/html;        <span class="hljs-comment">#加载默认服务器块的配置文件。</span>        <span class="hljs-attribute">include</span> /etc/nginx/default.d/ <span class="hljs-regexp">*.conf</span>;    <span class="hljs-comment">#location可以有多个，这里说如果访问的是'/'，就会定向到'/usr/share/nginx/html/index.html'</span>        <span class="hljs-attribute">location</span> / &#123;      <span class="hljs-comment">#root/usr/share/nginx/html;</span>      <span class="hljs-comment">#如果没有找到index.html，就会使用index.htm</span>      <span class="hljs-comment">#indexindex.htmlindex.htm;</span>        &#125;            <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;    <span class="hljs-attribute">location</span> = /40x.html &#123;        &#125;         <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;    <span class="hljs-attribute">location</span> = /50x.html &#123;      <span class="hljs-comment">#root/usr/share/nginx/html;</span>        &#125;    &#125;&#125;</code></pre><h1 id="日志log-format"><a href="#日志log-format" class="headerlink" title="日志log_format"></a>日志log_format</h1><h2 id="日志类型"><a href="#日志类型" class="headerlink" title="日志类型"></a>日志类型</h2><ul><li>error.log：记录处理请求错误的状态和Nginx本身服务的错误状态</li><li>access_log：记录http请求的访问状态，主要用于分析每一次请求和客户的交互和对行为的分析</li></ul><p>Nginx是如何实现这些日志的呢？</p><p>主要依赖于log_format配置，nginx的log中记录了很的信息，每一个信息可以理解成都是Nginx里面的对应的变量，log_format就是把这些变量组织到一起 ，记录到access_log中去</p><p>log_format的配置语法</p><ul><li>Syntax: log_format name [escape=default l json] string    ……;</li><li>Default: log_format combined    “…”;</li><li>Context:http</li></ul><h2 id="nginx-conf中配置"><a href="#nginx-conf中配置" class="headerlink" title="nginx.conf中配置"></a>nginx.conf中配置</h2><pre><code class="hljs nginx"><span class="hljs-attribute">error_log</span> /var/log/nginx/error.log [level];http&#123;    <span class="hljs-attribute">access_log</span>  /var/log/nginx/access.log  main;  &#125;</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>对于log_format来说，它有很多的变量，例如：</p><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">'<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] "<span class="hljs-variable">$request</span>" '</span>                      <span class="hljs-string">'<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> "<span class="hljs-variable">$http_referer</span>" '</span>                      <span class="hljs-string">'"<span class="hljs-variable">$http_user_agent</span>" "<span class="hljs-variable">$http_x_forwarded_for</span>"'</span>;&#125;</code></pre><p>这里做了一个分类</p><ul><li>HTTP请求变量 ：arg_PARAMETER、http_HEADER、sent_http_HEADER<ul><li>http_HEADER：request的Header输出</li><li>sent_http_HEADER：response的Header处理</li></ul></li><li>内置变量：Nginx内置的，这里由于变量很多，需要了解可以去看<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_status" target="_blank" rel="noopener">文档</a></li><li>自定义变量：自己定义</li></ul><hr><p>这里以<code>http_HEADER</code>做个例子：在日志中打印用户代理，在Request中会有一个User-Agent，它就是用户代理的信息，我希望能在日志中输出它，修改配置文件：</p><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;    <span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">'<span class="hljs-variable">$http_user_agent</span>'</span> ...&#125;</code></pre><p>效果：</p><pre><code class="hljs bash"><span class="hljs-comment">#修改了配置文件之后需要重载</span>~&gt; nginx -s reload -c /etc/nginx/nginx.conf ~&gt; curl localhost~&gt; tail -f /var/<span class="hljs-built_in">log</span>/nginx/access.logcurl/7.29.0curl/7.29.0::1 ...</code></pre><p>关于Nginx变量有很多种类型，这里给它进行分类：</p><ul><li>HTTP请求变量：arg_PAPARMTER、http_HEADER、set_http_HEADER</li><li>内置变量：Nginx内置变量<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#var_status" target="_blank" rel="noopener">文档</a></li><li>自定义变量：自己定义。这个会在lua章节中提到</li></ul><p>这里来介绍一下nginx.conf中默认使用的一些变量</p><pre><code class="hljs nginx"><span class="hljs-attribute">log_format</span>  main  <span class="hljs-string">'<span class="hljs-variable">$http_user_agent</span>'</span> <span class="hljs-string">'<span class="hljs-variable">$http_user_agent</span>'</span> <span class="hljs-string">'<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>] "<span class="hljs-variable">$request</span>" '</span>                      <span class="hljs-string">'<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> "<span class="hljs-variable">$http_referer</span>" '</span>                      <span class="hljs-string">'"<span class="hljs-variable">$http_user_agent</span>" "<span class="hljs-variable">$http_x_forwarded_for</span>"'</span>;</code></pre><ul><li>remote_addr：客户端地址</li><li>remote_user：http客户端请求认证的用户名，默认没有开启认证模块的话是不会有效的</li><li>time_local：时间</li><li>request：request头的请求行。比如请求方式：get、post，http的协议版本</li><li>status：response返回的状态</li><li>body_bytes_sent：从服务端响应给客户端body的大小</li><li>http_referer：标准http头信息。重要的记录信息，在防盗链里面对用户进行行为分析的时候这个会经常使用。它表示上一级页面是哪一个，我们访问当前这级页面那么它的上一级页面这个URL地址就会做为http_referer做记录</li><li>http_user_agent：标准http头信息。表示客户端的内容，我们用的IE那么它就打印对应的IE的agent，如果是chrome就会是chrome的agent</li><li>http_x_forwarded_for：标准http头信息。它会记录每一级用户通过http请求里面对应的所携带的http信息</li></ul><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>模块分类</strong></p><ul><li>Nginx官方模块：下载源码包中所默认携带的模块，以及在官方里面明写所支持的模块</li><li>第三方模块：没有得到官方默认支持的模块属于第三方模块，例如其它公司对Nginx做的一些模块开发开源出来可以使用或者自己开发的模块。这个会在lua章节中提到</li></ul><hr><p>通过<code>nginx -V</code>命令就能查看到Nginx编译的模块，它会以<code>–with</code>开头</p><pre><code class="hljs bash">~&gt; nginx -V--with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=<span class="hljs-string">'-O2</span></code></pre><p>这章不会介绍全部，只介绍一些大部分所用到的模块以及它对应的配置</p><h2 id="stub-status"><a href="#stub-status" class="headerlink" title="stub_status"></a>stub_status</h2><p>这个模块主要用于展示Nginx当前处理连接的状态，用于我们监控Nginx当前的连接信息，配置语法如下：</p><ul><li>Syntax: stub status；</li><li>Default：——</li><li>Context：server，location</li></ul><hr><p>nginx.conf加入内容</p><pre><code class="hljs nginx"><span class="hljs-comment">#内容</span>server&#123;<span class="hljs-attribute">location</span> /mystatus &#123;                stub_status;        &#125;&#125;</code></pre><p> 然后重载</p><pre><code class="hljs bash">~&gt; nginx -tc /etc/nginx/nginx.conf &amp;&amp; nginx -s reload -c /etc/nginx/nginx.confnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; curl localhost/mystatusActive connections: 3<span class="hljs-comment">#连接状态数 </span>server accepts handled requests<span class="hljs-comment">#展示了3个数，1：Nginx握手的总次数，2：Nginx连接数，3：总请求数。在正常情况连接数和握手数是一致的，这样表示它没有丢失</span> 6 6 3 Reading: 0 Writing: 1 Waiting: 2 <span class="hljs-comment">#表示当前状态，Reading：读的个数，Writing：写的个数，Waiting：在Nginx开启了keeplive长连接的情况下，表示客户端和服务端正在空闲的等待，既没有读也没有写，一个建立连接的数量</span></code></pre><h2 id="random-index"><a href="#random-index" class="headerlink" title="random_index"></a>random_index</h2><p><strong>编译选项</strong></p><p>–with-http_random_index_module：目录中选择一个随机主页    </p><p><strong>配置语法random_index_module</strong></p><p>Syntax：random_index on | off;<br>Default：random index off;<br>Context：location</p><hr><p><strong>演示</strong></p><p><code>/opt/app/code</code>下面有3个html</p><pre><code class="hljs bash">/opt/app/code&gt; <span class="hljs-built_in">echo</span> 1 &gt; 1.html/opt/app/code&gt; <span class="hljs-built_in">echo</span> 2 &gt; 2.html/opt/app/code&gt; <span class="hljs-built_in">echo</span> 3 &gt; 3.html</code></pre><p>nginx.conf</p><pre><code class="hljs lua">server&#123;location / &#123;    root /opt/app/code;    random_index on;  &#125;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; nginx -tc /etc/nginx/nginx.conf &amp;&amp; nginx -s reload -c /etc/nginx/nginx.confnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful~&gt; curl localhost1~&gt; curl localhost2~&gt; curl localhost1~&gt; curl localhost2~&gt; curl localhost2</code></pre><blockquote><p>这里注意：Nginx不会随机隐藏文件，只要文件开头是以.xxx就不会被随机</p></blockquote><h2 id="sub-module"><a href="#sub-module" class="headerlink" title="sub_module"></a>sub_module</h2><p><strong>编译选项</strong></p><p>–with-http_sub_module：用于Nginx服务端在给客户端response http的内容时候，给http的内容进行替换</p><p><strong>语法</strong></p><p>Syntax:：sub_filter string replacement;<br>Default：——<br>Context：http，server，location</p><p>Syntax：sub_filter_last_modified on | off；<br>Default：sub_filter_last modified off；<br>Context：http，server，location</p><blockquote><p>作用：http头信息的last-modified用于Nginx服务端来完成和客户端进行每一次请求校验服务端的内容是否有发生过变更，其目的是否有更新，如果发生更新返回给用户最新的内容，如果没有更新就不需要再一次返回html内容代码来减少不必要的消耗，这个主要用于缓存的场景里面，这个会在缓存章节中进行说明</p></blockquote><p>Syntax：sub_filter_once on off;<br>Default：sub_filter_once on;<br>Context：http，server，location</p><blockquote><p>作用：匹配所有html代码的第一个还是匹配所有指定的字符串，如果是on的话就只匹配第一个，如果是off的话会把所有html里面指定的内容都进行一次匹配</p></blockquote><p><strong>演示</strong></p><p>创建一个<code>submodule.html</code></p><pre><code class="hljs bash">/opt/app/code&gt; cat submodule.html&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;at&lt;/a&gt;&lt;a&gt;mcr&lt;/a&gt;&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;mcr&lt;/a&gt;</code></pre><p>nginx.conf修改</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">root</span> /opt/app/code;  <span class="hljs-attribute">index</span> submodule.html;  <span class="hljs-attribute">sub_filter</span> <span class="hljs-string">'&lt;a&gt;mcr&lt;/a&gt;'</span> <span class="hljs-string">'&lt;h1&gt;MCR&lt;/h1&gt;'</span>;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; nginx -tc /etc/nginx/nginx.conf &amp;&amp; nginx -s reload -c /etc/nginx/nginx.confnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful~&gt;  curl localhost&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;at&lt;/a&gt;&lt;a&gt;MCR&lt;/a&gt;&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;mcr&lt;/a&gt;</code></pre><p>这里可以看到，只有一个mcr做了替换，怎么办呢？这里需要将sub_filter_once关闭</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;            <span class="hljs-attribute">root</span> /opt/app/code;            <span class="hljs-attribute">index</span> submodule.html;            <span class="hljs-attribute">sub_filter</span> <span class="hljs-string">'&lt;a&gt;mcr'</span> <span class="hljs-string">'&lt;a&gt;MCR'</span>;            <span class="hljs-attribute">sub_filter_once</span> <span class="hljs-literal">off</span>;        &#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; nginx -tc /etc/nginx/nginx.conf &amp;&amp; nginx -s reload -c /etc/nginx/nginx.confnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf <span class="hljs-built_in">test</span> is successful~&gt; curl localhost&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;at&lt;/a&gt;&lt;a&gt;MCR&lt;/a&gt;&lt;a&gt;jeson&lt;/a&gt;&lt;a&gt;MCR&lt;/a&gt;</code></pre><h1 id="请求限制"><a href="#请求限制" class="headerlink" title="请求限制"></a>请求限制</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li>连接频率限制：limit_conn_module</li><li>请求频率限制：limit_req_module</li></ul><p>以上2个module都是可以实现Nginx的请求限制，但是它们的实现原来是不一样的，连接和请求是有区别的，关于连接和请求的区别介绍：</p><p>http请求建立在tcp协议上，要完成一次http请求先要进行tcp的3次握手，下面这张图描述了tcp3次握手：</p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20200123111840894.png" srcset="/img/loading.gif" alt="image-20200123111840894" style="zoom:50%;" /><p>在当今的http协议的时代，可以在一个连接的基础上建立多次请求，如上面这个图，先进行完tcp连接之后然后进行http的请求-响应，最后用客户端向服务端不断的发送FIN、ACK包来保持连接状态，也就是所谓的长连接。通过这个图可以知道连接是用在http请求的基础之上。</p><hr><p>在http不同版本的时候连接和 请求它有对应的限制</p><ul><li>http1.0：TCP不能否用。客户端向服务端发送请求以后，服务端在对应的时间后断开，一次连接对应一次请求</li><li>http1.1：顺序性TCP复用。一个连接可以顺序性被复用而发送多次http请求</li><li>http2.0：多路复用TCP复用。</li></ul><p>通过以上得出结论：</p><ul><li>http请求建立在一次TCP连接基础上</li><li>一次TCP请求至少产生一次HTTP请求，也可以产生多次HTTP请求</li></ul><hr><p><strong>连接限制</strong></p><p><strong>语法</strong></p><p>（1）</p><p>Syntax：limit_conn_zone key zone=name:size；<br>Default：—<br>Context：http</p><blockquote><p>这里的配置语法这么理解：既然要对连接进行限制那么就需要存储连接的状态，通过IP为空间进行存储，这里的limit_conn_zone就是它的空间，这里通过每个作为key，比如说：我想对客户端的IP作为key，我限制的就是客户端的ip，那么我就会把nginx对应remote_addr内置变量作为key，如果我们想以别的内置变量来作为限制的时候同样可以写到key下面。</p><p>这里的zone加了一个名字，这个是申请一块空间的zone的名字，这个名字是为了真正实现限制的时候来调用这个空间；size表示申请空间的大小</p></blockquote><p>（2）</p><p>Syntax：limit_conn_zone number;<br>Default：—<br>Context：http，server，location</p><blockquote><p>这里的语法需要结合上面的，先定义好zone才能使用这里的配置，这里后面直接加的zone，这个zone就是上面的zone的name，number表示限制并发数，比如是1，就允许期间有1个</p></blockquote><p><strong>请求限制</strong></p><p><strong>语法</strong></p><p>(1)</p><p>Syntax: limit_reg_zone key zone =name:size rate=rate;<br>Default：——<br>Context：http</p><blockquote><p>这里和连接限制的语法意思是一样的，rate是唯一的区别，这个地方是先定义好的，我对于这个请求我的限制是多大，通常是以秒为单位，然后请求限制是多少个，这里的意思是单位</p></blockquote><p>(2)</p><p>Syntax: limit_req zone=name [burst=number] [nodelay];<br>Default：——</p><p>Context：http，server，location</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="请求限制-1"><a href="#请求限制-1" class="headerlink" title="请求限制"></a>请求限制</h3><p>nginx.conf#http</p><pre><code class="hljs nginx"><span class="hljs-attribute">limit_conn_zone</span> <span class="hljs-variable">$binary_remote_addr</span> zone=conn_zone:<span class="hljs-number">1m</span>;<span class="hljs-comment">#这里的binary_remote_addr和remote_addr是一个意思，但是我们在这个地方是需要定义它的zone里面，我们知道这个zone大小设置的是1MB,对于1MB空间要存储remote_addr会比binary_remote_addr会要多10个字节</span><span class="hljs-comment">#限制同一个IP地址，所有的请求限制在1秒的时候内发起一个</span><span class="hljs-attribute">limit_req_zone</span>  <span class="hljs-variable">$binary_remote_addr</span> zone=req_zone:<span class="hljs-number">1m</span> rate=1r/s;</code></pre><p>测试</p><pre><code class="hljs bash"><span class="hljs-comment">#-n xx :总共发起请求数，-c xx：并发数</span>~&gt; ab -n 40 -c 20 http://localhost/index.html并发级别:20检测时间:0.002秒完成要求:40失败的请求:0写错误:0传输总量:202720字节传输的HTML: 193320字节每秒请求数:16508.46[<span class="hljs-comment">#/秒](平均)</span>每次请求所需时间:1.211 [ms](平均值)每个请求的时间:0.061 [ms](所有并发请求的平均时间)传输速率:81703.98 [Kbytes/sec]接收</code></pre><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;<span class="hljs-attribute">limit_req</span> zone=req_zone;&#125;</code></pre><pre><code class="hljs bash">~&gt; ab -n 40 -c 20 http://localhost/index.html并发级别:20检测时间:0.002秒完成要求:40失败的请求:39(Connect: 0, Receive: 0, Length: 39, Exceptions: 0)写错误:0Non-2xx反应:39传输总量:156700字节HTML传输:148860字节每秒请求数:18674.14[<span class="hljs-comment">#/秒](平均)</span>每个请求的时间:1.071 [ms](平均值)每个请求的时间:0.054 [ms](所有并发请求的平均时间)传输速率:71441.34 [Kbytes/sec]接收<span class="hljs-comment">#请求失败的都会可以在日志中查到</span>~&gt; tail -f /var/<span class="hljs-built_in">log</span>/nginx/error.log 020/01/23 16:02:32 [notice] 2651<span class="hljs-comment">#0: signal process started</span>2020/01/23 16:02:51 [error] 2654<span class="hljs-comment">#0: *648 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:02:51 [error] 2652<span class="hljs-comment">#0: *653 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>...</code></pre><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> / &#123;  <span class="hljs-comment">#limit_conn conn_zone;</span>  <span class="hljs-comment">#burst=3：客户端在超过指定的数据以后，遗留的3个会放到下一秒执行，保证这3个在后一秒执行，对客户端起到访问限速的作用也就是延迟响应，在超过3个时候会nodelay，直接返回503</span>  <span class="hljs-attribute">limit_req</span> zone=req_zone burst=<span class="hljs-number">3</span> nodelay;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; ab -n 40 -c 20 http://localhost/index.html并发级别:20检测时间:0.003秒完成要求:40失败的请求:36(Connect: 0, Receive: 0, Length: 36, Exceptions: 0)写错误:0Non-2xx反应:36传输总量:160240字节传输的HTML: 152280字节每秒请求数:12418.50[<span class="hljs-comment">#/秒](平均)</span>每次请求所需时间:1.611 [ms](平均值)每个请求的时间:0.081 [ms](所有并发请求的平均时间)传输速率:48582.54 [Kbytes/sec]接收</code></pre><h3 id="连接限制"><a href="#连接限制" class="headerlink" title="连接限制"></a>连接限制</h3><p>nginx.conf#server</p><pre><code class="hljs bash">location / &#123;<span class="hljs-comment">#limit_req zone=req_zone;</span>limit_conn conn_zone 1;&#125;</code></pre><blockquote><p>连接的限制是指服务端同一时刻只允许一个IP的连接过来</p></blockquote><p>测试</p><pre><code class="hljs bash">~&gt; ab -n 20 -c 20 http://localhost/index.html并发级别:20检测时间:0.002秒完成要求:20失败的请求:6(Connect: 0, Receive: 0, Length: 6, Exceptions: 0)写错误:0Non-2xx反应:6传输总量:94280字节HTML传输:89820字节每秒请求数:9237.88[<span class="hljs-comment">#/秒](平均)</span>每次请求所需时间:2.165 [ms](平均值)每个请求的时间:0.108 [ms](所有并发请求的平均时间)传输速率:42526.70 [Kbytes/sec]接收<span class="hljs-comment">#这里可以看下日志，上面说区域限制连接“conn_zone”，就表示前面的配置生效了</span>2020/01/23 16:24:35 [error] 2732<span class="hljs-comment">#0: *831 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:24:35 [error] 2732<span class="hljs-comment">#0: *838 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:24:35 [error] 2733<span class="hljs-comment">#0: *830 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:24:35 [error] 2733<span class="hljs-comment">#0: *832 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:24:35 [error] 2733<span class="hljs-comment">#0: *833 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span>2020/01/23 16:24:35 [error] 2734<span class="hljs-comment">#0: *843 limiting connections by zone "conn_zone", client: ::1, server: _, request: "GET /index.html HTTP/1.0", host: "localhost"</span></code></pre><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><p>关于http访问控制，在Nginx中提供了以下模块：</p><ul><li>基于IP的访问控制：http_access_module</li><li>基于用户的信任登录：http_auth_basic_module</li></ul><h2 id="access-module"><a href="#access-module" class="headerlink" title="access_module"></a>access_module</h2><p><strong>语法</strong></p><p>(1)</p><p>Syntax：allow address | CIDR | unix: | all；</p><p>Default：——</p><p>Context：http，server，location，limit_except</p><ul><li>allow address：允许某个地址</li><li>CIDR ：网段方式进行配置。例如：192.168.1.0/24，允许这一个网段进行访问</li><li>unix：在Nginx的limit上socket方式访问</li><li>all：允许所有的</li></ul><p>(2)</p><p>Syntax： deny address | CIDR | unix: | all；</p><p>Default：——</p><p>Context：http，server，location，limit_except</p><ul><li>deny address ：不允许哪些IP访问  </li></ul><p><strong>演示</strong></p><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/admin.html</span>&#123;                <span class="hljs-attribute">root</span> /opt/app/code;                <span class="hljs-attribute">deny</span> all;&#125;</code></pre><p>测试</p><pre><code class="hljs bash">~&gt; curl localhost/admin.html&lt;html&gt;&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>局限性</strong></p><blockquote><p>暂无</p></blockquote><h2 id="http-auth-basic-module"><a href="#http-auth-basic-module" class="headerlink" title="http_auth_basic_module"></a>http_auth_basic_module</h2><p><strong>语法</strong></p><p>(1)</p><p>Syntax：auth_basic string | off;<br>Default：auth_basic off;<br>Context：http，server，location，limit_except</p><blockquote><p>string：登录提示；</p><p>这个配置默认是关闭的“off”，如果需要 开启它，将off改为字符串即可</p></blockquote><p>(2)</p><p>Syntax：auth_basic_user_file file;<br>Default：——<br>Context：http，server，location，limit_except</p><blockquote><p>file：文件配置路径，这个路径的文件要来存储用户名和密码信息</p></blockquote><p>详细的介绍：<a href="https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="noopener">文档</a></p><p><strong>演示</strong></p><p>官方要求文件的密码需要通过<code>crypt</code>函数加密，这里可以在你的服务器中使用<code>htpasswd</code> ，这里先下载一下</p><pre><code class="hljs bash">~&gt; yum install  -y httpd-tools -y</code></pre><p>通过<code>htpasswd</code> 来生成文件</p><pre><code class="hljs bash">/etc/nginx&gt; htpasswd  -c ./auth_conf shuiNew password: 123456 Re-type new password: 123456 Adding password <span class="hljs-keyword">for</span> user shui</code></pre><p>nginx.conf#server</p><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/admin.html</span>&#123;                <span class="hljs-attribute">root</span> /opt/app/code;                <span class="hljs-attribute">auth_basic</span> <span class="hljs-string">"Please enter your account password!"</span>;                <span class="hljs-attribute">auth_basic_user_file</span> /etc/nginx/auth_conf;&#125;</code></pre><p><strong>局限性</strong></p><blockquote><p>暂无</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Nginx】 1.环境准备</title>
    <link href="/nginx-1.html"/>
    <url>/nginx-1.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境调试确认"><a href="#环境调试确认" class="headerlink" title="环境调试确认"></a>环境调试确认</h1><p><strong>两项安装</strong></p><pre><code class="hljs bash">~&gt; yum -y install  gcc gcc-c++ autoconf pcre pcre-devel make automake~&gt; yum -y install wget httpd-tools vim</code></pre><p><strong>一次初始化</strong></p><pre><code class="hljs bash">~&gt; <span class="hljs-built_in">cd</span> /opt &amp;&amp; mkdir app download logs work backup</code></pre><p><strong>目录介绍</strong></p><pre><code class="hljs lua">opt├── app<span class="hljs-comment">-- 存放代码</span>├── download<span class="hljs-comment">-- 存放源码包 </span>├── logs<span class="hljs-comment">--存放自定义日志</span>├── work<span class="hljs-comment">--存放shell脚本</span>└── backup<span class="hljs-comment">--存放默认配置文件，例如一些文件需要进行修改，这里存放它的一个默认配置</span></code></pre><p><strong>其它</strong></p><pre><code class="hljs bash"><span class="hljs-comment">#关闭、禁用防火墙</span>~&gt; systemctl  <span class="hljs-built_in">disable</span> firewalld.service &amp;&amp; systemctl  stop  firewalld.service<span class="hljs-comment">#查看SLinux是否开启</span>~&gt; getenforceEnforcing<span class="hljs-comment">#关闭SLinux</span>~&gt; setenforce 0</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Linux】 Linux初始化必做的一些事情</title>
    <link href="/linux-1.html"/>
    <url>/linux-1.html</url>
    
    <content type="html"><![CDATA[<h1 id="替换yum源"><a href="#替换yum源" class="headerlink" title="替换yum源"></a>替换yum源</h1><p><a href="https://idc.wanyunshuju.com/yum/851.html" target="_blank" rel="noopener">链接</a></p><h1 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h1><pre><code class="hljs bash">vim /etc/sysconfig/network-scripts/ifcfg-ens33<span class="hljs-comment">#内容：</span>BOOTPROTO=<span class="hljs-string">"static"</span> <span class="hljs-comment">#dhcp改为static </span>ONBOOT=<span class="hljs-string">"yes"</span> <span class="hljs-comment">#开机启用本配置</span>IPADDR=192.168.202.106 <span class="hljs-comment">#静态IP</span>GATEWAY=192.168.7.1 <span class="hljs-comment">#默认网关</span>NETMASK=255.255.255.0 <span class="hljs-comment">#子网掩码</span>DNS1=192.168.202.1 <span class="hljs-comment">#DNS 配置</span></code></pre><h1 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h1><pre><code class="hljs bash">yum -y install bash-completion</code></pre><h1 id="修改主机名（HostName）"><a href="#修改主机名（HostName）" class="headerlink" title="修改主机名（HostName）"></a>修改主机名（HostName）</h1><pre><code class="hljs bash">hostnamectl <span class="hljs-built_in">set</span>-hostname <span class="hljs-variable">$&#123;name&#125;</span> ...</code></pre><h1 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h1><pre><code class="hljs bash">yum install -y conntrack ntpdate ntp ipvsadm ipset jq  curl sysstat libseccomp wget vim net-tools git</code></pre><h1 id="关闭-SELINUX"><a href="#关闭-SELINUX" class="headerlink" title="关闭 SELINUX"></a>关闭 SELINUX</h1><pre><code class="hljs bash">swapoff -a &amp;&amp; sed -i <span class="hljs-string">'/ swap / s/^\(.*\)$/#\1/g'</span> /etc/fstabsetenforce 0 &amp;&amp; sed -i <span class="hljs-string">'s/^SELINUX=.*/SELINUX=disabled/'</span> /etc/selinux/config</code></pre><h1 id="调整内核参数，对于-K8S"><a href="#调整内核参数，对于-K8S" class="headerlink" title="调整内核参数，对于 K8S"></a>调整内核参数，对于 K8S</h1><pre><code class="hljs bash">cat &gt; kubernetes.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 <span class="hljs-comment"># 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它</span>vm.overcommit_memory=1 <span class="hljs-comment"># 不检查物理内存是否够用</span>vm.panic_on_oom=0 <span class="hljs-comment"># 开启 OOM</span>fs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720EOFcp kubernetes.conf /etc/sysctl.d/kubernetes.confsysctl -p /etc/sysctl.d/kubernetes.conf</code></pre><h1 id="调整系统时区"><a href="#调整系统时区" class="headerlink" title="调整系统时区"></a>调整系统时区</h1><pre><code class="hljs dsconfig"><span class="hljs-comment"># 设置系统时区为 中国/上海</span><span class="hljs-string">timedatectl </span><span class="hljs-built_in">set-timezone</span> <span class="hljs-string">Asia/</span><span class="hljs-string">Shanghai</span><span class="hljs-string">#</span> 将当前的 <span class="hljs-string">UTC </span>时间写入硬件时钟<span class="hljs-string">timedatectl </span><span class="hljs-built_in">set-local-rtc</span> 0<span class="hljs-comment"># 重启依赖于系统时间的服务</span><span class="hljs-string">systemctl </span><span class="hljs-string">restart </span><span class="hljs-string">rsyslog</span><span class="hljs-string">systemctl </span><span class="hljs-string">restart </span><span class="hljs-string">crond</span></code></pre><h1 id="关闭系统不需要服务"><a href="#关闭系统不需要服务" class="headerlink" title="关闭系统不需要服务"></a>关闭系统不需要服务</h1><pre><code class="hljs bash">systemctl stop postfix &amp;&amp; systemctl <span class="hljs-built_in">disable</span> postfix</code></pre><h1 id="设置-rsyslogd-和-systemd-journald"><a href="#设置-rsyslogd-和-systemd-journald" class="headerlink" title="设置 rsyslogd 和 systemd journald"></a>设置 rsyslogd 和 systemd journald</h1><pre><code class="hljs bash">mkdir /var/<span class="hljs-built_in">log</span>/journal <span class="hljs-comment"># 持久化保存日志的目录</span>mkdir /etc/systemd/journald.conf.dcat &gt; /etc/systemd/journald.conf.d/99-prophet.conf &lt;&lt;EOF[Journal]<span class="hljs-comment"># 持久化保存到磁盘</span>Storage=persistent<span class="hljs-comment"># 压缩历史日志</span>Compress=yesSyncIntervalSec=5mRateLimitInterval=30sRateLimitBurst=1000<span class="hljs-comment"># 最大占用空间 10G</span>SystemMaxUse=10G<span class="hljs-comment"># 单日志文件最大 200M</span>SystemMaxFileSize=200M<span class="hljs-comment"># 日志保存时间 2 周</span>MaxRetentionSec=2week<span class="hljs-comment"># 不将日志转发到 syslog</span>ForwardToSyslog=noEOFsystemctl restart systemd-journald</code></pre><h1 id="升级系统内核为-4-44"><a href="#升级系统内核为-4-44" class="headerlink" title="升级系统内核为 4.44"></a>升级系统内核为 4.44</h1><pre><code class="hljs bash">uname -r <span class="hljs-comment">#查看内核</span><span class="hljs-comment"># 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！</span>rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpmyum --enablerepo=elrepo-kernel install -y kernel<span class="hljs-_">-lt</span><span class="hljs-comment"># 设置开机从新内核启动</span>grub2-set-default <span class="hljs-string">'CentOS Linux (4.4.189-1.el7.elrepo.x86_64) 7 (Core)'</span></code></pre><h1 id="kube-proxy开启ipvs的前置条件"><a href="#kube-proxy开启ipvs的前置条件" class="headerlink" title="kube-proxy开启ipvs的前置条件"></a>kube-proxy开启ipvs的前置条件</h1><pre><code class="hljs bash">modprobe br_netfiltercat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF<span class="hljs-meta">#!/bin/bash</span>modprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOFchmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</code></pre><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager \--add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-comment">#2选1，这个保证最新</span>yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repoyum update -y &amp;&amp; yum install -y docker-ce<span class="hljs-comment">## 创建 /etc/docker 目录</span>mkdir /etc/docker<span class="hljs-comment"># 配置 daemon.</span>cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;<span class="hljs-string">"exec-opts"</span>: [<span class="hljs-string">"native.cgroupdriver=systemd"</span>],<span class="hljs-string">"log-driver"</span>: <span class="hljs-string">"json-file"</span>,<span class="hljs-string">"log-opts"</span>: &#123;<span class="hljs-string">"max-size"</span>: <span class="hljs-string">"100m"</span>&#125;,<span class="hljs-string">"registry-mirrors"</span>: [<span class="hljs-string">"https://c0dhqpb1.mirror.aliyuncs.com"</span>]&#125;EOFmkdir -p /etc/systemd/system/docker.service.d<span class="hljs-comment"># 重启docker服务</span>systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl <span class="hljs-built_in">enable</span> docker</code></pre><h1 id="安装DockerComponent"><a href="#安装DockerComponent" class="headerlink" title="安装DockerComponent"></a>安装DockerComponent</h1><p> 通过以下命令自动下载并安装适应系统版本的 Compose</p><pre><code class="hljs bash">sudo curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose</code></pre><p>为安装脚本添加执行权限</p><pre><code class="hljs bash">chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose</code></pre><p>这样，Compose 就安装完成了。可使用以下命令测试安装结果。</p><pre><code class="hljs bash">~&gt; docker-compose --versiondocker-compose version 1.16.1, build 1719ceb</code></pre><p>安装 Compose 命令补全工具</p><pre><code class="hljs bash">sudo curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose</code></pre><h1 id="kubectl自动补全"><a href="#kubectl自动补全" class="headerlink" title="kubectl自动补全"></a>kubectl自动补全</h1><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"source &lt;(kubectl completion bash)"</span>&gt;&gt; /root/.bashrc<span class="hljs-built_in">source</span> /root/.bashrc<span class="hljs-built_in">echo</span> <span class="hljs-string">"source /usr/share/bash-completion/bash_completion"</span>&gt;&gt;/root/.bashrc<span class="hljs-built_in">source</span> /root/.bashrc</code></pre><h1 id="让你提升命令行效率的-Bash-快捷键-完整版"><a href="#让你提升命令行效率的-Bash-快捷键-完整版" class="headerlink" title="让你提升命令行效率的 Bash 快捷键 [完整版]"></a>让你提升命令行效率的 Bash 快捷键 [完整版]</h1><h2 id="常用的命令行击键操作"><a href="#常用的命令行击键操作" class="headerlink" title="常用的命令行击键操作"></a>常用的命令行击键操作</h2><p>ctrl + insert　 xshell 中复制，可以设置选中内容自动复制<br>ctrl shift + c　 crt 中复制<br>shift + insert　xshell 中粘贴<br>ctrl shift + v　 crt 中粘贴<br>ctrl+tab 　 xshell 中快速切换连接选项卡<br>alt + N 　 N 为数字，CRT 中快速切换连接选项卡<br>alt + d 删除光标所在位置的后单词，要设置 alt 键为 meta 键<br>ctrl + w 删除光标前一个单词相当于 VIM 里 db<br>ctrl + k 删除光标后面所有字符相当于 VIM 里 d shift+$<br>ctrl + u 删除光标前面所有字符相当于 VIM 里 d shift+^<br>ctrl + y 恢复 ctrl+u 上次执行时删除的字符<br>ctrl + 键盘左右键 快速移动一个词（Xshell）<br>ctrl + a 将光标移动到命令行开头相当于 VIM 里 shift+^ 或者 home 键<br>ctrl + e 将光标移动到命令行结尾处相当于 VIM 里 shift+$ 或者 end 键<br>ctrl + p 返回上一次输入命令字符<br>ctrl + r 输入单词搜索历史命令<br>Ctrl + g 从历史搜索模式退出，Ctrl+r 后用作退出使用<br>alt + p 输入字符查找与字符相接近的历史命令<br>ESC + . 打印之前执行过的命令的最后一部分（参数）以空格为分隔符，也可以用 alt+.<br>Ctrl + l 清屏<br>Ctrl + o 执行当前命令，并选择上一条命令<br>Ctrl + z 挂起命令<br>Ctrl + d 退出登录<br>tab 键 自动补全<br>ctrl + i 类似 TAB 健补全功能，一般用 tab 不用它<br>Ctrl + Shift + r 重新登录前一个用户<br>ctrl + c 终止当前操作<br>ctrl + s 锁住终端<br>ctrl + q 解锁终端<br>ctrl + o 重复执行命令<br>alt + 数字键 操作的次数（Xshell）</p><h2 id="命令行击键操作整理-复制粘贴和窗口切换"><a href="#命令行击键操作整理-复制粘贴和窗口切换" class="headerlink" title="命令行击键操作整理,复制粘贴和窗口切换"></a>命令行击键操作整理,复制粘贴和窗口切换</h2><p>ctrl + insert　 xshell 中复制，可以设置选中内容自动复制<br>ctrl shift + c　 crt 中复制<br>shift + insert　xshell 中粘贴<br>ctrl shift + v　 crt 中粘贴<br>ctrl+tab 　 xshell 中快速切换连接选项卡<br>alt + N 　 N 为数字，CRT 中快速切换连接选项卡<br>alt + d 删除光标所在位置的后单词，要设置 alt 键为 meta 键</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>ctrl + d 删除光标所在位置上的字符相当于 VIM 里 x 或者 dl<br>ctrl + h 删除光标所在位置前的字符相当于 VIM 里 hx 或者 dh<br>ctrl + k 删除光标后面所有字符相当于 VIM 里 d shift+$<br>ctrl + u 删除光标前面所有字符相当于 VIM 里 d shift+^<br>ctrl + w 删除光标前一个单词相当于 VIM 里 db<br>ctrl + y 恢复 ctrl+u 上次执行时删除的字符<br>ctrl + ? 撤消前一次输入<br>alt + r 撤消前一次动作<br>alt + d 删除光标所在位置的后单词</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>ctrl + a 将光标移动到命令行开头相当于 VIM 里 shift+^ 或者 home 键<br>ctrl + e 将光标移动到命令行结尾处相当于 VIM 里 shift+$ 或者 end 键<br>ctrl + f 光标向后移动一个字符相当于 VIM 里 l<br>ctrl + b 光标向前移动一个字符相当于 VIM 里 h<br>ctrl + 方向键左键 光标移动到前一个单词开头<br>ctrl + 方向键右键 光标移动到后一个单词结尾<br>ctrl + x 在上次光标所在字符和当前光标所在字符之间跳转<br>alt + f 跳到光标所在位置单词尾部</p><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>ctrl + t 将光标当前字符与前面一个字符替换<br>alt + t 交换两个光标当前所处位置单词和光标前一个单词<br>alt + u 把光标当前位置单词变为大写<br>alt + l 把光标当前位置单词变为小写<br>alt + c 把光标当前位置单词头一个字母变为大写<br>^oldstr^newstr 替换前一次命令中字符串</p><h2 id="历史命令编辑"><a href="#历史命令编辑" class="headerlink" title="历史命令编辑"></a>历史命令编辑</h2><p>ctrl + p 返回上一次输入命令字符</p><p>ctrl + r 输入单词搜索历史命令</p><p>alt + p 输入字符查找与字符相接近的历史命令</p><p>alt + &gt; 返回上一次执行命令</p><p>Ctrl + g 从历史搜索模式退出</p><p>Ctrl + n 历史中的下一条命令</p><p>Alt + . 打印之前执行过的命令的最后一部分（参数）以空格为分隔符</p><p>ESC + . 打印之前执行过的命令的最后一部分（参数）以空格为分隔符</p><h2 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h2><p>Ctrl + l 清屏</p><p>Ctrl + o 执行当前命令，并选择上一条命令</p><p>Ctrl + z 挂起命令</p><p>Ctrl + d 退出登录</p><p>tab 键 自动补全</p><p>clear 清屏</p><p>logout 退出当前用户</p><p>Ctrl + Shift + r 重新登录前一个用户</p><p>ctrl + c 终止当前操作</p><p>ctrl + s 锁住终端</p><p>ctrl + q 解锁终端</p><p>ctrl + i 类似 TAB 健补全功能，一般用 tab 不用它</p><p>ctrl + o 重复执行命令</p><p>alt + 数字键 操作的次数（xshell 中）</p><h1 id="通过lrzsz-代替FTP"><a href="#通过lrzsz-代替FTP" class="headerlink" title="通过lrzsz 代替FTP"></a>通过lrzsz 代替FTP</h1><p><a href="https://www.jianshu.com/p/d4dcbd088a05" target="_blank" rel="noopener">链接</a></p><pre><code class="hljs bash">~&gt; yum -y install lrzsz</code></pre><h1 id="安装Jdk8"><a href="#安装Jdk8" class="headerlink" title="安装Jdk8"></a>安装Jdk8</h1><p><a href="https://blog.csdn.net/xingbaozhen1210/article/details/84062364" target="_blank" rel="noopener">链接</a></p><pre><code class="hljs bash">~&gt; yum -y install java-1.8.0-openjdk*</code></pre><h1 id="Xshell-登录-Linux-太慢怎么办"><a href="#Xshell-登录-Linux-太慢怎么办" class="headerlink" title="Xshell 登录 Linux 太慢怎么办"></a>Xshell 登录 Linux 太慢怎么办</h1><pre><code class="hljs bash">~&gt; vim /etc/ssh/sshd_config<span class="hljs-comment">#加入内容：</span>UseDNS no</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>零碎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 15.开发运维常见坑</title>
    <link href="/redis-15.html"/>
    <url>/redis-15.html</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核优化"><a href="#Linux内核优化" class="headerlink" title="Linux内核优化"></a>Linux内核优化</h1><h2 id="vm-overcommit-memory"><a href="#vm-overcommit-memory" class="headerlink" title="vm.overcommit_memory"></a>vm.overcommit_memory</h2><blockquote><p>针对Redis申请内存，它针对操作系统申请内存的一些设置，这里主要关心Redis相关的申请内存的设置</p></blockquote><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191110211518864-1573391851722.png" srcset="/img/loading.gif" alt="image-20191110211518864"></p><p>如果说你给<code>overcommit_memory</code>设置为0，当你启动时，日志中它会警告</p><p>提示你这个参数为0，但是如果你的内存在一个比较紧张的情况下，那可能bgsave、bgrewriteaof可能会失败，那修复这种问题呢它建议去将这个<code>overcommit_memory</code>设置为1并且写入到<code>/etc/sysctl.conf</code>这个文件上，这样的话即使在重启的情况下你这个<code>overcommit_memory</code>也会生效，也就是说设置为1，</p><h3 id="overcommit含义"><a href="#overcommit含义" class="headerlink" title="overcommit含义"></a>overcommit含义</h3><p>它有3个值：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191110212118191.png" srcset="/img/loading.gif" alt="image-20191110212118191"></p><p>前面为什么要将这里设置为1呢首先0表示如果内存足够，它就给你，1就是说我可能会超量的给你，这里有个含义：进程在申请内存的时候，它申请了4GB，但是它有时候并没有申请4GB就去用4GB，这里0表示一种保守的策略，1就不保守，可能有引起一些问题一些情况，我现在没有4GB，但是还是给你分配，那可能因为其他的人它申请了但没有去用，1就是为了解决这个问题；</p><p>前面介绍部分的那张图，在你启动的时候建议你将它设置为1，它目的是为了保证bgsave、bgrewriteaof的成功，这个是为了防止bgsave、bgrewriteaof可能会产生一个阻塞，说了半天就是一个fork的失败，fork失败就意味着主线程可能会被阻塞</p><h3 id="overcommit实践"><a href="#overcommit实践" class="headerlink" title="overcommit实践"></a>overcommit实践</h3><h4 id="获取和设置"><a href="#获取和设置" class="headerlink" title="获取和设置"></a>获取和设置</h4><pre><code class="hljs bash">获取：[root@mcr2 ~] cat /proc/sys/vm/overcommit_memory 0设置：[root@mcr2 ~] <span class="hljs-built_in">echo</span> <span class="hljs-string">"vm.overcommit_memory=1"</span> &gt;&gt; /etc/sysctl.conf[root@mcr2 ~] sysctl vm.overcommit_memory=1</code></pre><h4 id="最佳实现"><a href="#最佳实现" class="headerlink" title="最佳实现"></a>最佳实现</h4><ol><li>前面说了内存超量的使用，对于我们在生产环境中我们应该怎么去做呢？设计上我们对Redis设置合理的maxmemory，这样和之前将的内存管理的时候，给每个Redis设置maxmemory之和然后把当前的机器保留20%~30%的闲置内存，这样保证了足够的闲置内存然后就可以完成类似fork相关可能出现内存溢出的情况；</li><li>集中化管理AOF重写和RDB的bgsave，重写我们知道这个如果你开了aof它重写是必然会产生的，为了防止aof文件过大，然后它就会执行重写这样的工作，那我们怎么防止重写集中化的爆发呢？其实我们可以做一个集中化的管理，比如说对当前机器我们去写一个程序或者做一个工具让它去遍历当前机器下所有的Redis，让它去看当前的aof是否达到重写的条件，让aof重写放到我们手中防止集中爆发；<br>RDB的bgsave有两点：<ul><li>复制产生；</li><li>在夜间做一个集中的备份，在集中备份的时候我们一定要做一个创建备份，不让当前机器下所有的Redis都做bgsave，<br>这里还有一个问题：我当前这个机器master比较多，</li><li>如果master和slave之间长时间的断开，也有可能出现当前机器所有的主都会bgsave，这也是比较危险的，这个就涉及到我们在分配内存的时候跟分配主从关系的时候的一个分配算法，也就是说我们不要让过多的主节点放在一个机器中，可能如果主从之间机器发生断开的时候，可能会出现集中大量的bgsave</li></ul></li><li>我们按照Redis的建议把这个值设置为1，这样其实是为了防止极端情况下会造成fork失败，这个相信了解参数含义的读者应该明白这个道理，笔者后面会对这个overcommit_memory这个参数进行演示带着大家看一下操作系统的相关设置，以及之前的日志内容</li></ol><pre><code class="hljs bash">[root@mcr2 config] <span class="hljs-built_in">pwd</span>/usr/src/redis/config[root@mcr2 config] vim 6379.conf 内容port 6379daemonize yesdir /usr/src/redis/datadbfilename 6379.rdblogfile 6379.log启动：[root@mcr2 config]<span class="hljs-comment"># redis-server ./6379.conf </span>查看6379节点的日志2669:M 11 Nov 06:13:31.937 <span class="hljs-comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span>这段内容就是上面的那段提示了，这里说建议将overcommit_memory设置为1并且将它并且将它重定向到配置文件中查看overcommit_memory内容[root@mcr2 config] cat /proc/sys/vm/overcommit_memory 0设置为1[root@mcr2 config] <span class="hljs-built_in">echo</span> <span class="hljs-string">"vm.overcommit_memory=1"</span> &gt;&gt; /etc/sysctl.conf[root@mcr2 config] sysctl vm.overcommit_memory=1</code></pre><h2 id="swappiness"><a href="#swappiness" class="headerlink" title="swappiness"></a>swappiness</h2><blockquote><p>针对swappiness的一些设置</p></blockquote><h3 id="swappiness含义"><a href="#swappiness含义" class="headerlink" title="swappiness含义"></a>swappiness含义</h3><p>swappiness是操作系统在使用swappiness这个事情上的一个概率 or 倾向，它的默认值是60，它的最大值是100，当它达到100的时候就代表它会主动的使用swappiness，当它是60的时候它可能会你可以认为百分之的概率也就是60的值会使用swappiness，当它是0的时候使用概率会更小，但是Linux在不同的内核版本中它有一些不同的规定：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191111192035694.png" srcset="/img/loading.gif" alt="image-20191111192035694"></p><p>对于Linux3.5以上版本的时候它会宁愿用OOM killer也不用swap，在低版本下它宁愿用一下swap也不希望被OOM killer进行杀掉，我们在对Redis这个东西，在Linux环境下会怎么去设置呢？我们当然给它设置为0，也就是说我们不希望Linux去使用swap，因为swap是非常慢的，我们Redis之所有非常快是因为它的所有数据放在了内存当中，当然也跟它的线程模型、数据结构优化有关，但实际上它本质快的原因因为它是一个全内存的一个数据库、缓存，这里当然不使用swap</p><h3 id="swappiness实践"><a href="#swappiness实践" class="headerlink" title="swappiness实践"></a>swappiness实践</h3><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><ol><li>立即生效：echo {bestvalue} &gt; /proc/sys/vm/swappiness；</li><li>永久生效：echo vm.swappiness={bestvalue} &gt;&gt; /etc/sysctl.conf。</li></ol><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>如果Linux内核大于3.5，推荐设置：vm.swappiness=1，否则vm.swappiness=0，从而实现如下两个目标：</p><ul><li>物理内存充足时候，使Redis足够快，不让Linux去用swappiness；</li><li>物理内存不足时候，避免Redis死掉，这个也不是绝对的，如果当前Redis为高可用，死掉比阻塞更好，因为死掉之后还有新的组从进行切换这个时候就不会出现Redis僵死的情况</li></ul><h2 id="THP-Transparent-huge-page"><a href="#THP-Transparent-huge-page" class="headerlink" title="THP(Transparent huge page)"></a>THP(Transparent huge page)</h2><blockquote><p>针对fork，在子进程的时候可能会用到这个参数</p></blockquote><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191111193516660.png" srcset="/img/loading.gif" alt="image-20191111193516660"></p><p>它和overcommit非常类似，假如它认为你的THP的值设置的值不是它认为很理想的值，它会给你打一串日志，上面这张图就是日志上的警告内容，它警告你当前的THP是在你Linux内核下开启的，首先来介绍一下什么是THP？——THP是为了加速fork，就是在做bgsave、bgwriteaof的时候都会有一个fork，它会加速fork，原来它的内存页是4kb，在THP特性开启时候它会达到2mb，就是说它扩大了512倍，它会大大加速Redis的fork速度，我们知道fork是在Redis下主线程执行的，加快速度就意味着你的主线程的阻塞时间比较短，它是一个非常好的东西，但是它还有很多问题，我们来看图中的第二句话，它说：你开启了这个特性可能会造成一些延迟甚至内存使用的问题，这里的延迟主要是指因为你内存页扩大了，那可能在内存页扩大发生这期间如果你做一些操作可能会对当前信息的阻塞，我们在线上遇到过一个情况，开启了THP属性，但写入量比较大的时候，甚至一个<code>incr</code>操作，一个不可能出现在慢查询列表的操作它出现在慢查询列表当中了，它就会造成慢查询，当然还有一个是内存使用的问题：这个体现在因为这个fork使用的是<code>copy on write</code>就是写时复制，假如你的写入量非常大，那你原来的一个4kb的内存页现在要变成2mb，你的写入量非常大，意味着它的<code>copy on write</code>量大，可能会造成内存暴增，假如你是1GB的Redis，由于内存页非常大但是并不是说Redis内存全都是连续的，内存页大量的复制<code>copy on write</code>可能会造成内存大量的产生，它会提示你修复这个问题建议你把这个特性关闭：echo never打印到指定的路径下，它还会建议你把它添加到<code>/etc/rc.local</code>中，及时在重启了THP的特效依然会被关闭掉</p><h3 id="THP作用"><a href="#THP作用" class="headerlink" title="THP作用"></a>THP作用</h3><ol><li>作用：加速fork；</li><li>建议：禁用，可能产生更大的内存开销；</li><li>设置方法： echo never&gt;/sys/kernel/mm/transparent_hugepage/enabled</li><li>坑：源码是绝对路径，注意不同发行版本的区别<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191111195140272.png" srcset="/img/loading.gif" alt="image-20191111195140272"><br>它会fopen，这个路径下去找到这个THP有没有开启，其实这样写没什么问题，但是它没有预料到在不同的Linux发行版本像centos可能THP这个属性对应的路径是不一样的，比如用得红帽，它的路径上没有THP这个属性，它是类似于自己加了一个路径设置了THP，对于Redis启动的时候它只会检测绝对路径不会检测相对路径，就会出现它没有任何提醒但是你当前是在使用THP的情况，这里在你使用的时候一定要注意你的Linux的发行版本</li></ol><h2 id="OOM-killer"><a href="#OOM-killer" class="headerlink" title="OOM killer"></a>OOM killer</h2><blockquote><p>Redis的是内存，如果内存使用不当、内存暴增、内存超过Linux本身内存的情况下可能有会有一个<code>OOM Killer</code>，Linux会选举一些不重要的一些进程进行删除</p></blockquote><ol><li>作用：当前这个机器内存超量去使用了，操作系统会按照某些规则把一些不重要的进程kill掉</li><li>配置方法：/proc/{progress_id}/oom_adj，oom_adj越小杀掉进程的概率越小。前面提到内存已经使用超出了，假如说当前有10个进程，它会从oom_adj中选择比较大的进程进行杀除，这里的杀除策略是非常复杂的，我们也不会进行详细的分析，我们知道需要知道oom_adj这个参数是控制它被杀的概率</li><li>运维经验：对于Redis来说，我们可以将每一个Redis的进程的oom_adj设置比较小，在发生oom killer的时候不会被干掉，在实际生产中我们不会用这样的规则，首先一点我们当前机器下肯定是单机多部署，而且是部署一堆Redis，大部分情况不于其他应用混部实际上也是一个很不专业的行为，而且一个就是说不要过度依赖于此特性，应该合理管理内存。<ul><li>有关OOM killer的详细细节，可以参考Linux源码：mm/oom_kill.c中oom_badness函数；</li><li>笔者认为oom_adj参数只能起到辅助作用，合理地规划内存更为重要；</li><li>通常在高可用情况下，被杀掉比僵死更好，因此不要过多依赖oom_adj配置。</li></ul></li></ol><h2 id="NTP（Net-Time-Protocol）"><a href="#NTP（Net-Time-Protocol）" class="headerlink" title="NTP（Net Time Protocol）"></a>NTP（Net Time Protocol）</h2><blockquote><p>它是一个时间服务，可以实现一个公共的时间服务，相当于你可以看到它是一个标准的时间，然后其他的一些机器、一些服务去它那边去拿一个时间，让大家达到一个时间的一致性</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112190022980.png" srcset="/img/loading.gif" alt="image-20191112190022980">它就是对时服务，你可以理解为它就是一个钟表，比如北京使用、某个区域的一个表，对于它下面的很多机器，比如说我们当前有很多机器，那我完全可以对每个机器执行一个定时认为，比如说让它每小时去跟NTP做一次同步，这样的话我们机器之间的时间是一致的，当时间一致的时候我们就在做一些分布式的时候就比较好有好处了，比如对于时间的一些判断是一致的，这样对于一些行为的规定一些处理这样的话达到一致的效果，对于我们Redis来说，我们当前的无论是RedisSentinel、RedisCluster，它做的选举是依赖与本地机器的时间，也就是说及时时间不一致也不会对当前集群的选举产生问题因为它依赖的是本地时间， 但是任然希望你把它做一个这样的NTP服务呢？不然说我们当前有N台机器，然后集群之间形成了一个集群，然后我们在排查一些问题的时候，如果发现你的时间点都是不一致的对于你排查问题的时候也不是非常的方便，所以这里任然会建议你去跟这个NTP服务做一个实时的定时任务</p><h2 id="ulimit"><a href="#ulimit" class="headerlink" title="ulimit"></a>ulimit</h2><blockquote><p>对于连接的限制</p></blockquote><h3 id="ulimit与Redis"><a href="#ulimit与Redis" class="headerlink" title="ulimit与Redis"></a>ulimit与Redis</h3><p>这个主要是对Linux文件句柄的限制进行一个设置，它于Redis的关系是什么？</p><p>在你启动Redis的时候，日志中可以会出现：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112191441944-1573557295700.png" srcset="/img/loading.gif" alt="image-20191112191441944"></p><p>它会告诉你当前Redis的maxclients设置的最大客户端连接数是1W，你至少需要10032文件句柄，这是什么意思？就是说Redis默认的 maxclients是1W，它为什么需要1W和10032个文件句柄？是因为除了你的客户端连接以外Redis自身也需要很多文件句柄，它会告诉你当前Redis是不能把文件句柄设置成10032个，是因为当前没有权限，因为可能你在启动Redis的时候没有使用root用户（当然这里不建议你去使用root用户），它告诉你当前最大的文件句柄是4096个，也就是说它建议你把maxclients设置成4064个，实际上就是4096去减去32，那如果你想去设置更高的值，那你就把它执行一个<code>ulimit -n</code>，这样一个设置，把你当前的进程的文件句柄设置的更大一些这样可以满足Redis的一个需求。其实说了这么多就是Redis启动的时候是需要10032个句柄，你当前句柄数比较小，只有4096那建议你去进行一个设置，你在启动一定要给进程进行一个设置。</p><h2 id="TCP-backlog"><a href="#TCP-backlog" class="headerlink" title="TCP backlog"></a>TCP backlog</h2><blockquote><p>针对TCP网络的连接时，TCP3次握手会有一个async对列，针对那个东西进行一些设置</p></blockquote><h1 id="安全的Redis"><a href="#安全的Redis" class="headerlink" title="安全的Redis"></a><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112192420855.png" srcset="/img/loading.gif" alt="image-20191112192420855">安全的Redis</h1><h2 id="全局crackit攻击"><a href="#全局crackit攻击" class="headerlink" title="全局crackit攻击"></a>全局crackit攻击</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112193358968.png" srcset="/img/loading.gif" alt="image-20191112193358968"></p><h3 id="被攻击的Redis特征"><a href="#被攻击的Redis特征" class="headerlink" title="被攻击的Redis特征"></a>被攻击的Redis特征</h3><ol><li>Redis所在的机器有外网IP；</li><li>Redis以默认端口6379为启动端口，并且是对外网开放的；</li><li>Redis是以root用户启动的；</li><li>Redis没有设置密码；</li><li>Redis的bind设置为0.0.0.0或者“”。</li></ol><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112193722132.png" srcset="/img/loading.gif" alt="image-20191112193722132"></p><p>左边部分代表攻击的机器，右边是被攻击的机器，它当前是一个公网启动了一个Redis，这个Redis是以root启用的，而且绑定网卡是0.0.0，也就是它没有绑定，然后它端口也没有做限制，它允许公网的任何端口对外暴露，以6379启动；</p><p>现在来看一下攻击步骤，很显然ssh root这台机器，这样是可以连通的，因为你没有密码，而且你没有授权，这个时候是连接不上的，这里我可以先连接Redis，因为Redis没有设置密码，没有做限制，连接之后我可以执行一个 <code>flushall</code>，当前就把你的Redis清除了，这其实不够坏，这样只影响了Redis没有影响机器本身，那我可以继续用Redis的特点 来完成下面的事情，首先设置一个key叫做crackitz这个key，然后我把它设置值是我当前的公钥的一个字符，然后我对当前这个Redis去执行<code>config set dir，</code>我给它设置一个新的dir，我把它设置成ssh目录下，然后我会执行``config set dbfilename`，也就是说我设置一个自己的一个dbfilename，就比如说是一个授权文件，然后执行save，那它就相当于在.ssh里面授权文件里面去添加了这台攻击机器A的公钥，这样的话我下面就可以免密码去访问这台机器干很多的坏事</p><h2 id="Redis安全七法"><a href="#Redis安全七法" class="headerlink" title="Redis安全七法"></a>Redis安全七法</h2><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><ol><li>服务端设置：设置密码就是requirepass这个参数，需要注意的是我们要为从节点设置masterauth，这样的话从节点就能同步主节点命令，为了防止主从之间的切换，我们建议你把requirepass和masterauth在主从节点都进行一个设置，这样的话即使发生了主从切换，它任然可以完成各自的职责；</li><li>客户端连接：auth命令和-a参数</li><li>相关建议：<ul><li>密码足够复杂，防止暴力破解；</li><li>masterauth不要忘记；</li><li>auth还是通过明文传输，意味着通过网络的一些监听，比如说对网络进行抓包，可以拿到中间可能产生的一系列密码，这样的话抓过来之后可以进行一个解析做很多的坏事，这个暂时没有太好的方法，一些云服务提供类似于SSL安全的一些方式进行文本协议的传输来减少这样的问题，但整体来说Redis是运行在内网中的，只要你保证它有密码，大部分情况下不会被挖取到</li></ul></li></ol><h3 id="伪装危险命令"><a href="#伪装危险命令" class="headerlink" title="伪装危险命令"></a>伪装危险命令</h3><ol><li>服务端配置：rename-command，它可以将当前命令伪装成其他字符或者一个空，它有什么含义呢？假如我不希望客户端去使用<code>flushall</code>这样的命令，我可以将<code>flushall</code>伪装成也给空的字符串，把这个命令干脆禁掉或者伪装成随机字符串</li><li>客户端连接：不可用或者使用指定随机字符；</li><li>相关建议：<ul><li>不支持config set动态设置；</li><li>RDB和AOF如何包含rename-command之前的命令，将无法使用</li><li>config命令本身是在Redis内核会使用到，不建议设置</li></ul></li></ol><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ol><li>服务端配置：bind可以限制网卡的输入流量，假如说你有4个网卡或者4个ip地址，它可能限制当前的Redis流量是从哪个网卡去打入的，注意这里它不是限制客户端，这个很容易让刚刚接触它的人去迷惑的这个命令是限制某些网关的IP客户端能访问，它无法限制IP，它只能限制网卡的流量；</li><li>相关建议：<ul><li>bind不支持config set；</li><li>bind 127.0.0.1需要谨慎，如果你设置127.0.0.1只能从本机去访问，这个不是很好，因为假如你Redis真是和你的应用放在一个机上，你可以这样设置，但实际中肯定有很多其它的流量去访问到Redis，而且很多Redis是做分布式的，它需要节点之间的通信，如果你设置这样一个选项的话会对分布式的使用有影响或者说干脆就使用不了；</li><li>如果存在外网网卡，经量去设置这样的配置，它能保证你的流量不会从外网去打入进来；</li></ul></li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ol><li>防火墙：杀手锏，你设置任何密码也不如你设置一个防火墙有用，但是防火墙的设置一定要注意，比如说像RedisCluster节点之间的通信或者你在做分布式的时候或者你对外网的一个访问，就是外网IP内网IP的一个访问的时候一定要设置清楚，否则出现网络不通的情况下可能对你Redis使用会有一定影响；</li><li>定期备份，这个是根据前面讲的安全事件总结出来的，万一你的数据被删了，或者说主机被攻陷了，如果你有一个定期备份的数据，也不至于让Redis数据丢失；</li><li>不太管用的方法，在个别情况下管用，不使用默认端口，防止被弱攻击杀掉；</li><li>强制：使用非root用户启动，假如说攻击者拿到root用户权限，那危害是非常大的</li></ol><h1 id="热点Key发现"><a href="#热点Key发现" class="headerlink" title="热点Key发现"></a>热点Key发现</h1><h2 id="热点key的寻找方法"><a href="#热点key的寻找方法" class="headerlink" title="热点key的寻找方法"></a>热点key的寻找方法</h2><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><blockquote><p>因为客户端是访问Redis的数据来源，我们知道所有的请求是在哪里</p></blockquote><p>这里客户端来解决不是一个非常好的方法，例如我们可以写一个这样的东西，我们可以记录每分钟每个key的调用次数，然后我们在客户端去记录这样的东西，然后定期的去清理这个map中的访问次数，这样防止你的map过大，但是这里任然有一个问题：即使你只记录一分钟的可能你的map也非常大，而且客户端去记录这样的东西本身也会增加你客户端的业务逻辑，不建议去使用，假如你的key很少或者说你当前的情况下是允许这样做，建议你去设置，可以采用这样的思路</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112212752956.png" srcset="/img/loading.gif" alt="image-20191112212752956"></p><h3 id="代理端"><a href="#代理端" class="headerlink" title="代理端"></a>代理端</h3><blockquote><p>使用codis这样的工具从代理端获取数据</p></blockquote><p>像使用codis，它是所有流量都打到代理上的，然后代理可以有一个权重量的一个统计，可以做类是的事情 ，但是仍然有那样的问题：一个是代理要增加代理的逻辑，实现复杂度的逻辑，还有就是在实际使用过程中代理可以是多个，因为代理的负载会很高，它需要满足底下很多Redis的规模然进行客户端的要求，所以代理会非常多，做这个也会很复杂</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112213120406.png" srcset="/img/loading.gif" alt="image-20191112213120406"></p><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><blockquote><p>通过Redis统计热点key在哪里</p></blockquote><p>使用monitor这样的命令解析Redis执行了哪些东西，通过monitor短暂的解析这个东西 ，比如使用它去分析近10W条Redis的命令并找出比如说哪些命令命令执行的比较多，是get-set还是hget-hset比较多，然后我们可以总结这10W条命令中哪些key的前缀出现的比较多，这样就有可能去找到对应的热点key，但是前面已经介绍了monitor的各种问题，所以在使用这种monitor的方式时候要尽量小心一点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112213522769.png" srcset="/img/loading.gif" alt="image-20191112213522769"></p><h3 id="机器收集"><a href="#机器收集" class="headerlink" title="机器收集"></a>机器收集</h3><blockquote><p>使用机器的抓包、对于数据协议的分析来找到对应的热点</p></blockquote><p>假设现在有很多Redis部署在多个机器或者一个机器上，我们可以通过对这太机器网络包的分析，我们可以抓取这些信息的Redis的一个TCP数据来对这个当前的机器上所有的流量进行分析，这样的话也可以找到对应的热点key。上述都提供了Redis抓取热点key、寻找热点key的思路，在实际生产过程中你要根据对应的一个使用场景或者Redis的规模、具体情况来进行分析</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112213914768.png" srcset="/img/loading.gif" alt="image-20191112213914768"></p><h2 id="四种方式总结"><a href="#四种方式总结" class="headerlink" title="四种方式总结"></a>四种方式总结</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191112213927833.png" srcset="/img/loading.gif" alt="image-20191112213927833"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 14.内存管理</title>
    <link href="/redis-14.html"/>
    <url>/redis-14.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis内存优化介绍"><a href="#Redis内存优化介绍" class="headerlink" title="Redis内存优化介绍"></a>Redis内存优化介绍</h1><p>Redis是一个存内存的缓存/存储，这也是它非常快的原因，但是我们同时知道其实内存相对来说还是比较昂贵的，当然它比CPU要便宜很多，当时相对于其他硬件来说它的总体价格要高很多，虽然说使用Redis非常快，但是当我们去使用Redis的量非常大的时候，我们也希望能节省更多的内存，当然节省内存也是要有限度的，不能因为节省内存而让我们Redis的使用效益下降，这章来介绍Redis内存优化的一些技巧</p><h1 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h1><h2 id="内存使用统计"><a href="#内存使用统计" class="headerlink" title="内存使用统计"></a>内存使用统计</h2><blockquote><p>Redis作为非常好的kv缓存、存储它给我们提供这样的信息，通过<code>info memory</code>来查看Redis使用状况</p></blockquote><p>内存使用统计：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106193830684.png" srcset="/img/loading.gif" alt="image-20191106193830684"></p><p>假如现在<code>redis-cli</code>执行了一个<code>info memory</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106194219160.png" srcset="/img/loading.gif" alt="image-20191106194219160"></p><h2 id="内存消耗划分"><a href="#内存消耗划分" class="headerlink" title="内存消耗划分"></a>内存消耗划分</h2><blockquote><p>对Redis做一个更加细分的一个分析，上面这种方式只是能获取全局的内存使用，但是对于每一个细节的地方它做的还不够细，在新的Redis 4.0版本里已经提供了这样的功能，但是我们这里主要还是讲线上、公司用的比较多的版本：3.2版本，这里为什么不讲最新的？其实是这样，对于Redis这种存储来说，假如我们公司有几万个节点，那我能不能一下从Redis3升级成Redis4呢？其实这是非常难的，为什么？因为我们做的是数据，这里面的数据会涉及到迁移，迁移的话可以会影响其他的业务甚至在迁移的时候会发生很多问题，所有在你当前这个版本能够满足你大部分功能的前提下你做不做升级其实不是很重要，比如说可能新的版本的特性能解决一个痛点或者能极大提升效率这种情况下可以考虑做升级，当然新的版本肯定是最好的，我们这里主要还是介绍用的比较多的主流版本：Redis3</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106194241995-1573041430182.png" srcset="/img/loading.gif" alt="image-20191106194241995"></p><p>对于used_memory来说它分为4个部分，自身一个内存：你启动以一个Redis它肯定会有一些自身的内存的开销，因为它本来有一些共享变量这样的一些东西，当然这些占用内存非常低，一般也就几百KB根据不同版本可能不太一样，这里的部分内存基本不用你去担心；</p><p>这里的重头戏就是2个部分：</p><ul><li><p>对象内存： 我们存的key-value比如hash、set那些东西；</p></li><li><p>缓冲内存：缓存内存会稍微复杂一些，包括对外缓冲区、复制缓冲区、客户端缓冲区，当然这些东西如果你使用不是很好的话也可能会出现一些很奇怪的问题；</p></li><li><p>Lua内存：当你使用lua的时候，这个时候可能会有一个lua的内存；</p></li><li><p>内存碎片：系统分配给你的内存和你用的内存的一个差值，这个差值就是一个碎片，假如我们使用的是一个字符串类型，我们用了一个 <code>set hello word</code>，比如说hello和word就是5个字节，那就分配给你5个字符串，但是当你在<code>set hello</code>是一个长的情况下它就为了保证Redis SDS的数据结构，它认为你可能还会用到更多内存的情况下，它会给你预留一部分，当你再<code>set hello word</code>回来之后它并不会把内存做一个回收，这个时候可能会产生碎片的情况，有兴趣的读者可以去看下Redis源码中SDS的部分，这里只需要知道我们用了很多内存，这个部分是用的，但是你申请的可能会比用的多一些这个时候就会产生内存碎片</p></li></ul><hr><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106200207592-1573041728497.png" srcset="/img/loading.gif" alt="image-20191106200207592"></p><p>这里来看一个更加详细的内存消耗，第一部分自身内存，前面提到过了，也就几百K或者更多一点根据不同版本，这里相对来说是固定的，这里比较主要的就是缓冲内存它是比较复杂的，它包括3个部分：</p><ul><li>客户端缓冲区：Redis客户端执行get、set一些命令的时候甚至像memory这样的命令的时候它都会有一个缓冲区，Redis无论是客户端发送命令还是返回结果它都会有一个缓冲区来缓冲这部分内存；</li><li>复制缓冲区：前面介绍的复制，会有复制缓冲区，为了防止全量复制这样的问题；</li><li>AOF缓冲区：它有2个部分，AOF写入的缓冲区、AOF重写期间的缓冲区，后面会对它进行详细说明。</li></ul><p>这里重头戏就是对象内存，就是你存的那些key和value，当然不仅仅value很重要，你的key也很重要，假如说你的key非常大或者很长这对整体内存使用量也会有一定影响，这和具体的规模有关系</p><hr><p>现在进入Redis来执行一个info命令</p><pre><code class="hljs bash">127.0.0.1:6379&gt; info <span class="hljs-comment"># Server</span>redis_version:3.0.7redis_git_sha1:00000000redis_git_dirty:0redis_build_id:fee2042acc931bb1redis_mode:standaloneos:Linux 3.10.0-1062.1.2.el7.x86_64 x86_64arch_bits:64multiplexing_api:epollgcc_version:4.8.5process_id:2061run_id:82774a23e6d19c005a1c79a396e953e309efc3f1tcp_port:6379uptime_in_seconds:25uptime_in_days:0hz:10lru_clock:12790371config_file:/usr/src/redis/config/redis-6379.conf<span class="hljs-comment"># Clients 客户端</span>connected_clients:1client_longest_output_list:0client_biggest_input_buf:0<span class="hljs-comment">#客户端缓冲区</span>blocked_clients:0<span class="hljs-comment"># Memory内存相关</span>used_memory:816544used_memory_human:797.41Kused_memory_rss:7647232used_memory_peak:816544used_memory_peak_human:797.41Kused_memory_lua:36864mem_fragmentation_ratio:9.37mem_allocator:jemalloc-3.6.0<span class="hljs-comment">#...</span></code></pre><p>这里会发现它有很多选项，假如你想看内存的使用量你可以执行<code>info memory</code>，用前面介绍的几点进行分析</p><pre><code class="hljs bash">127.0.0.1:6379&gt; info memory<span class="hljs-comment"># Memory</span>used_memory:815704<span class="hljs-comment">#Redis内存使用量</span>used_memory_human:796.59Kused_memory_rss:7647232<span class="hljs-comment">#操作系统使用量，它申请的内存</span>used_memory_peak:816544used_memory_peak_human:797.41Kused_memory_lua:36864mem_fragmentation_ratio:9.38<span class="hljs-comment">#比值碎片率</span>mem_allocator:jemalloc-3.6.0</code></pre><h1 id="客户端缓冲区"><a href="#客户端缓冲区" class="headerlink" title="客户端缓冲区"></a>客户端缓冲区</h1><h2 id="客户端缓冲区分为3类"><a href="#客户端缓冲区分为3类" class="headerlink" title="客户端缓冲区分为3类"></a>客户端缓冲区分为3类</h2><p>普通客户端：你可以认为它就是正常的我们执行命令比如get、set一些正常的命令，你无论使用什么客户端去连接都是普通客户端缓冲；</p><p>slave客户端：我们现在有一对主从，主和从之间要同步数据，这里的客户端是一个从，它有一个伪装的客户端去接受这个master同步过来命令；</p><p>pubsub客户端：pubsub发布订阅模式比较特殊，它会有一个单独的缓冲区</p><h2 id="输入缓冲区"><a href="#输入缓冲区" class="headerlink" title="输入缓冲区"></a>输入缓冲区</h2><p>在介绍上面3种缓冲区之前，来看一下输入缓冲区。</p><p>刚才说的那3种都是输出缓冲区，那么输入缓冲区是什么意思？就是我现在有很多客户端去发送给Redis命令，无论是get、set这些东西，从图中看到有3个客户端分别执行了很多命令，这些命令发送给Redis之前它会放到各自客户端的缓冲区当中，可以简单的认为就是一个对列的东西去发送到Redis中瞬间去执行，这个是非常快的，你放到缓冲区中可能就会立刻被Redis执行，但有一个问题如果Redis非常忙，这个时候你发送的字节数非常非常大，比如set一个hello它的value有几百兆，我们知道Redis预期是512兆，你设置非常大可能它的缓冲区就会被暂时阻塞掉，所以大部分情况下你看到的输入缓冲区可能都是0，但是可能你设置非常大的值的时候可能会被卡主或者Redis忙的时候可能发生变动，但一般说还好，其实Redis允许的一个最大的客户端缓冲区是1G，如果你超过1G的情况下会有什么问题？你的客户端会直接被服务端干掉，对于客户端来说这个连接就已经断了，所以这个也是一个问题，通常来说输入缓冲区也没有太多问题，当然你出现类似这种问题的时候你可以用刚才我们info命令中的统计可以看到这些信息，稍后会给读者们去看一下。</p><hr><p>我们重点去看输出缓冲区，输出缓冲区主要是针对命令返回，刚才是把命令发送了，现在是把命令返回，因为我们知道有3类：普通客户端、从节点的slave客户端、pubsub客户端，它针对这3种类型可以灵活的配置，它和上一类输入缓冲区不一样一点就是它可以进行配置，上一个必须要求你不能超过个1G，这里就可以进行配置</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106205416410.png" srcset="/img/loading.gif" alt="image-20191106205416410"></p><p>这里的<code>hard limit</code>可以设置为0，表示无论多大都不会关闭，这样可以保证客户端不会被关闭，但是可能会产生一个问题：它会占额外内存，因为我们知道used_memory里面它是有一项客户端缓冲区的，<code>soft limit</code>和<code>soft seconds</code>是一个组合选项，这个是什么意思？它会发现你的客户端在这个<code>soft limit</code>值中，比如我们设置了64M，我们超过64M达到了60秒，这个时候我们可能就会将客户端进行关闭，它是和<code>hard limit</code>相对应的东西，2方面进行限制，一个是软限制另一个是硬限制。</p><h2 id="普通客户端缓冲区"><a href="#普通客户端缓冲区" class="headerlink" title="普通客户端缓冲区"></a>普通客户端缓冲区</h2><p>这里是根据输出缓冲区进行的设置：</p><ol><li><p>默认：<code>client-output-buffer-limit normal 0 0 0</code></p></li><li><p>上面的配置意思是默认没有对客户端输出缓冲区进行限制</p></li><li><p>这里有2个问题其实前面已经提到了，这样设置的目的是什么？其实就是Redis为了保证客户端连接不会被干掉，但是这样做有一个坏处：当执行非常大的命令，比如一次<code>hgetall</code>，然后在一个几百万的哈希这样的key-value去执行这样的命令或者执行很频繁的时候我们必然会发现我们普通客户端的输入缓冲区会被阻塞，因为它的每次返回结果非常大，还有一种情况像monitor这样的命令，所有客户端执行的命令在monitor端都可以监控到，它是有一个非常好的地方它可以监控Redis当前到底执行了什么命令然后是哪些客户端执行的？它的坏处也很明显，当你的Redis客户端非常多而且每个客户端它执行的并发量非常大，就是说所有的命令都会打到monitor客户端上，然后就会出现一个问题：monitor的输入缓冲区会很大，因为它无法及时消费所有的命令的结构</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106210724039.png" srcset="/img/loading.gif" alt="image-20191106210724039"><br>，它是一个非常有帮助的命令，但是如果你使用不当，比如你不是在当前Redis上使用的而是在其他机器远程连接，这样会降低消费速度，在使用这样的命令会比较危险，它会让你输入缓冲区瞬间可能出现暴增的情况，我们后面会做一个例子来模拟这样的问题，这里还关于monitor设置的问题，后面也会进行说明</p></li></ol><h2 id="slave客户端缓冲区"><a href="#slave客户端缓冲区" class="headerlink" title="slave客户端缓冲区"></a>slave客户端缓冲区</h2><p>slave缓冲区就是同步主节点的写命令来实现一个主从同步</p><ol><li>默认：<code>client-output-buffer-limit slave 256mb 64mb 60</code>，</li><li>这里建议这部分值调大一些，这是因为什么？比如说主从延迟比较高或者从节点比较多的时候，可能会出现客户端缓冲区会被膨胀，超过你这个limit限制，在出现这种情况下，会出现全量复制的情况，但是你的主节点分片比较大，这个时候也会出现你的客户端缓冲区被打满，当然这和写入量也有关系，也会造成客户端缓冲区被打满的情况</li><li>建议从节点不要过多，你的分片不要过大，这里为什么要把这些值调大一些呢？这部分客户端是相对独立的，它就只有1个，我们可以将它调大一些，来牺牲一点内存而防止客户端直接被干掉slave客户端产生新的全量复制的问题，所以一定要注意要适当调大一些，比如512mb，这样的话能防止slave客户端缓冲区被干掉的情况。</li></ol><h2 id="pubsub客户端缓冲区"><a href="#pubsub客户端缓冲区" class="headerlink" title="pubsub客户端缓冲区"></a>pubsub客户端缓冲区</h2><p>pubsub客户端缓冲区是针对发布订阅命令来单独设置的客户端的输出缓冲区</p><ol><li>默认：<code>client-output-buffer-limit pubsub 32mb 8mb 60</code>，pubsub不是一个很主流的方法，它的使用场景并不是很多，因为它不是一个专业的发布订阅、消息队列系统，如果你要使用的话来根据自己的使用量来进行一个合理的调整，如果你发现你的pubsub缓冲区出现了比较大的情况，比如你发现你代码中你的客户端被断开了，是因为pubsub缓冲区过大造成的；</li><li>它的阻塞原因：生产速度大于消费速度，它的一个查询方法也是需要在info进行查询或者使用client list这样的命令进行查询，稍后会结合之前介绍的内存进行统一的演示；</li><li>注意：根据自己的使用场景来进行调试，你的并发量、你的生产和消费速度比 类似这样的东西进行调试</li></ol><h2 id="客户端缓冲区演示"><a href="#客户端缓冲区演示" class="headerlink" title="客户端缓冲区演示"></a>客户端缓冲区演示</h2><pre><code class="hljs bash">127.0.0.1:6379&gt; info clients <span class="hljs-comment"># Clients</span><span class="hljs-comment">#客户端连接数</span>connected_clients:1<span class="hljs-comment">#你所以的缓冲区是一个list，它由2部分组成，一个是buffer加上list，这个buffer比较小也就是剩下的缓冲区对象是通过这样一个list进行存储的，这项统计中统计的是所有客户端中这个list最大的，当前是0，因为这是一个测试环境，但是如果你发现这个是非常大的，比如它超过了1K,那这个时候可能就会有些缓冲区阻塞，这个时候它要有多大你也看不到，后面会介绍命令进行查询</span>client_longest_output_list:0<span class="hljs-comment">#客户端输入缓冲区最大的buffer，上面的是个数，这个是字节</span>client_biggest_input_buf:0blocked_clients:0</code></pre><p>那我们想了解所有客户端的一个呢？</p><pre><code class="hljs bash">127.0.0.1:6379&gt; client listid=2 addr=127.0.0.1:54212 fd=6 name= age=5937 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</code></pre><p>这里可以看到所有客户端的基本信息，age是说这个连接连接了多久？idle是闲置时间等等一些东西，其中有几个比较重要的和输出缓冲区相关的：</p><ul><li><p>qbuf：缓冲区有多大</p></li><li><p>qbuf-free：缓冲区有多少空余的</p></li><li><p>obl、oll：缓冲区的list有多大</p></li><li><p>omem：缓冲区是不是很大，将上面2个进行计算然后算一些它的内存有多大，如果发现这个比较大的时候可能就是一个有问题的连接，这个可以根据实际应用场景进行查询，可以通过以下命令</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -a abcdef client list | grep -v <span class="hljs-string">"omem=0"</span>1</code></pre><p>omem为0的过滤掉进行查询，可能就能查询到出现有问题的，然后进行问题的查询</p></li></ul><h1 id="缓冲内存"><a href="#缓冲内存" class="headerlink" title="缓冲内存"></a>缓冲内存</h1><h2 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107202202656.png" srcset="/img/loading.gif" alt="image-20191107202202656"></p><p>在学习之前的章节，会讲到一部分关于复制的内容，其实复制缓冲区就是<code>repl_back_buffer</code>这个配置，这个配置主要是用来设置复制缓冲区的大小，它主要是将这个缓冲区master节点的一些命令写入到缓冲区内，为了防止slave节点和master节点出现临时的网络抖动而造成不必要的全量复制，主要是做这部分内容的；这里不会多说它的详细配置因为在之前课程中已经介绍过了，这里再次强调一点，它的默认值是<code>1MB</code>，下面我们应该给它设置比较大的值，比如设置为<code>100MB</code>，注意一下这部分内存实际上也是一个独立的，就相当于一个master节点有buffer这个东西，然后我们可以适当给它调大然后牺牲一部分内存来减少不必要的全量复制；上面这张图是全量复制的演示图；</p><h2 id="AOF缓冲区"><a href="#AOF缓冲区" class="headerlink" title="AOF缓冲区"></a>AOF缓冲区</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107202434669.png" srcset="/img/loading.gif" alt="image-20191107202434669"></p><p>如果你开启了AOF,AOF这种持久化方式无论你是使用哪种刷盘策略，它都是将命令写到一个buffer当中，然后再做一个刷盘的动作，所以这个buffer就是AOF的缓冲区；我们在做AOF重写的时候如果你对上面这张图还有印象的话，它就是做重写的内容，AOF在的重写的时候这期间产生的<code>aof buffer</code> 是不是要做一个单独的记录，如果进行一个单独的记录的话就会有一个额外的aof重写的buffer，它也是aof的buffer，这个也是需要注意的，这个值是没有固定的限制的，它也没有容量的限制，在这一块的话需要注意一下，但是一般来说这块也不会有太大问题，只需要知道这个内存也会由这部分来组成就好了，不必须过渡去关系，除非写量非常大，刷盘刷的有问题这个时候就会放到buffer里。</p><h1 id="内存消耗-1"><a href="#内存消耗-1" class="headerlink" title="内存消耗"></a>内存消耗</h1><h2 id="对象内存"><a href="#对象内存" class="headerlink" title="对象内存"></a>对象内存</h2><p>对象内存是由2部分组成：</p><ol><li>key：不要过长，量大不容忽视（redis3：embstr 39字节）</li><li>value：ziplist、intset等优化方式</li></ol><h2 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h2><p>内存碎片是必然产生的，因为我们的Redis使用的是jemalloc，jemalloc它的分配策略是按块，也不能说是按照块是按照段，比如这么个意思：以4k、8k、16k这样一个内存分配来为单位当然还有更大的一个递增内存块，其实一个内存块不能认为是一个内存单位，其实是这样的，它比如会产生一个内存碎片就是说我的一个对象可能会有举个例子可能只有15k，但它只有8k、12k、16k，这个时候我们可能会分配16k，这个时候就换产生内存碎片，当然前面这个具体是8k、12k还是16k我没有细研究过，而是我举了一个例子，你大概能懂这个意思就好了，比如说它是8k和16k、12k两种，那现在来个 15k它必然是有一个内存碎片的，这个需要注意一下，其实内存碎片主要是因为频繁的比如说做append、setrange、过期这种情况产生的比较多，其实内存碎片没有太好的解决办法，Redis官方的一个说明说如果你的内存碎片大于1.4倍，这个时候你可以考虑做一些内存碎片的处理，比如说最明显的方法就是重启，但是大部分情况下是不允许重启的，但是在<code>redis sentinel</code>、<code>redis cluster</code>这样的架构是允许把slave节点重启，重启之后然后它会做一个重新的内存分配，这样的话可以将碎片进行一个清理，对于主节点来说也可以，如果你真的想做那样的事情的话可以做一个主从切换，然后再把它当做从节点再进行重启，这样就可以完成碎片的整理；目前Redis3来说没有太好的解决办法，对于Redis4、Redis5这些版本这种情况有一个内存碎片管理的选项的，但是这个东西没有在线上或者云服务、一些公司大规模去使用，所以暂时还不建议去用，你可以去了解一下相关的内容</p><h2 id="子进程内存内存消耗"><a href="#子进程内存内存消耗" class="headerlink" title="子进程内存内存消耗"></a>子进程内存内存消耗</h2><p>你对aof、rdb比较了解的情况下你应该知道Redis是使用fork来实现bgsave和bgrewriteaof；它是一个必须存在的，假如我们执行了fork，必然会产生一个子进程，那肯定会有额外的内存开销，这里说的必然存在是因为即使你关了aof当然它是没有aof重写了，你关了自动save还是无法避免全量复制，它也是用rgsave生成一个rdb全量的文件，它必然会产生fork，fork是无法避免的；</p><p>它的优化方式有几种：</p><ul><li>去掉THP特性：它是在Linux内核的2.6.38增加的，它可以加快fork的速度，但是它有一个问题，它在写时复制的时候它的内存页会比原来扩大512倍，原理的4KB现在变成2MB，如果写量非常大的时候它会产生不必要的阻塞、内存的暴增，这里的内核优化会在后面进行说明；</li><li>观察写入量：copy-on-write的写入量；</li><li>overcommit_memory=1，这个在后介绍Linux内核的时候会说，它的作用是可以用fork顺利的完成</li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>内存管理比较简单，但是它很重要，它的简单是因为它就2个参数：</p><ul><li>你要给Redis设置一个内存上限，这个对于内存管理是非常有帮助的；</li><li>动态调整内存上限，这个内容和上面是相关的；</li><li>内存回收策略，这个和最大内存也是相关的，当你的Redis设置了4GB内存，但是你已经使用或者超过4GB内存的时候，之后你写入的时候要采用什么策略，是把原来的数据踢掉，还是是单纯的写进去还是使用其他的什么策略，至于踢掉哪些数据也有相关不同的策略</li></ul><h2 id="设置内存上限"><a href="#设置内存上限" class="headerlink" title="设置内存上限"></a>设置内存上限</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107211253752.png" srcset="/img/loading.gif" alt="image-20191107211253752"></p><p>现在上面这张图中是一个Linux，我们有24GB，它有4个Redis进程，Redis1-4，每个是4GB，我们要给这个机器空闲一些内存去做AOF重写、BGSAVE这样产生的fork内存，当然对于Linux自身也要预留一部分内存，对于配置来说就是一个<code>max-memory</code>一个选项来给Redis设置一个最大内存，这样的好处在于我们可以对每个Redis使用内存进行限制，当限制之后我们可以对机器内存的使用进行合理的管理，假如我们现在启动了很多Redis，但是没有对它们设置最大内存，如果无法控制Redis内存的使用量可能会超过单机就会影响其他的实例，这东西对于Redis管理来说是一个很致命的问题，这里还要提到一点：我们要预留百分30，这个是需要根据你公司的实际情况来决定，可能你们机器比较多，而且使用上比较宽长一些，可能会预留多一些，当然预留的越多你产生的危险就越小，因为我们都知道，它可能会产生一些额外的开销，比如像客户端缓冲区的暴增，客户端缓冲区是无法通过<code>max-memory</code>限制的，<code>max-memory</code>是说当你的<code>used-memory</code>超过<code>max-memory</code>是对于<code>key-value</code>的管理，对于这种客户端缓冲区的暴增它是无法限制的，针对于这类问题甚至一些fork产生的内存这些额外内存以外的问题你预留的内存越多可能这种产生内存溢出的可能就会越小，如果你们公司当前机器比较紧张一些可能预留的会少一些，如果你把内存监控做的足够好，可能产生内存溢出的可能性就越小；</p><h2 id="设置内存上限-1"><a href="#设置内存上限-1" class="headerlink" title="设置内存上限"></a>设置内存上限</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107211801815.png" srcset="/img/loading.gif" alt="image-20191107211801815"></p><pre><code class="hljs bash">redis&gt; config <span class="hljs-built_in">set</span> maxmemory 6GBredis&gt; config <span class="hljs-built_in">set</span> maxmemory 2GBredis&gt; config rewrite</code></pre><p>例如刚才哪个Redis1到Redis4，每个4GB的，这个时候我Redis2其实用不了这么多，我们上限之后发现它用不了这么多，我们可能就会给它进行一个缩容，将原来的4GB变成了2GB，但是注意你的原来的4GB使用最好不要超过2GB，这个时候如果超过2GB就可能产生一个数据的回收问题，对于Redis1来说原来4GB，现在变成了6GB，那么就应该在Redis1中去执行<code>config set maxmemory 6GB</code>，在Redis2中执行<code>config set maxmemory 2GB</code> ，对于这2个操作我们都要进行 <code>config rewrite</code>，进行一个配置重启，给它回到磁盘当中</p><h2 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h2><p>上一部分内容非常简单就是一个内存管理，但是建议在你的Redis使用过程中都要进行一个设置，一个问题：当你的 key-value或者说内存已经超过了 <code>maxmemory</code>设置的时候那它比如会有一些事情发生，我们这个时候写数据会将过期键删除；</p><h2 id="内存溢出控制策略"><a href="#内存溢出控制策略" class="headerlink" title="内存溢出控制策略"></a>内存溢出控制策略</h2><p>Redis内存超过了<code>maxmemory</code>的时候，这个时候肯定要做很多事情，比如是不是要将原理的数据剔除？还是说现在根本就写不进去啊？类似于这样的事情；</p><h3 id="删除过期件"><a href="#删除过期件" class="headerlink" title="删除过期件"></a>删除过期件</h3><p>过期件删除有2种策略：</p><ol><li><p>惰性删除：在说惰性删除之前可以说一些Redis内核源码它对于key-value的一个管理它是这样的：对于多个key-value它会单独用一个hashtable进行一个存储，过期的key它也会使用一个单独的hashtable进行存储，也就是说我们get一个hello的时候它首先会去过期hashtable或者字典里面去查一下看这个key有没有过期，如果过期了它会将这个key删除，而且它还会做一件事情：把这个key返回一个空；如果在过期表里没有，它会从原生的hashtable里面去获取；</p></li><li><p>定时删除：为什么要做定时删除？有种可能我的key过期了，但是我下次没有去访问它，它会造成这个过期这个表会不断的扩大，我们可以想到的策略就是我定期对这个过期hashtable进行一个扫描，对于Redis来说它有一个定时删除的策略，它每秒运行10次来进行采样删除，它的删除策略是这样：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107212905506.png" srcset="/img/loading.gif" alt="image-20191107212905506"></p><p>对每个数据库随机选举20个键，它发现如果超过了百分25都是要过期的，它就会进行新的循环，进入更快的策略，进行一个删除，就是说它不会退出当前循环，而是进入二次的采样删除；如果它发现过期的比较少，那它就直接退出进入下一次循环</p></li></ol><h2 id="策略介绍"><a href="#策略介绍" class="headerlink" title="策略介绍"></a>策略介绍</h2><p>对于Redis内存的一个回收还有第二种：当你的使用内存超过了maxmemory，有一个配置来进行一个定义就是maxmemory-policy这样的内存策略，它的策略非常多，大概有5种，但是有很多是相似的：</p><ul><li>Noevication:它不会进行数据删除，比如说你现在有4GB，现在<code>used memory</code>超过了4GB，这个时候我在进行数据写入的时候我会返回给你一个错误：“(error) OOM command not allowed when used memory”，告诉你现在内存已经满了，不要去写入数据了；</li><li>Volatile-lru：根据LRU算法根据你最近使用比较少的一些key进行删除，这些key是相对来说不重要的，未来保证新的命令写入是成功的它采取这样的策略，这里它认为不重要的数据是过期表中的数据，哪些数据不重要呢?就是LRU算法，最近使用比较少的而且它是即将过期的，这样的话进行一个数据删除会比较稳妥，当然这样也可能删除一个重要的数据；</li><li>Allkeys-lru：在所有键中使用LRU算法进行删除；</li><li>Allkkeys-random：随机删除所有键，直到腾出足够空间为止；</li><li>volatile-random：随机删除过期键，直到腾出足够空间为止；</li><li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期的数据。如果没有，回退到noeviction策略。</li></ul><blockquote><p>在实际使用中要根据使用场景进行决定，假如我们真的不在乎所有数据是否丢失，那我们可以使用Allkeys-lru这样的策略，假如希望只在过期的数据集进行数据的删除可以使用volatile相关的策略，这里不太推荐使用默认的策略。当然默认的策略是可以的，它可以保证我的老数据不会丢失，新数据写入失败，对于大的互联网来说这个不是一个很通用的事</p></blockquote><h1 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h1><h2 id="内存分布"><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h2><blockquote><p>为什么要介绍内存分布？因为我们要做内存优化要优化哪些部分</p></blockquote><h3 id="内存消耗-2"><a href="#内存消耗-2" class="headerlink" title="内存消耗"></a>内存消耗</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191106200207592-1573041728497-1573135246853.png" srcset="/img/loading.gif" alt="image-20191106200207592"></p><p>回顾一下内存消耗，used_memory来说它有</p><ul><li>自身内存消耗，大概是800kb，</li><li>缓冲区内存包括客户端缓冲区包括客户端输入输出缓冲区有三种类型：普通客户端、slave、pubsub，输出缓冲区、输入缓冲区相对独立的；</li><li>对象内存：Redis中存了很多key-value，这个也是节省内存或者说内存优化的重头戏</li></ul><h2 id="合理选择优化数据结构"><a href="#合理选择优化数据结构" class="headerlink" title="合理选择优化数据结构"></a>合理选择优化数据结构</h2><p>前面提到了很多像客户端缓冲区，像aof缓冲区或者说复制缓冲区优化的余地不是特别多，它其实主要体现在普通客户端，你的命令的使用、合理的API使用，假如你使用不合理，假如说hgetall、monitor导致输出缓冲区比较大，这和你的QPS有关；</p><p>对于key-value的东西，我们最重要的是优化它的值对象，优化值对象就是说我们选择一个合理的数据结构，现在有一个简单的例子：现在有一个需求：要计算每天的独立用户数，实际上有很多方式，正确的方式比如说使用hadoop的一套东西设置日志，然后做每天的计算，现在假如说我当前这个需求不是这么大规模的，而是让你用Redis实现来达到比较快的目的，那你怎么去做呢？这里就有很多方式了：<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107221431230.png" srcset="/img/loading.gif" alt="image-20191107221431230"></p><ul><li>集合：这个很好理解，现在要记录每天独立用户数，那我们就用一个集合然后在加上一个时间标签把我们所以的ID放到这个集合当中，最终求出集合的总数，它会自动帮我们过滤掉有可能产生的独立用户数；</li><li>BitMaps：位图的话可以将每个用户去对应到位图中的位，如果这个位是1，就证明它出现过，然后它没有出现就是0，最后统计一下所有为1的个数就可以算出它的用户数；</li><li>HyperLogLog：通过这个来实现计数的方式，但是它有一个问题：它的最终结果可能不是准的。</li></ul><p>这里要根据用户场景来进行选择，这里举个例子：我们当前用户量非常大，每天有几个亿，但是我们统计大概有多少就可以了，而且我们要求内存使用非常低，那这个时候HyperLogLog是可以满足的，假如我们每天的用户数非常少，而且我希望保存下来所有的userId，这个时候HyperLogLog是不合理的它没法保存ID，这里完全可以使用集合或者BitMaps，BitMaps会节省很多内存，当然也有一个问题就是你BitMaps要跟你的userId做一个对应，这个时候可能会增加复杂度，甚至是说你BitMaps比较松散，BitMaps可能比较长，在你的userId比较松散的时候这个时候可能来说集合会用的小一些内存，这个也要做一个权衡，这是什么意思？假如你这个网站有10亿用户，每天就有10万人访问的话，显然用集合比BitMaps要好，因为你要给10亿人去做一个位图其实也是非常废内存的；</p><h2 id="合理选择优化数据结构-内部编码"><a href="#合理选择优化数据结构-内部编码" class="headerlink" title="合理选择优化数据结构-内部编码"></a>合理选择优化数据结构-内部编码</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107222103645.png" srcset="/img/loading.gif" alt="image-20191107222103645"></p><p>选择合理数据结构的另一种方式就是要做一个内部编码，这样我们选择的是一个合理的数据结构，下一个其实要选择编码，以哈希为例子，它有hashtable、ziplist两种模式，ziplist是压缩列表它就是用一个连续存储的列表来模拟hashtable的使用方式，当然其实我们可以想象出来用一个列表去模拟hash的方式它肯定会在存储速度上会比较慢，比如我们去做一个随机的获取或者插入，这种使用ziplist它必然需要做一个内存重写分配、指针位移类似这些东西，但是它要使用连续存储而且他要自身要做很多优化，这个时候可能它的内存开销上会有一些优势</p><hr><h3 id="一个例子、三种方案"><a href="#一个例子、三种方案" class="headerlink" title="一个例子、三种方案"></a>一个例子、三种方案</h3><p>需求：现在有很多图片id和用户id，大概有10亿个，我希望通过picId可以得到userId</p><p>方案：</p><ul><li>全部string：set picId userId；</li><li>一个hahs：hset allPics picId userId：把10亿个数据存储在一个hahs里面，这样做是有问题的，可能这是一个bigkey的问题，对于运维来说这个东西是一个很让人头疼的的东西；</li><li>若干个小hash：hset picId/100 picId%100 userId：对上面这种大的hahs进行拆分，给它拆分成若干个小的的hash，每一个小的hash里存100个field和value，这样的话我们就可以实现若干的小的hash，后面这种小的hahs我们会介绍，对于这种小的hahs，它就会使用ziplist这种存储方式，然后可以大量的节省内存</li></ul><p>现在看一下例子：假如现在只有100W张图片</p><h3 id="方案1："><a href="#方案1：" class="headerlink" title="方案1："></a>方案1：</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107223019036.png" srcset="/img/loading.gif" alt="image-20191107223019036"></p><p>picId和userId一一对应，它的使用内存为115.59M</p><h3 id="方案2："><a href="#方案2：" class="headerlink" title="方案2："></a>方案2：</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107223117730.png" srcset="/img/loading.gif" alt="image-20191107223117730"></p><p>内存开销129M</p><h3 id="方案3："><a href="#方案3：" class="headerlink" title="方案3："></a>方案3：</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107223141889.png" srcset="/img/loading.gif" alt="image-20191107223141889"></p><p>内存开销：26M</p><h3 id="3种方案对比"><a href="#3种方案对比" class="headerlink" title="3种方案对比"></a>3种方案对比</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107223241833.png" srcset="/img/loading.gif" alt="image-20191107223241833"></p><h3 id="消耗内存分析"><a href="#消耗内存分析" class="headerlink" title="消耗内存分析"></a>消耗内存分析</h3><p>将所有元素存在在一个连续的存储单元，减少了指针的使用，做了一些压缩的处理，这里不详细介绍ziplist的详细处理，有兴趣的读者可以去看ziplist的源码</p><p>（1）配置：</p><ul><li>hash-max-ziplist-entries 512</li><li>hash-max-ziplist-value 64</li></ul><blockquote><p>当hash数据结构小于512元素，也就是它的hlen小于512，而且这个元素中没有超过64字节的filed和value这个使用就会使用压缩列表ziplist来存储这个hash</p></blockquote><p>（2）ziplist（小和长度有限对象）</p><ul><li>连续内存</li><li>读写有指针偏移，最坏0(n的2次方)</li><li>新增删除有内存重分配</li></ul><p>使用连续存储，它在管理hash这样的方式必然会比较慢，这就是为什么它要限制个数的原因了，这是为了防止ziplist过大然后对性能产生影响，也就说最终是在性能和内存节省上做了一个权衡，这种还是比较好的一种方式，这里的配置建议不要设置过大，如果为了使用ziplist设置过大那可能你使用Redis速度快的目的就无法达到了</p><h3 id="三种方案优点对比"><a href="#三种方案优点对比" class="headerlink" title="三种方案优点对比"></a>三种方案优点对比</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107224230584.png" srcset="/img/loading.gif" alt="image-20191107224230584"></p><h2 id="客户端内存优化"><a href="#客户端内存优化" class="headerlink" title="客户端内存优化"></a>客户端内存优化</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>来看一下客户端缓冲区的优化，前面已经详细介绍了客户端缓冲区，我们已经清楚了它的结构，在这里我们只需要介绍一个例子，介绍一下客户端缓冲区在使用中可能出现的问题；</p><p>这里在来回顾一下客户端缓冲区：</p><ul><li>输入缓冲区：当输入缓冲区超过1GB的时候它会把你的连接直接干掉；</li><li>输出缓冲区有很多种类型：<ul><li>普通客户端缓冲区，它可以做一些限制</li><li>发布订阅缓冲区客户端缓冲区，它可以做一些限制；</li><li>复制缓冲区，它可以做一些限制；</li></ul></li></ul><h3 id="一次内存暴增"><a href="#一次内存暴增" class="headerlink" title="一次内存暴增"></a>一次内存暴增</h3><blockquote><p>这是以前遇见的问题</p></blockquote><p>我们当时用的是Redis Sentinel的架构，一主一从，然后有几个Sentinel节点，我们在使用过程做做了很多监控，例如我们在某一个节点发现这一对主从出现一个很奇怪的问题：主节点它的使用内存使用了4GB，已经超过了maxmemory，当时给maxmemory设置的是4GB，然后我们从节点是正常的，从节点是2GB，这种情况是怎么造成的？我们遇到这种问题的时候不要去着急，而是去想一下当前内存的组成，就是Redis的内存组成是什么？你可以脑子里去想，Redis内存有什么呢？</p><p>自身消耗：这个很小没有任何区别、缓冲消耗、数据消耗，这个时候会想一个问题就是说是不是因为我现在master的数据没有复制到从节点上，因为这样的情况可能会出现主节点的内存写进去了，但是从节点没有收到造成主从不一致，</p><p>这个时候要考虑到；还有一点就是缓冲：第一个缓冲“复制缓冲区”，这个我们是应该进行设置的，比如说100MB，这个它不会超过100MB，比如AOF缓冲区那我们可以检测硬盘是不是正常的，正常的情况下AOF不会被写满，当然这里就可能涉及到客户端的缓冲区，可能会涉及到客户端的输入，当然这里没有输入的问题，因为我们知道如果超过1GB的时候它会将你干掉，当然也不存在这种可能，</p><p>还有一个就是输出缓冲区：我们读主节点的时候，我们输出缓冲区发生了阻塞，</p><p>这些情况考虑了之后我们来看一下相关的数据</p><ol><li>批量写入：看看是不是有大批量的写入，当然我们看的时候没有看到有大批量的写入，所以可以排除数据的不一致造成内存的暴增<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107230034782.png" srcset="/img/loading.gif" alt="image-20191107230034782"></li><li>主从不一致？在主从节点上都执行DBSIZE，2个都是一样的<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107230112099.png" srcset="/img/loading.gif" alt="image-20191107230112099"></li><li>大部分情况都是客户端的溢出，我们系统比较好的是对所有Redis核心参数进行了监控，比如我们前面提到的<code>client_longst_output_list</code>，它的最大输出缓冲区的对列，我们给它设置的阈值是1000，这个时候发现，某某节点已经道到了23W<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107230447499.png" srcset="/img/loading.gif" alt="image-20191107230447499">，很明显客户端的输出缓冲区过大，这个值给我们提供了一个依据，我们可以使用之前我们介绍的<code>redis-cli list | grep -v “omem=0”</code>命令，<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107230455740.png" srcset="/img/loading.gif" alt="image-20191107230455740"><br>有这么一个客户端它的oll是20W，当然它和23W不一样是因为这是一个实时的状态，发现它内存的使用量是非常大的，我们可以看到它当时执行的命令是“monitor”，很明显它就是有一个人或者一个程序去执行了monitor去拉所有Redis执行的命令，然后它本身又消费不了，而且当时看到它当时在本机执行的，任然是消费不了，这个时候我们可以对这个monitor命令执行删除，让内存进行一个回收，当然其实这里有 一个问题就是说你现在主节点已经超过了最大内存，可能会产生<code>maxmemory-policy</code>内存溢出的情况</li></ol><p>我们来回顾一下Monitor模型</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191107231052717.png" srcset="/img/loading.gif" alt="image-20191107231052717"></p><p>现在对Redis进行写入或者查找很多一些命令，它会将那些命令全部和到monitor的客户端，然后就就造成monitor这个客户端如果消费不了就会造成monitor客户端缓冲区非常大，对于Redis总体内存造成很的干扰；</p><h3 id="预防策略"><a href="#预防策略" class="headerlink" title="预防策略"></a>预防策略</h3><ol><li>找到对应的业务放直接干掉；</li><li>预防：<ul><li>运维层面：线上Redis禁用monitor（rename-command）；</li><li>运维层面：适度限制缓冲区大小，它是一个普通客户端缓冲区，默认是0 0 0 ，我们如果希望能不出现这样的情况，我们可以给它设置比如最大10M、100M这样的的东西</li><li>开发层面：理解monitor的原理，也可以短暂寻找热点key（本地执行）</li><li>开发层面：使用CacheCloud可以直接监控到。</li></ul></li></ol><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><ol><li>不要忽视key长度：1亿个键，1个字节也是节省（键名：简短明了）<pre><code>user：friends：notify：{id}     ——&gt; u：f：n：{id}</code></pre></li><li>序列化和压缩方法：解决java原生，采用protobuf、kryo、snappy等。</li></ol><h3 id="需不需要Redis？"><a href="#需不需要Redis？" class="headerlink" title="需不需要Redis？"></a>需不需要Redis？</h3><ol><li>数据：大数据、冷数据：这类数据不适合放Redis中；</li><li>功能性：关系型查询、消息队列：不建议用Redis进行处理，因为Redis本身不是关系型数据库</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>内存是宝贵资源；</li><li>结合场景选择和优化数据结构；</li><li>序列化是有成本的；</li><li>不要忽视键长度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 13.Redis开发范式</title>
    <link href="/redis-13.html"/>
    <url>/redis-13.html</url>
    
    <content type="html"><![CDATA[<h1 id="键值设计"><a href="#键值设计" class="headerlink" title="键值设计"></a>键值设计</h1><p>一个良好的键值设计是使用Redis的保障，这里涉及到2个部分</p><ul><li>Key名设计：遵守一些规范，在键值可管理性、可读性、键值长短的管理性上会有一定要求，这样可以达到很好的效果，比如内存使用量比较小，或者键值的可读性可管理性比较高；</li><li>Value设计：在使用KV缓存或者多存储的时候，最重要的是value里面会有多种类型，它可能会影响到Redis的使用量或者说是网络的使用情况，或者像Redis是否发生阻塞的情况，都会影响</li></ul><h2 id="Key名设计"><a href="#Key名设计" class="headerlink" title="Key名设计"></a>Key名设计</h2><h3 id="三大建议"><a href="#三大建议" class="headerlink" title="三大建议"></a>三大建议</h3><ul><li>可读性和可管理性：可读性，通过一个key的名字能了解它是什么意思；可管理性：删除某些命名开头所有的key,按照这种规则，比如我们希望以A开头的这种key做什么事情，可以达到一个可管理的水平；以业务名（或数据库名）为前缀（防止key）冲突，用冒号分割，比如业务名:表名:id，如:<code>ugc：video：1</code>；</li><li>简洁性：保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视（redis3：39字节<code>embstr</code>），如：<code>user：{uid}:friends：messages：{mid}</code>简化为<code>u：{uid}:fr：m：{mid}</code>，这里说的redis3，39字节是什么意思？在Redis3这个版本里有3种表达字符串的内部编码，一种是原生的、int的，还有一种是<code>embstr</code>，在使用<code>embstr</code>这种情况下它会对内存造成很大的节省；</li><li>不要包含特殊字符：反例：包含空格、换行、单双引号以及其他转义字符。</li></ul><h3 id="embstr"><a href="#embstr" class="headerlink" title="embstr"></a>embstr</h3><p>确定自己的Redis版本是3</p><pre><code class="hljs bash">127.0.0.1:6379&gt; info server<span class="hljs-comment"># Server</span>redis_version:3.0.7</code></pre><p>查看内部编码</p><pre><code class="hljs bash">127.0.0.1:6379&gt;  <span class="hljs-built_in">set</span> k1 v1 OK127.0.0.1:6379&gt; object encoding k1<span class="hljs-string">"embstr"</span>127.0.0.1:6379&gt; incr counter (<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; object encoding counter<span class="hljs-string">"int"</span>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a sadlfasdhfasdklfhsadfOK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> a sadlfasdhfasdklfhsadfasdfasdfasdfasfdasfdasdfOK127.0.0.1:6379&gt; object encoding a<span class="hljs-string">"raw"</span></code></pre><p>对于Redis来说它的它对外有5种数据结构但是每一种数据结构又有自己的内部编码，对于外部的话，它实际上是一个string</p><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> k1string127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> astring127.0.0.1:6379&gt; <span class="hljs-built_in">type</span> counterstring</code></pre><blockquote><p>那么它内部的规则是什么？不然像counter这种自增的，它是一个整数的话它会用int进行存储，一些短字符串像k1它低于39个字节的字符串它会使用embstr，大于39字节的使用row，embstr的优化：Redis在分配内存的时候，除了给Redis的对象做一个分配运算，还要给具体的一个内容做一个分配，对于embstr的话它是将Redis Object以及字符串的类容是放到一次分配当中，而且是一个连续的内存，这样的话可以节省分配内存的次数，而且可以节省一定的空间，对于小于39字节的话，它会用embstr进行存储，这样可以减少一定的内存开销</p></blockquote><p>现在做一个例子</p><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> hello  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<span class="hljs-comment">#39字节</span>OK127.0.0.1:6379&gt; object encoding hello<span class="hljs-string">"embstr"</span>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> hello1  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <span class="hljs-comment">#40字节</span>OK127.0.0.1:6379&gt; object encoding hello1<span class="hljs-string">"raw"</span></code></pre><p>从这个例子中，如果在设计key的时候，把key控制在一定长度的内，这样可以达到内存节省的一定效果，在Redis4中它做了一些改变，因为它会Jedis内部的一个字符串实现做了一些优化，这个时候它只要小于44个字节就好了，但是在Redis3中是要小于39个字节的</p><p>Redis3 embstr测试</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104200407985.png" srcset="/img/loading.gif" alt="image-20191104200407985"></p><h2 id="Value设计"><a href="#Value设计" class="headerlink" title="Value设计"></a>Value设计</h2><h3 id="拒绝bigkey"><a href="#拒绝bigkey" class="headerlink" title="拒绝bigkey"></a>拒绝bigkey</h3><p>定义</p><ul><li>string类型控制在10KB以内，超过了就算是bigkey；</li><li>hash、list、set、zset元素个数不要超过5000，如果超过了认为是bigkey，bigkey是什么？它的key的value是比较大的，注意这里我们的定义并不是说有一个国际标准、官方认证，而是我们希望你的Redis中的value要尽量小，value小的话会有一定好处，如果你的value过大会有很多很多问题，这些问题留着后面再将，这些标准是阿里云发布的标注，对于运维人员来说其实这样一个标准可以保证我们Redis的一个运维是可以足够顺畅的，比如说我们一个Redis实例非常多，可能都是单机混部的情况对于运维人员来说你有一个这样的标准对于运维来说可以有很大的帮助，对于开发人员来说你要严格要求自己不去越过这个红线，其实对于key定义每个公司都是不一样的，比如可以定义1KB一下的甚至100KB以下的都可以认为是一个合理的标准，这个是按照不同公司要求来看的；<ul><li>反例：一个包含几百万元素的list、hash等，一个巨大的josn字符串；</li></ul></li></ul><h3 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h3><h4 id="网络阻塞"><a href="#网络阻塞" class="headerlink" title="网络阻塞"></a>网络阻塞</h4><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104202723564.png" srcset="/img/loading.gif" alt="image-20191104202723564"></p><p>我的一个机器可能现在部了很多Redis，因为Redis是单线程的，无论是一些云厂商或者一些公司实际上都是在单机部署多个Redis实例，由于使用Redis，可能会有一些千兆网卡，说是千兆网卡，实际上它要除以8，对应的128MB字节，这个时候如果我们Redis存在了bigkey，比如我的Redis里有一个key是5MB，意味着我这个key的QPS达到了30，它就会瞬间超过最大的带宽，那会有什么问题呢？它会将当前Redis阻塞掉，因为我们去共享一份机器总共的带宽的，还有一个问题：单机多部署的话那你会影响其他Redis带宽，这么小的一个QPS由于你这么一个bigkey或者大对象的存在，它会将Redis阻塞而影响其他Redis，那就意味着影响很多业务，就这么小的东西可能会有致命的灾难，假如我们一个key是10KB，对于一些热点key，像新浪微博发布的一些重要消息、一些明星发布的重要消息，假如你的key只有1KB,那比如说QPS非常高，达到了1千、1万、10万、100万这样的级别可能危害就更大了，一瞬间将你机器带宽吃满，影响其他业务，影响自己，这个危害是非常大的；</p><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104202708182.png" srcset="/img/loading.gif" alt="image-20191104202708182"></p><p>hgetall、lrange、zrange（例如几十万）：它在做一些全量操作的时候可能会比较慢，它除了说这个网络流量比较大，它还有就是比较慢，Redis是一个单线程的设计模式，你这一个bigkey的命令可能会阻塞其他命令，因为你的hgetall几百万个元素上去执行，它的速度是非常慢的，我们这里不考虑它的一个网络阻塞的问题，只单纯去看命令的问题它也是非常慢的，意外着如果我们QPS非常高，比如QPS是3万，然后我这一个命令执行了2秒，那就意味着你这1秒的3万个命令全都会被阻塞掉；</p><h4 id="节点数据不均衡"><a href="#节点数据不均衡" class="headerlink" title="节点数据不均衡"></a>节点数据不均衡</h4><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104202818862.png" srcset="/img/loading.gif" alt="image-20191104202818862"></p><p>对于一些使用RedisCluster集群这种分布式的形式，如果你的数据相当于分配到多个Redis节点上，因为我们的key只能落在一个节点上，那如果存在bigkey的情况下，那可能会出现像图中这种，各各节点的对象数差不多，但是它的内存使用量是不一样的，有一个节点的内存它的使用量明显会大于其他节点，对于我们管理Redis集群来说是非常不方便的，因为我们在管理的时候希望用一个通用的模式，比如说我们需要64GB的内存，可能就是8x8的节点，甚至16x4节点的分配，这样会对我们的管理造成影响</p><h4 id="反序列化消耗"><a href="#反序列化消耗" class="headerlink" title="反序列化消耗"></a>反序列化消耗</h4><p>这是一个不是很常见的问题</p><ol><li>Redis客户端本身不负责序列化；</li><li>应用频繁序列化和反序列bigkey：本地缓存或Redis缓存。</li></ol><p>Redis客户端不做序列化和反序列工作的，Jedis就没有提供这样的功能，它在你开发的时候需要传入的是字节数组，如果我们要做序列化和反序列化，比如做一个字符串类型的序列化、反序列化的对象，这个时候就需要操作去操作这个bigkey，假如这个对象是一个非常大的对象就意味着要消耗很多CPU，假如你的QPS非常高，在某一个节点上非常高消耗很多CPU，下面这张图就是我们之前线上业务发现的bigkey，它频繁的序列化和反序列化，会造成Java这样的应用的进程CPU非常非常高，最终通过一些手段去对位这样的问题，Redis bigkey有很多很多问题，如果你设计的不好，可能会造成若干个这样的情况；</p><h1 id="bigkey发现"><a href="#bigkey发现" class="headerlink" title="bigkey发现"></a>bigkey发现</h1><ul><li><p>应用异常：一些超时，这个不是很明显，但它也是第一个有关的原因；</p></li><li><p>redis-cli –bigkeys：Redis官方提供的工具；</p></li><li><p>scan+debug object： 如果上面工具没有达到要求，比如一些定制化的参数，我们可以自己去实现，比如使用scan+debug object</p></li><li><p>主动报警：网络流量监控、客户端监控<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104204606546.png" srcset="/img/loading.gif" alt="image-20191104204606546"></p></li><li><p>内核热点Key问题优化<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104204833399.png" srcset="/img/loading.gif" alt="image-20191104204833399"></p></li></ul><h2 id="应用方发现"><a href="#应用方发现" class="headerlink" title="应用方发现"></a>应用方发现</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104204144087-1572871319822-1572871749637.png" srcset="/img/loading.gif" alt="image-20191104204144087"></p><h2 id="redis-cli-–bigkeys"><a href="#redis-cli-–bigkeys" class="headerlink" title="redis-cli –bigkeys"></a>redis-cli –bigkeys</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104204214452-1572871773909.png" srcset="/img/loading.gif" alt="image-20191104204214452"></p><blockquote><p>但是它这里不能设定多大是bigkey，这行这个命令的时候建议在slave节点上执行，因为它本身是去做一些扫描和一些计算的，最好是在本地执行，这样执行速度会很快，用网络一台机器扫描另一台机器的话仍然是需要消耗很多时间的</p></blockquote><h2 id="scan-debug-object"><a href="#scan-debug-object" class="headerlink" title="scan + debug object"></a>scan + debug object</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104204541652-1572872169550.png" srcset="/img/loading.gif" alt="image-20191104204541652"></p><p>对于上面图中的演示，有一个问题就是说我们无法定义比如1KB以上的是bigkey还是10KB以上bigkey，还有它的元素个数多大的bigkey，它是没法定义的，这里就可以使用一些Redis命令来实现</p><h2 id="主动报警"><a href="#主动报警" class="headerlink" title="主动报警"></a>主动报警</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104205633736.png" srcset="/img/loading.gif" alt="image-20191104205633736"></p><p>对Redis所有的info信息做一个收集，比如一分钟收集一次、秒级监控然后存在到我们对应的位置，或者直接实时做一个监控，当它超出我们的预期，比如说像输出流量超出我们的预期了，就会可能出现类似bigkey流量的问题，这个时候可以去重点关注一下，当我们手里的证据越多，那我们发现问题就更快，因为我们发现有些人解决问题比较快，当然它的理论知识很强，也可能是因为他手里有更多的证据或者它有更好的工具</p><h2 id="内核统计"><a href="#内核统计" class="headerlink" title="内核统计"></a>内核统计</h2><p>这个可能会涉及更加深一点，其实原理很简单，在Redis内部去设置一个类似于堆的概念，通过它去完成top key的问题，最大的10多20个，我们可以设置这样的参数，每次当有key变更的时候我们去维护这个堆，这样我们也可以找到那些bigkey，它有一个优势：我们前面通过扫描它的过程比较慢，因为我们每次都要去扫描，然后拿一个结果，非常非常慢，如果有几亿个key就不用说快了，它达不到一个效果就是说我们在对所有Redis进行集中管理，比如现在有一万个Redis节点，我希望每小时去拿到bigkey的信息，基本上对于这种情况是无法完成的，因为每次任务就非常长而且Redis实例非常多，这个你做一个调度系统也很难去完成这样的任务，那假如说我Redis内部就可以吐出这样的信息，不需要每次都做很复杂的计算，这样会有很好的优势，当然这对Redis本身的维护成本会高一些，因为你需要对Redis源码进行修改，这里会涉及到很多问题，一个是你修改的靠不靠谱，另一个就是说你更官方的毕竟是不一样的，这样在后期维护上会有一些问题，尤其是当我们管理的Redis比较多如果你只管一个Redis那你可以进行修改，可能管理一万个、1千个可能你一个小的改动、一个小的错误会影响大部分的业务，这个时候你要考虑一个问题，要不要做那样的事情 </p><h1 id="bigkey删除"><a href="#bigkey删除" class="headerlink" title="bigkey删除"></a>bigkey删除</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><blockquote><p>注意隐性删除（过期、rename等）</p></blockquote><p>前面了解了bigkey的危害以及如何去发现它，当我们确定要对bigkey进行删除的时候，我们要做很多的操作，有人说直接将它del掉就可以了，因为Redis中所有的kv删除命令都是del操作，但其实这里有一个问题：当你的bigkey非常大的时候它的删除速度会非常慢，</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104220646084.png" srcset="/img/loading.gif" alt="image-20191104220646084"></p><p>上面这张表是通过测试得出来的结论，这里以一个例子来说，假如要删除的类型是hahs，现在有100万个field和value，每一个field和value是128字节这其实对应图中，就是说删除这一个hash，可能需要2000毫秒，为什么这么慢呢？因为它的删除要将field和value一个个进行删除的，其实Redis中hash可以是hashtable、ziplist，但是它元素非常多的时候肯定是hashtable，实际上和我们删除Redis是一样的，因为Redis本身就是一个hashtable，它删除速度非常慢，那就有一个问题：Redis是单线程的，你删除这么一个键就会阻塞掉很多Redis访问；还有一个问题：一些隐性删除（过期、rename等），隐形删除是什么意思？这是以前碰到的例子，假如说我没有手动去删除这个过期件，而是通过Redis自动来完成的，比如说像过期，假如我们给Redis的一个hahs设置过期时间，这个hash的field有100万、200万，比如让它每天晚上去过期，其实过期是一样的，无论是你通过Redis的主动过期还是被动过期去将它删除掉都是要进行一个删除操作的，它背后也对应的是一个del操作，它会在那个时间点会阻塞掉你的Redis；而且这里还有一个更严重的问题：过期删除这个命令本本身它不会记录在Redis慢查询当中，因为Redis慢查询是记录客户端产生的行为，而这个只是记录在Redis的延迟事件类型中，但是有一个好处就是它会将删除的命令同步给从节点，因为从节点对应Redis它是一个伪装的客户端，你这个时候通过从节点的慢查询找到这样的数据然后去定位这样的问题，所以这里你要做的就是主从节点计量的要收集它的慢查询；</p><h2 id="Redis-4-0：lazy-delete-（unlink命令）"><a href="#Redis-4-0：lazy-delete-（unlink命令）" class="headerlink" title="Redis 4.0：lazy delete （unlink命令）"></a>Redis 4.0：lazy delete （unlink命令）</h2><p>它可以将所有的删除命令做一个后台删除，相当于删除一bigkey的时候我们可以执行一个后台删除，后台会单独有一个线程去帮我们做这样的事情，它就不会阻塞掉Redis主线程，如果你想使用这样的功能，可以把Redis更新到4.0版本</p><h2 id="bigkey删除方法"><a href="#bigkey删除方法" class="headerlink" title="bigkey删除方法"></a>bigkey删除方法</h2><p>对于Redis4.0以下的版本，我们怎么去做呢？这里可以通过scan来完成</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104222834988.png" srcset="/img/loading.gif" alt="image-20191104222834988"></p><p>无论是hash的hscan或者是set的scan我们都可以扫描这样的bigkey，然后对它做一个子删除，比如说像hash的hdel，包括像set的sremove这样的操作，最后我们循环遍历这样的bigkey，最终当它的游标设置为0的时候就将它返回，但是这里要注意：最终要删除这个bigkey</p><h2 id="bigkey预防"><a href="#bigkey预防" class="headerlink" title="bigkey预防"></a>bigkey预防</h2><h3 id="优化数据结构"><a href="#优化数据结构" class="headerlink" title="优化数据结构"></a>优化数据结构</h3><p>假如说我们真的要在Redis中有这样的bigkey，如果你真的删除不了，我们可以考虑将它做一个拆分，比如说我们可以按让日期拆分，假如有的人存了一个大的list，实际上它是按天来存的，它有个时间戳的属性，那这个时候我们完全可以给它做一个二级拆分比如说按天、按小时这样就不会有bigkey的问题，甚至像hash这样的类型，我们可以做一些二级hash的处理，后面讲Redis使用合理数据结构的时候会介绍一个类似的例子；</p><h3 id="物理隔离或者万兆网卡：不是治标方案"><a href="#物理隔离或者万兆网卡：不是治标方案" class="headerlink" title="物理隔离或者万兆网卡：不是治标方案"></a>物理隔离或者万兆网卡：不是治标方案</h3><p>还有一些方法的话，它不是解决根本问题的方法，比如说我们可以对有bigkey的Redis做一些物理隔离，甚至让它使用万兆网卡，这样的话可以减轻像网络阻塞的问题，但是任然这里不是解决问题的根本方法</p><h3 id="命令优化"><a href="#命令优化" class="headerlink" title="命令优化"></a>命令优化</h3><p>我们有bigkey，我们可以使用一些轻的命令，比如说我们在使用hash的时候，我们真的需要使用hgetall吗？能不能通过hmget、hscan指定获取需要的属性；</p><h3 id="报警和定期优化"><a href="#报警和定期优化" class="headerlink" title="报警和定期优化"></a>报警和定期优化</h3><p> 运维人员将Redis的bigkey定期做一个收集，然后发送到各各业务端，各各业务端定期发现这个问题之后会做各自的修复，这样在总体的管理Redis上会有很好的帮助；</p><h3 id="bigkey总结"><a href="#bigkey总结" class="headerlink" title="bigkey总结"></a>bigkey总结</h3><ul><li>牢记Redis单线程特性；</li><li>选择合理的数据结构和命令；</li><li>清楚自身的OPS和QPS防止出现网络阻塞、阻塞问题；</li><li>了解bigkey的危害。</li></ul><h1 id="合适的数据结构"><a href="#合适的数据结构" class="headerlink" title="合适的数据结构"></a>合适的数据结构</h1><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>例如我们在设计kv的时候，要选择一个合理的数据结构，比如我们使用hahs、字符串、set、zset，实际上每种数据结构都有自己的特点，我们在选择的时候需要注意两点：</p><ul><li>选择合理的数据结构，我们是使用哪种数据结构？</li><li>选择数据库的编码，我们希望能达到某种类型的一个内存，比如内存和性能的最大化</li></ul><p>首先来看第一个问题，这个用一个例子说明：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104224658186.png" srcset="/img/loading.gif" alt="image-20191104224658186"></p><p>假如现在我的数据表是这样的，一个用户数据表有4个属性，分别是它的邮件、名字、密码、序号，它对应我们一个选择数据结构的时候可能会有2种设计，</p><p>第一种：<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104224545458.png" srcset="/img/loading.gif" alt="image-20191104224545458"></p><p>我们给每个属性也就是user：1然后它的name设置一个名字，然后user：1的age设置一个属性类似于这样；</p><p>第二种：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104224648877.png" srcset="/img/loading.gif" alt="image-20191104224648877"></p><p> 使用hash，将关系型数据库进行倒装，比如说我们将它的每一列作为field，它的每一个值作为我们的value，然后它的数据库名或者表名作为它的key，然后它的id作为它的keyt的后缀，相当于我前缀对应数据库名+表名然后一个冒号然后再加上它的id，在设计这种数据结构的时候我们通常会使用第二种，使用hash会有几个好处：</p><ul><li>保证key不是一个松散的，user：1是一个完全的整体，如果使用上面这种情况下它不是一个整体，而且我们在使用像hash的时候如果使用了像ziplist,满足ziplist的条件还可以达到节省内存的效果</li></ul><h2 id="一个例子、三种方案"><a href="#一个例子、三种方案" class="headerlink" title="一个例子、三种方案"></a>一个例子、三种方案</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>picId=&gt;userId（100万），这里需要通过图片id去找到用户id这样一个映射，比如用户发了很多图片，然后就有一个picId和userId的映射</p><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul><li>全部string：set picId userId</li><li>设置一个大的hash，hset allPics picId</li><li>若干个小的hash，我们对应一个key的话就是 hset picId/100 picId%100 userId</li></ul><p>来看下这3种方案的内存使用</p><p>方案1：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104225828520.png" srcset="/img/loading.gif" alt="image-20191104225828520"></p><p>第一种很明显，张图图可以看出来，就是key和value的字符串类型，当我们设置100万个的时候：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104225834735.png" srcset="/img/loading.gif" alt="image-20191104225834735"></p><p>方案2：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104225852146.png" srcset="/img/loading.gif" alt="image-20191104225852146"></p><p>这种方式很明显就是一个bigkey，一个100万个元素的hash，</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104225927443.png" srcset="/img/loading.gif" alt="image-20191104225927443"></p><p>这样非常占用内存，它的设计方案也很有问题。</p><p>方案3：</p><p>拆分成这样：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104230054990.png" srcset="/img/loading.gif" alt="image-20191104230054990"></p><p>每一个hash key有100个field和和value，这样我可以将一百万个picId和userId拆成一万个小的hash就是这样的设计模式，key就是100万个picId每个picId除以100，field就是picId去取一百的余，这样就可以将这个大的picId和userId拆成若干个小的hash，内存使用量：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104230328603.png" srcset="/img/loading.gif" alt="image-20191104230328603"></p><h3 id="3种方案内存对比"><a href="#3种方案内存对比" class="headerlink" title="3种方案内存对比"></a>3种方案内存对比</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104230411636.png" srcset="/img/loading.gif" alt="image-20191104230411636"></p><p>第1种和第2种是类似的，第3种它可以达到很惊人的内存使用效果，甚至可以达到缩小4-5倍的效果</p><h3 id="3种方案内存分析"><a href="#3种方案内存分析" class="headerlink" title="3种方案内存分析"></a>3种方案内存分析</h3><p>为什么第3种方案占用内存比较小？</p><p>对于Redis来说它支持很多内存优化方案，对于hash类型的话，它对外是hash类似，它内部有很多编码，比如hashtable、ziplist</p><p>配置（支持动态修改）</p><ul><li>hash-max-ziplist-entries 512</li><li>hash-max-ziplist-value 64</li></ul><p>ziplist</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104230718916.png" srcset="/img/loading.gif" alt="image-20191104230718916"></p><p>连续内存存储，减少了很多指针以及连续内存产生的碎片的问题，而且它是一个连续存储之后，它首先会节省很多内存，但是它会有一个问题，它的操作复杂度会比较高，它的读写指针的位移并且你新增添加删除的时候会有一个内存的重分配，还有你寻找会比较慢，这种数据结构的话是有一个权衡，在使用这种数据结构的时候要考虑元素个数，如果元素个数少，或者一个大的一个value的时候，那它的一个内存和性能做一个平衡，我们宁可用更少的内存稍微多一点性能来换取内存的最大化，其实对应上面2个配置，也就是当我们元素少于512并且filed value没有大于64字节的元素的时候，那我们Redis会默认选择使用ziplist来存储这样的hash结构，也就说我们会用更少的内存来存储hash结构，对于刚才例子中看到了每一个field-value是100个它是满足512个的，然后64个字节也一样，我的每个filed-value字节数比较少的，当然这个你是可以动态调整的，比如config set来进行调整，但是一定要注意：我们在性能和内存上一定要做一个均衡，不能说我给它设置成5120，这样的话我们是使用了ziplist，但是它的性能会下降，会导致QPS不是很高而且CPU使用非常高的情况</p><h3 id="3种方案优缺点对比"><a href="#3种方案优缺点对比" class="headerlink" title="3种方案优缺点对比"></a>3种方案优缺点对比</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191104231550306.png" srcset="/img/loading.gif" alt="image-20191104231550306"></p><h1 id="键值生命周期的管理"><a href="#键值生命周期的管理" class="headerlink" title="键值生命周期的管理"></a>键值生命周期的管理</h1><h2 id="Redis不是垃圾桶"><a href="#Redis不是垃圾桶" class="headerlink" title="Redis不是垃圾桶"></a>Redis不是垃圾桶</h2><p>Redis对于开发人员是非常好用的，它可以将hash、set、zset、list这样的数据结构和开发语言中的数据结构做一个完美的映射，它非常方便，造成很多开发人员使用Redis的时候会胡乱使用，比如：什么东西都往Redis放，而且他还不会控制Redis生命周期给key设置过期时间，比如Redis缓存一个key应该是要在一定时间进行删除的，或者在一定时间都没有用了但是它因为没有设置过期时间这样造成Redis一直保留那些数据，不仅包括说Redis去要不断的去扩容，这样的话它的量非常大，还有它使用的时候会比较混乱。</p><hr><p>对于生命周期的数据，我们需要对周期数据做一个缓存或者过期时间的设置，Redis支持expire这样的命令，但如果我们对一个现有的Redis，希望找到多少年多少月多少周期使用的数据，这样的数据我们可以利用<code>object idle time</code>命令找到key-value的闲置时间，比如有一个数据30天没使用了，我们可以利用这个报告发送给开发人员或者开发人员自身去扫描scan这样的key，自身去进行优化，这对于管理Redis是非常有帮助的</p><hr><p>在设置过期时间的时候，比如都设置在3小时后过期或者每3小时过期一次，然后过期之后通过数据库进行重建，这样很可能产生缓存穿透和雪崩问题，过期在集中产生的时候可能会集中去访问数据库或者底层数据源，这样会造成缓存集中去穿透，造成底层数据源无法承受这么大的并发量造成雪崩</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191105193911373.png" srcset="/img/loading.gif" alt="image-20191105193911373"></p><p>上面这张图显示的是一个数据库，它有在周期的时间内会发现负载非常高，这里就可能是因为过期时间设置比较集中造成的</p><h1 id="命令优化技巧"><a href="#命令优化技巧" class="headerlink" title="命令优化技巧"></a>命令优化技巧</h1><h2 id="【推荐】0-N-以上命令关注N的数量"><a href="#【推荐】0-N-以上命令关注N的数量" class="headerlink" title="【推荐】0(N)以上命令关注N的数量"></a>【推荐】0(N)以上命令关注N的数量</h2><ul><li>例如：hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值，假如你的N是几百或者一千以下实际上也没有太大的影响，其实如果你的键值或者filed和value非常大的时候你要考虑一个问题：能不能使用一些命令来进行遍历，比如使用hscan、sscan、zscan进行代替，这里意思是说使用大的命令时你要关注你使用的命令是不是一个真的大命令；</li></ul><h2 id="【推荐】禁用命令"><a href="#【推荐】禁用命令" class="headerlink" title="【推荐】禁用命令"></a>【推荐】禁用命令</h2><p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><h2 id="【推荐】合理使用select"><a href="#【推荐】合理使用select" class="headerlink" title="【推荐】合理使用select"></a>【推荐】合理使用select</h2><p>redis有很多数据库，它默认给你16个数据库，你可以使用select 0、select 1进行数据库切换，数据库之间逻辑上是可以进行区分的，也就是说我可以在数据库0中设置key为hello，value为world，在第2个库里设置hello是abc，这两个库之间是没有干扰，这样可以做一些业务逻辑的隔离，而且还可以防止干扰，比如说可以在一些测试环境上用一个单独的数据库，但是Redis对数据库比较弱，因为它用数字进行区分；</p><hr><p>很多客户端对select支持差，像select 0、select 1这些，很容易造成一些问题，比如说你切换切换自己都不知道切换到哪里去了</p><hr><p>它的隔离只是逻辑上的隔离并不没有做成进程之间的隔离，它只有一个进程而且任然是一个单线程的处理，比如说你在0号数据库正常业务去执行那你在1号数据库去执行很大的命令它依然会阻塞0号数据库，所有在使用的时候一定要注意而且你在大的业务上去使用select的时候频繁的切换对于Redis也会有一定性能的消耗，它比较占QPS</p><h2 id="【推荐】Redis事务功能较弱，不建议过多使用"><a href="#【推荐】Redis事务功能较弱，不建议过多使用" class="headerlink" title="【推荐】Redis事务功能较弱，不建议过多使用"></a>【推荐】Redis事务功能较弱，不建议过多使用</h2><p>Redis是支持简单事务的，但是它的事务功能非常弱它不支持回滚，这个就不是一个完整的事务，所以你在使用Redis的时候，如果有事务的需求，建议不要使用Redis自带的事务，而是使用像一些开发语言像Spring自带的一些事务来进行完成，或者借助一些外部来实现；</p><hr><p>在集群中有一个要求：在所有事务中使用一个命令必须是要在一个slot上，比如在使用RedisCluster要求在一个事务中操作的所有key必须是一个在一个slot上，这里无法控制slot和key的对应关系，因为对于key落在哪个slot上我们是无法控制的，如果真的要使用这样的功能建议去使用<code>hashtag</code>，它能保证所有的key是落在一个slot上，但是这样也会有一些问题比如说造成key不均匀</p><h2 id="【推荐】Redis集群版本在使用Lua上有特殊要求"><a href="#【推荐】Redis集群版本在使用Lua上有特殊要求" class="headerlink" title="【推荐】Redis集群版本在使用Lua上有特殊要求"></a>【推荐】Redis集群版本在使用Lua上有特殊要求</h2><p>Redis支持Lua，Lua可以自研很多命令，比如将很多命令进行一个组合来实现一个原子性的操作，它可以完成很多特殊的需求，它是很有帮助的东西，但是Lua有一个严格的要求，比如说你在Redis上使用的不合理，一些写超时会造成需要重启Redis这样一些问题，个人认为Lua在Redis上使用是一个鸡肋，作为运维人员来或者开发人员在使用的时候一定要注意很多问题：</p><ul><li>所有key，必须在1个slot上，否则直接返回error；</li><li>“- ERR eval/evalsha command keys must in same slot\r\n”；</li></ul><p>建议不要过分去使用Lua，如果你真的需要去过分使用建议单独去开一个Redis来做这样的事情，而且不要使用集群来降低Lua对Redis造成的危害</p><h2 id="【建议】必要情况下使用monitor命令时，要注意不要长时间使用"><a href="#【建议】必要情况下使用monitor命令时，要注意不要长时间使用" class="headerlink" title="【建议】必要情况下使用monitor命令时，要注意不要长时间使用"></a>【建议】必要情况下使用monitor命令时，要注意不要长时间使用</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191105201307817.png" srcset="/img/loading.gif" alt="image-20191105201307817"></p><p>monitor可以将Redis的命令实时监控，比如像Redis执行了哪些命令，我们可以使用monitor命令进行监控，这样的话可以监控是哪个IP执行的、执行哪些命令在什么时候执行的，但是要注意一个问题，上面这张图就是Redis monitor的一个模型，任何客户端在Redis执行命令都会同步给monitor客户端，如果我们并发量非常高，所有的命令都打到monitor客户端上就会造成问题，monitor命令它无法实时去消费所有命令，就会造成monitor客户端它也是一个普通的Redis客户端的一个输出缓冲区，它的输出缓冲区会暴增，这个输入缓冲区会占用Redis的内存，也是说它可能会将Redis内存撑爆，所以不建议使用这样的东西，如果你真的要去使用它，那建议去短时间去使用，比如你使用几秒、一分钟，最重要的是你要在本地去执行，这样可以提高我们客户端消费速度不至于出现内存暴增的情况。</p><h1 id="客户端优化"><a href="#客户端优化" class="headerlink" title="客户端优化"></a>客户端优化</h1><blockquote><p>这里使用Java客户端来进行说明</p></blockquote><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>避免多个应用使用一个Redis实例</p><p>假如现在我业务A和业务B，然后现在有一个Redis，业务A使用Redis，业务也用Redis，现在他们用同一个实例，这样有几个问题：</p><ol><li>可能会造成key冲突；</li><li>Redis是一个单线程的，业务A中慢的操作会影响到业务B</li></ol><p>正例：不相干的业务拆分，像刚才那2个业务A和B其实2个业务没有任何关系，那我其实就不需要用同一个Redis，还有一种可能：不去用多个数据库，而是用多个实例，比如可以开更多的Redis，因为Redis是单线程的，我们会在一个机器上去开多个Redis实例，让Redis去充分利用好多个服务器上的多核，这样就会有更好的优势业务与业务之间不会受到干扰，当然这里还有就是公共的数据要做服务化，假如现在有10个业务全都用到公共信息，这里以一个视频网站，比如说优酷、爱奇艺都有一些视频信息，视频信息就是这些网站的公共数据，基本是你做任何业务都离不开这样的公共数据，这样的公共数据我们不可能将它去存在一个Redis实例或者MySQL实例中，有可能会存，但对于这种方式我们不可能让每一个业务都去调MySQL、Redis实例，而是说我们做更好的是做一个公共的服务，像现在说的微服务、服务话的名词，这里至于服务的底层用的是Redis还是MySQL存储的这个是你自己的事情，对于多个业务使用同一个数据的时候是通过像一些http接口、其他协议的接口来对外提供服务，这样的话不会Redis实例进行干扰，因为这份公共数据全部会在一个比较权威的项目或者组内，然后它对外提供的是一个公共的数据服务</p><hr><p>在使用Java客户端或者其他客户端的时候建议去使用连接池，其实连接时有一个标准的使用方式：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191105203315653.png" srcset="/img/loading.gif" alt="image-20191105203315653"></p><p>在try-catch-finally外面去定义Jedis对象，Jedis对象去通过JedisPool这个连接池去获取连接，然后去执行对应的命令，在catch里面去捕获异常，捕获异常要注意一个点：假如你现在操作一个命令，执行这个命令会有key，这里在异常中打印出来，然后再加上异常异常，在finally中去关闭Jedis连接，这里的关闭不是说关闭连接，如果关闭连接其实使用连接池就没有意义，因为使用连接池就是为了使用长连接，这样的话会减少每次tcp三次握手，它并不会真的进行关闭，它会在JedisPool模式，比如说你现在使用JedisPool中获取的连接，它会把Jedis的连接归还给连接池，也就是说它会判断你的连接是从连接池取出来的还是普通实例化出来的连接，如果实例化的连接它会对它进行关闭处理；</p><p>那么说了这么多，这么做有什么好处？</p><ul><li>对于捕获异常来说，我们可以在Jedis获取连接、执行命令的时候都可以捕获到它的异常；</li><li>异常的时候能打印出它的key，可以判断出这个key对应的节点，比如说我们使用的是RedisCluster，如果不打印出来它连接的地址前提下，我们可以打印key，通过key来知道对应的IP和端口，我们可以通过redis-cli获取到它的host；</li><li>通过异常的捕获还可以做其他的事情，比如像log4j这样的东西，然后去写一些append，这个append只收集想Redis的问题，这样就可以针对Jedis来做很多独立的统计，比如统计一分钟内发生多少异常，每种异常的类型是什么？</li></ul><h2 id="连接池参数说明"><a href="#连接池参数说明" class="headerlink" title="连接池参数说明"></a>连接池参数说明</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191105204618121.png" srcset="/img/loading.gif" alt="image-20191105204618121"></p><h2 id="如何预估最大连接池"><a href="#如何预估最大连接池" class="headerlink" title="如何预估最大连接池"></a>如何预估最大连接池</h2><p>对于连接池，最重要的参数是maxTotal，它值的是最大连接数是多少，这个是非常有讲究的，我从线上来看，之前维护的业务包括我了解的业务也比较多，发现这个配置千奇百怪，每个人的配置都有不同的理解，甚至很多其他配置，有人配置几千甚至上万都见过，但是在你不懂它的含义的之前或者说不你不理解去预估参数之前，这些设置都是没有任何道理的，那么maxTotal怎么去设置呢？这里建议你将maxIdle和maxTotal接近，我们的最大空闲数和最大连接数是一样的，这样是什么目的呢？其实主要为了防止maxIdle到MaxTotal它们相差的期间，创建新的连接，当创建新的连接就是类似等待的效果，这是一个非常不好的手段；</p><p>来看下maxTotal考虑的因素：</p><ul><li>业务希望Redis并发量：这个是指的是业务端，业务端希望Redis并发量是多少，比如我并发量是1W、10W，你可以用最简单最直白的想法去想，那其实我的maxTotal是和并发量有关，并发量越低在一瞬间去需要的连接数时越小的，你的并发量越小，那需要maxTotal越小，并发量越大需要的就越大；</li><li>客户端执行命令时间：现在maxTotal为8，那现在我的客户端平均时间都在2秒，就是说每个命令都要执行2秒，我这一瞬间8个连接都会被占用，下一次有个访问都要等2秒以后才能获取到，这这要看你的需求了，你的命令的时间越小那可能需要的maxTotal就越小；</li><li>Redis资源：例如node（应用个数） * maxTotal不能超过Redis最大连接数：你的应用总数和你的maxTotal超过Redis最大连接数了，Redis对于服务端来说，假如有1W个连接，可能你应用个数有100个，你的maxTotal是不是超过100的，否则你达到Redis服务端的最大连接数；</li><li>资源开销：例如虽然希望控制空闲连接，但是不希望因为连接池的频繁释放创建连接造成不必要的开销。</li></ul><p>一个例子：</p><blockquote><p>这里通过一个例子来进行了解</p></blockquote><p>我现在这个业务里每一次的命令就是像borrow 、return、resource从池子去，从池子里还来去执行命令，执行命令还包括网络时间，命令是通过网络发送给Redis的，假设我们当前的平均耗时为1毫秒，那就说我这一个连接的QPS可以到1000，那我现在有业务希望QPS是5W，这里很简单的算法：<code>maxTotal = 5W / 1000 = 50个</code>，50个就可以达到预期5W的效果，虽然这只是一个理想的值，但是这个值是有参考意义的，这样的话你可以在实际使用中适当的去放大和缩小，我们可以用75个、100个虽然去设置一个值根据你的想法来设置，但是这里有一个比较难的地方，你要清楚两点：</p><ul><li>清楚命令的平均耗时，这个是要做很多时间的，比如说你要通过各种手段知道命令的平均耗时是多少，注意这里的耗时是客户端的耗时时间，并不是Redis服务端统计出来的时间；</li><li>你需要知道业务并发量是多少，就是Redis并发量是多少</li></ul><p>这里介绍的依然是一个理论知识，理论知识怎么去用呢？实际中就按这个来设置就好了，但是在这里需要监控很多东西，比如监控前面提到的当前连接数、每次getResource需要的时间、还给池子的时间、当前的总数，这些都是要去进行监控的，有一个图或者一个预警，这些东西需要做一个长期的升级，然后就能知道当前的平均耗时是多少，我们从线上可以看到我们并不是说理论这样设置50个线上就去设置50个，而是通过预期的设置去观察线上是否有出现连接池耗满的问题，我们要有这样的基础，但是实际生产中我们要通过对线上的观察来获取，观察不是说用肉眼去看，而是通过各方面的数据收集来支撑。</p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 12.布隆过滤器.md</title>
    <link href="/redis-12.html"/>
    <url>/redis-12.html</url>
    
    <content type="html"><![CDATA[<h1 id="引出布隆过滤器"><a href="#引出布隆过滤器" class="headerlink" title="引出布隆过滤器"></a>引出布隆过滤器</h1><p>现有50亿乙个电话号码,现有10万个电话号码,要==快速准确==判断这些电话号<br>码是否已经存在?布隆过滤器基本原理，看看这些解决方案：</p><ol><li>通过数据库查询：实现快速有点难；</li><li>数据预放在集合中：50亿*8字节≈40GB（内存浪费或不够）；</li><li>hyperloglog：准确有点难。</li></ol><p>以上的方式都是无法实现需求的，上述的应用场景在很多地方都有遇到：</p><ul><li>垃圾邮件过滤：现在有几亿封垃圾邮件，在这种情况我认为它是垃圾邮件，现在我来了一封新的我怎么去判断呢？现在就不去考虑一个收件人一个特征来判断它是否在垃圾邮件这个大的集合当中呢？</li><li>文字处理（例如word）错误单词检测；</li><li>网络爬虫重复URL检测：在抓的时候有些URL是重复的，为了防止重复的抓取，它要做一个是否在这个已抓的这个URL集合中？它也要做一个判断，这里就需要用布隆过滤器解决这个问题；</li><li>Hbase行过滤：也需要使用布隆过滤器来解决。</li></ul><h1 id="布隆过滤器基本原理"><a href="#布隆过滤器基本原理" class="headerlink" title="布隆过滤器基本原理"></a>布隆过滤器基本原理</h1><ul><li>1970年伯顿.布隆提出，用很小的空间，解决上述类似问题；</li><li>实现原理：一个很长的二进制向量和若干个哈希函数。<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191103210029972.png" srcset="/img/loading.gif" alt="image-20191103210029972"></li><li>参数：m个二进制向量（上面的0 1 数组），n个预备数据（50亿个电话号码），k个hash函数（上面的f1-f8 你需要多少个，这个可以设置）；</li><li>构建布隆过滤器：n个预备数据走一遍上面过程：每一个数据走一遍f1-f8把对应的向量的值设置为1；</li><li>判断元素存在：走一遍上面过程：判断过程是不是1，如果都是1，则在表明存在，反之不存在。</li></ul><h1 id="布隆过滤器误差率"><a href="#布隆过滤器误差率" class="headerlink" title="布隆过滤器误差率"></a>布隆过滤器误差率</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191103211924442.png" srcset="/img/loading.gif" alt="image-20191103211924442"></p><h1 id="本地布隆过滤"><a href="#本地布隆过滤" class="headerlink" title="本地布隆过滤"></a>本地布隆过滤</h1><ul><li><p>现有库：guava；</p></li><li><p>本地布隆过滤器的问题：</p><ul><li><p>容量受限制：受限于容器，假如容器是一个JVM或者你使用的是Tomcat这样的Web容器它实际上也是JVM,那么就会受到JVM的限制，就包括之前提到的你使用集合的话，使用布隆过滤器还是需要很多内存的，假如n比较大，而且你希望的误差率比较低，对于M要求就比较大，同时还会涉及到单机</p></li><li><p>多个应用存在多个布隆过滤器，构建同步复杂。<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/image-20191103214303958.png" srcset="/img/loading.gif" alt="image-20191103214303958"></p><p>假如这里container1需要向布隆过滤器插入一些东西，由于业务逻辑，然后container2去往布隆过滤器插一些东西，但container1中的和container2中的这样的布隆过滤器是没法实现同步的，之后可能涉及到一些业务逻辑的时候，尤其一些前端业务逻辑，前端访问的时候，它可能做了一些负载均衡，它不保证全部都在container1，它可能还会去container2，在布隆过滤器没有这样的概念。</p></li></ul></li></ul><h1 id="Redis单机布隆过滤器"><a href="#Redis单机布隆过滤器" class="headerlink" title="Redis单机布隆过滤器"></a>Redis单机布隆过滤器</h1><blockquote><p>笔者正在补充~</p></blockquote><h1 id="Redis分布式布隆过滤器"><a href="#Redis分布式布隆过滤器" class="headerlink" title="Redis分布式布隆过滤器"></a>Redis分布式布隆过滤器</h1><blockquote><p>笔者正在补充~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 11.Redis云平台CacheCloud.md</title>
    <link href="/redis-11.html"/>
    <url>/redis-11.html</url>
    
    <content type="html"><![CDATA[<h1 id="Redis规模化运维困扰"><a href="#Redis规模化运维困扰" class="headerlink" title="Redis规模化运维困扰"></a>Redis规模化运维困扰</h1><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>当集群数量多的时候就会遇到很多问题</p><ul><li>发布构建繁琐，私搭乱盖：你可能会找几台机器进行集群的安装或者单机安装、Sentinel安装，然后随便记录一下文档客户端就可以调用了，这个属于一个私搭乱盖的情况，当有几百台机器、上千上万台的时候，你怎么可能记得在某台机器安装了一个集群呢？何况集群之间本身就发生高可用的切换，本身对于这种场景去管理去使用非常的混乱。当到了一定量的时候必然会出现问题；</li><li>节点和机器等运维成本：无法对机器和节点的关系合理的管理，必然会造成浪费的情况，一些机器可能会闲置；</li><li>监控报警初级：用一些工具可以实现对Redis节点的使用状况进行监控，Redis虽然是一个高性能的数据库，但它也是一个脆弱的服务器，因为前面提到它单线程的特性，例如你使用不当就会对它造成一个致命的影响，所以我们希望知道它到底在执行什么，以及每个地方什么时间出现哪些问题，对于问题排查是有帮助的。</li></ul><p>这里会对上述问题通过CacheCloud解决，它有什么功能呢？</p><ol><li>一键开启Redis（Standalone、Sentinel、Cluster）；</li><li>机器、应用、实例监控和报警；</li><li>客户端：透明使用、性能上报；</li><li>可视化运维：配置、扩容、Failover、机器/应用/实例上下线；</li><li>已存在Redis直接接入和数据迁移；</li><li><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">https://github.com/sohutv/cachecloud</a> </li></ol><p>使用场景</p><ol><li><p>全量视频缓存（视频播放API）：跨机房高可用；</p></li><li><p>消息队列同步（RedisMQ中间件）；</p></li><li><p>分布式布隆过滤器（百万QPS）；</p><p>计数系统：计数（播放数）；</p><p>其他：排行版、社交（直播）、实时计算（反作弊）等。</p></li></ol><h1 id="快速构建"><a href="#快速构建" class="headerlink" title="快速构建"></a>快速构建</h1><blockquote><p>请根据官方文档进行搭建</p></blockquote><h1 id="机器部署"><a href="#机器部署" class="headerlink" title="机器部署"></a>机器部署</h1><h1 id="应用接入"><a href="#应用接入" class="headerlink" title="应用接入"></a>应用接入</h1><h1 id="用户功能"><a href="#用户功能" class="headerlink" title="用户功能"></a>用户功能</h1><h1 id="运维功能"><a href="#运维功能" class="headerlink" title="运维功能"></a>运维功能</h1>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 10.缓存设计与优化</title>
    <link href="/redis-10.html"/>
    <url>/redis-10.html</url>
    
    <content type="html"><![CDATA[<h1 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h1><blockquote><p>使用缓存能带来哪些收益又会付出什么成本？</p></blockquote><h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ol><li>加速读写<ul><li>通过缓存加速读写：CPU  L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器缓存、Ehcache缓存数据库结果；</li></ul></li><li>降低后端负载<ul><li>后端服务器通过前端缓存降低负载：业务端使用Redis降低后端MySQL负载等。</li></ul></li></ol><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ol><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关：你需要将底层的数据库的数据放到缓存槽进行缓存，它两会有一个不一致，例如数据库更新了，然后缓存怎么去更新呢？这里就有很多更新策略，它不会立刻更新，而是过一会更新；</li><li>代码维护成本：多了一层缓存逻辑；</li><li>运维成本：例如Redis Cluster，这些会增加运维成本，当然这些成本不一定是安装，假如你可以使用一些外面的云，但是会涉及到经济成本。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>降低后端负载：<ul><li>对高消耗的SQL：join结果集/分组统计结果缓存；</li></ul></li><li>加速请求响应：<ul><li>利用<code>Redis</code>/<code>Memcache</code>优化IO响应时间</li></ul></li><li>大量写合并为批量写：<ul><li>如计数器，假如说我如果只使用DB的话，我不可能每次都<code>update</code>一个值等于一个值加一这样做，对于数据库来说这种操作相当于插入来说它本身就是比较慢的，然后如果你还要做大量的这种操作那它的负载会很高速度会很慢，而且它本身不适合这种场景，但是有的时候真的要将这个数据保存在DB，这里可以先写一个计数器，例如使用<code>Redis</code>的<code>INCR</code> ，在<code>INCR</code>中做累加，因为它<code>INCR</code>是非常快，如果真的需要同步给数据库，可以定期批量的做这样的事情，从而提高效率</li></ul></li></ol><h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><p>缓存的数据都是有声明周期的，需要做定期更新或者删除从而保证空间在一个可控的范围内，而且保证数据定期更新；但是缓存中数据由于某些原因可能和真实的数据有一些不一致，需要在合理的策略、合理的时间进行更新，这里对这个问题说明，这里介绍3种更新策略</p><ol><li>LRU/LFU/FIFO算法剔除：对于Redis来说就是<code>maxmemory-policy</code>最大内存对应的策略，比如说最大内存出现了时候要怎么去做？像有一些策略是说在对应出现<code>maxmemory-policy</code>达到最大值的时候它首先关注过期建议，因为过期建议未来可能会删除的一些键，然后执行<code>LRU</code>，将一些最近没使用的一些key去执行来保证<code>maxmemory-policy</code>的整体的值不会超过，达到保护内存的效果，而且保证尽可能的数据安全，虽然这样已经剔除了一些数据，但是它可能保证一定的安全 ，还有像OKEYCORU就是在所有键里面去执行LRU，这样一个策略，当然它有一个优势是说我们在设置这样功能的时候是非常简单，只需要对缓存配置一个对应的策略，例如以上说的策略，我们不需要关心具体每一个key到底是怎么删的、到底是时候什么策略都不用去关心，它的适用场景是我们在控制最大内存，例如像刚才说的我要对应缓存或者说一个存储设置最大内存，在这种情况下去帮我删除数据，而不是说我的没有几条数据然后你就按这个策略帮我删；</li><li>超时剔除：对于Redis来说就是设置过期时间，例如用户信息将它缓存起来了，然后给它设置一个半小时的过期时间，在这半个小时之内，用户请求都是会去缓存中去拿对应的结果，然后来保证性能来降低后端的负载，但是有一个问题：在这缓存期间如果用户更新了怎么办？这个用户信息很重要，对于这种情况expire就不是很好，可能一些不重要的信息，像视频对应的说明很长的几百个字，然后它改了一个逗号，对于用户来说这一段时间的不一致是可以容忍的，像一些重要信息，涉及到钱方面的金融的信息肯定不能用这样的策略；</li><li>主动更新：控制key更新周期，例如刚才说的还是以刚才的用户信息为例子，用户信息在存储层发生了变化，如果对应的缓存层能知道，我通过你的业务代码或者通过开发一些工具，比如去订阅这个持久层消息的变化，它做了更新它会发一条消息，然后我这里做一个主动的更新把对应的key删掉或者做一次重建，从数据层去读取一遍，然后回写到持久层，来实现数据一致性，当然这种一致性任然不是一个完全一致的强一致性，而是一个需要时间的最终一致性，最终一致性需要的时间是比较短的，因为它是有这样机制来保证；</li></ol><p>策略对比</p><table><thead><tr><th>策略</th><th>一致性</th><th>维护成本</th></tr></thead><tbody><tr><td>LRU/LIRS算法剔除</td><td>最差</td><td>低</td></tr><tr><td>超时剔除</td><td>较差</td><td>第</td></tr><tr><td>主动更新</td><td>强</td><td>高</td></tr></tbody></table><p>建议</p><blockquote><p>在实际开发中要使用哪种策略呢？</p></blockquote><ol><li>低一致性：最大内存和淘汰策略：非常不关心缓存一致性或者缓存和持久层数据不一样都无所谓的，那就使用这种策略，可以使劲往里面扔，然后当出现最大内存的时候，然后就去把对应的数据淘汰，而且淘汰什么我也无所谓，如果没有的话就一下次从持久层落键；</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底：为什么这里要结合呢？不是是说主动更新更优秀吗？但实际上超时剔除是给主动更新做一个兜底，假如说主动更新的业务逻辑或者业务图或者对应的代码出现了问题，它没有将真正的数据删除掉，那我们可能后期就没法发现这个问题，假如说我给它设置比较长的过期时间，如果遇到类似的问题，它会将数据进行删除，当然所有数据是指有生命周期的，它确实是要在一定时间过期的，假如说我有一些数据不会过期或者需要自己去手动删除的数据，不会给它设置过期时间，当然这里还会使用最大内存和超时策略做一个兜底，因为天有不测风云，你无法保证每天内存突然增上去了，而且你对内存做的不到位，这个时间我需要最大内存淘汰策略进行兜底来保证项目出现问题后缓存就不可用了这样的问题；</li></ol><h1 id="缓存粒度控制"><a href="#缓存粒度控制" class="headerlink" title="缓存粒度控制"></a>缓存粒度控制</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572526081631.png" srcset="/img/loading.gif" alt="1572526081631"></p><p>上面这张图是很多应用的抽象，使用Redis、Memcahe等做为缓存底层使用MySQL做为存储源，对于大部分流量来说，都去光顾到Redis，小流量到MySQL这样的场景；</p><hr><p>缓存粒度控制-三个角度</p><ol><li>通用性：全量属性更好；</li><li>占用空间：部分属性更好；</li><li>代码维护：表面上全量属性更好。</li></ol><h1 id="缓存穿透优化"><a href="#缓存穿透优化" class="headerlink" title="缓存穿透优化"></a>缓存穿透优化</h1><h2 id="大量请求不命中"><a href="#大量请求不命中" class="headerlink" title="大量请求不命中"></a>大量请求不命中</h2><p>对于正常的访问来说，访问到cache它会把结果返回给request，如果它没有命中的话，它就会把流量放下去，也就是存储层，如果存储层正常的话它会返回拿到对应的结果，然后回写cache返回给request，当下次request再访问的时候，cache就已经命中了，就不需要访问到存储层了，但是有一种问题就是存储层也不存在，那会有什么问题？我返回给request是一个空的结果，而且当下次再请求的时候，它任然会返回cache层，cache层还是没有，然后继续把流量导到存储层，所有的流量都会达到存储层，因为cache中没有这样的数据，如果根本不存在的数据你去访问它，比如说它是一个key或者一个id它根本就不存在，你这里的缓存存、存储层都不存在，它就会把流量打到存储层，这就是缓存穿透的基本过程，这样已经失去了缓存的意义，因为缓存的意义就是保护持久层，然后这样会给持久层一个负载带来很大保护，但是现在已经失去了这样的作用，那就会对持久层造成很大隐患</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>以上描述的情况到底是由于什么造成的？</p><ol><li>业务代码自身问题：写的逻辑有问题，比如你去写一个回写，或者你真的拿不到那样的数据，又或者你的持久层是别人的接口，别人的接口出现问题了，那怎么办？那可能拿到就是一个异常或者一个空，你没法做缓存的回写，或者你自身代码有问题；</li><li>恶意攻击、爬虫等等：对于视频网站，虽然说它的URL做了很多加密，实际上这个加密是防止用户恶意的人员去猜到这个视频id的规则，这样的话它在抓取这个视频网页的数据的时候，因为网页上有很多的信息，比如说一个视频网站，它有明星的信息，还有推荐信息，这些信息可能对处于某些目的的人，它可能想去拿到这样的信息，那它通过一些渠道知道了你这个URL规则，或者它根本就不知道，但是它强制访问，它访问的时候可能会触发你这边对应的接口，你接口就触发到缓存，这种数据比如它传给你的id根本就不在存储的范围内，所以说必然会出现穿透问题，可能就会造成上面类似的危害；</li></ol><h2 id="任何发现"><a href="#任何发现" class="headerlink" title="任何发现"></a>任何发现</h2><p>以上描述的问题要如何去发现？</p><ol><li>业务的响应时间：可能有一些或者什么语言，它可能都会有相应的监控系统，平常缓存抗了很大的量，本身缓存抗量了，而且它的响应速度比较快，所以说一般时间是在一个稳定的情况下，它是一个可预期的 ，但如果出现了类似的穿透现象，它可能把所有流量全打到存储层，它必然会在时间上发生问题；</li><li>业务本身问题；</li><li>相关指标：总调用数、缓存层命中数、存储层命中数：这些相关的参数你都是可以采集到，比如说你采集每分钟的变化，然后你就可以知道到底有没有这样的问题；</li></ol><h2 id="解决方法1"><a href="#解决方法1" class="headerlink" title="解决方法1"></a>解决方法1</h2><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><blockquote><p>这是一个简单粗暴的方法</p></blockquote><p>一个请求在cache层、storage层也miss的情况，之前做法是直接返回给request一个空，我们想象一下，我们如果这样做的话任然会将流量打到storage，实际上这就是缓存穿透问题，那如果我们真的认为它确实不存在，就是访问request我认为你确实不存在，那我就把它当做一个结果然后缓存到cache中，这里有很多原因，可能是真的不存在、可能是由于某些原因，比如说storage暂时不可用或者storage它是一个接口，那个接口不可用等等愿意…，那这个时候我们可以将这个cache设置一个过期时间，比如5分钟、半分钟这样的一些指标，这个根据你的场景决定，那对于下次访问来说，在cache中已经有了那个key，但是这个key的值是空的，但是它可能帮助我们减少storage层的压力，从而解决缓存穿透问题带来的一些危害，但是它存在2个问题：</p><ol><li>需要更多的键：前面提到像恶意攻击或者爬虫，它会有很多各种乱七八糟的键，你都无法预测，使用缓存空对象的时候，会把那些传过来的键都进行一个缓存，虽然只存键和它的空值，但是如果这个量很大的时候，从业务上或者从缓存的使用量来说也会有一定影响，所以设置过期时间来降低这样的风险；</li><li>缓存层和存储层数据“短期”不一致：因为存储层在一些情况出现了问题，比如类似一个接口，它当时调用的时候出现比如网络滚动、对方出现异常我拿不到对应的结果是一个空，我把这个空缓存了然后缓存了5分钟过期时间，在这之后它的业务恢复正常了，但是我缓存是一个空的状态，这个时候它们2者是不一致的，实际上这个数据是存在的，但是缓存是一个空的，当然这样的问题可以依赖一些方式来解决，比如说你可以去订阅它的消息，比如它的服务发出正常的消息，我们会把缓存重新上线一遍，将这个key重新发送一遍，可以使用一些消息队列单独订阅到某一个key，或者某一个业务，这些都可以解决不一致的问题，但是它绝对不是一个强一致，因为它两之间永远会存在短期的不一致，这个看你的使用场景来决定</li></ol><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572528561308.png" srcset="/img/loading.gif" alt="1572528561308"></p><h2 id="解决方法2-布隆过滤器拦截"><a href="#解决方法2-布隆过滤器拦截" class="headerlink" title="解决方法2-布隆过滤器拦截"></a>解决方法2-布隆过滤器拦截</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572529784092.png" srcset="/img/loading.gif" alt="1572529784092"></p><p>通过很小的内存来实现对数据的过滤，比如说巨大的一个电话本，例如说有10亿行，我要判断一个电话是否在这个电话本里要怎么去做？一般不可能把电话本全部放到内存里，这样会使内存非常大，布隆过滤器是解决类似的问题的，它可以通过一些算法将电话本大数据放到布隆过滤器热一遍，当你下次访问需要判断某个电话是否在这个电话本里的时候，它可以用很小的内存解决刚才类似的问题。布隆过滤器拦截实际上你可以认为它所有的key或者一份大的离线数据放到布隆过滤器里，也就是说这个布隆过滤器在开始层再去做一层拦截，如果在布隆过滤器里已经被过滤了那就不认为你这个请求是有效的，如果你没有被过滤，那就从开始层去拿，当然这有一个问题：布隆过滤器怎么去生成？是离线生成还是说怎么去做？这个都是有很多问题的，布隆过滤器它的使用场景对于这种比较固定的数据是比较好的，如果是频繁更新的数据，我怎么去构建布隆过滤器，这里就有很多问题，举个例子：比如我之前做的推荐服务，很早的推荐服务，不想现在实时推荐，而是说根据用户前一天执行的日志给出第二天的结果，这个结果一般都是在夜间去算的，然后算完之后它会存储到比如hbase上，然后第二天就这些对应结果给用户，这份数据实际上是一份比较固定的数据，它有每个用户的行为，我们可以把每个用户的key做成一个布隆过滤器，这个布隆过滤器相对是一个可信的，它就是这样一个过程，它的使用场景是有局限的，要么你对布隆过滤器实现实时更新，要么使用一个比较固定的数据体，和刚才说的缓存空对象来说，它们2者的使用场景不太相同，而且使用的维护成本也不太相同，例如会像这样来说：这个代码比较简单，但是它可能会需要一些额外的空间来保存空的key，而且它可能有一些数据不一致，而对于布隆过滤器的问题就更多了，它需要特殊的使用场景，这个布隆过滤器要单独写一些代码，而且它本身虽然可以占用很小内存来实现整个数据的过滤都是需要额外的空间来完成的，虽然在选取对应的方案的时候，或者你发现了一种思路你都要去根据具体的场景来决定使用哪些方法</p><h1 id="无底洞问题优化"><a href="#无底洞问题优化" class="headerlink" title="无底洞问题优化"></a>无底洞问题优化</h1><p>在介绍RedisCluster的时候说过RedisCluster是如何实现批量优化的时候，提到过那样的问题是无底洞问题，下面来看看这个问题的描述：</p><ul><li>2010年，Facebook有了3000个Memcache节点，因为它们业务的量越来越大，而且它们当时用了很多Memcache，Memcache也是缓存的产品</li><li>发现问题：“加”机器性能没能提升，反而下降，这个就是无底洞问题，你加了个更多的投入，但是你没有得到对应的收益，反而去下降了，投入越多下降越明显，这个东西是一个无底洞</li></ul><p>无底洞问题关键点：</p><p>一个批量操作变化，假如原来我们一个cache一个节点只有这么一个，实现一个mget操作只进行一次IO,当节点变成3个的时候，之前介绍过，将客户端将key进行组装，然后按照它对应的节点ip和端口，然后就会出现这种问题，也就是我一次mget操作会随着机器或者节点的个数越来越多，那么网路的次数也会越来越多，会对我的客户端一次命令执行效率带来很大下降，实际上我的一个IO由于扩容，由原来的O：1变成了O:node，我的node节点越多mget理论上来说它的一次批量操作时间会越长，因为它涉及到更多的节点，而且这里有个问题：你在一次mget可能要等最慢的节点完成然后才能将这个操作完成，这还是在并行的情况下，假如说是在一个串行的话它会更晚，当然这里指的是节点非常多，前面提到过了：Facebook那个时候已经达到了3000个节点，对于一般应用来说从一个扩展成3个，一次mget一个损失不会特别明显，所以说大家也不用去过分担心这个问题；</p><ul><li>更多的机器！=更高的性能；</li><li>批量接口需求（mget、mset等）；</li><li>数据增长与水平扩展需求：随着业务量越来越大，肯定需要将我们的缓存进行水平库容，水平扩容无非就是加节点加机器，所以这2者实际上是一个矛盾，我客户端需要更高的性能，但是我服务端又需要更多的数据，或者说服务端性能你的扩容</li></ul><p>对于上的IO问题，这里提供了几种优化方法</p><ol><li>命令本身优化：例如慢查询keys、hgetall bigkey；</li><li>减少网络通信次数：mget由原来的一次的n次网络变成了节点次网络，或者说是到一次网络，怎么去做这件事，当然这里还有一个问题你优化的到底是什么东西，假如说优化的Redis这种命令执行本身，那我可能会考虑网络优化更多一点，假如说像MySQL，可能MySQL本身执行就非常慢，网络可能会稍微忽略一些，而且MySQL对性能要求不会太高，像Redis，我可能会考虑优化很多sql，做不同的数据库优化，它的思路也不太一样；</li><li>降低接入成本：我们在使用客户端的使用，可能会考虑更多使用长连接或者连接池、NIO一些技术来降低成本提高IO优化效率，本次这个无底洞问题主要优化的是读写，不会考虑命令本身IO成本，因为它已经足够优秀了，我们解决主要问题降低通信次数，因为我们机器加的越多通信次数越多</li></ol><h1 id="雪崩问题"><a href="#雪崩问题" class="headerlink" title="雪崩问题"></a>雪崩问题</h1><blockquote><p>正在补充~</p></blockquote><h1 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572533261311.png" srcset="/img/loading.gif" alt="1572533261311"></p><p>使用缓存首先是从缓存获取，如果获取不到会从数据源获取，如果获取到了会进行一个回写，也就是缓存的重建过程，这个过程可能会出现一个问题</p><p>热点key+较长的重建时间：如果重建的这个key是一个热点key，它的访问量非常大，以微博为例子：某一个大v发了一个重要的消息，然后这个key访问量非常大，重建的过程是比较慢的，例如它执行了一个很复杂的sql或者调了一个很慢的API，那它就会有一个问题：再这个重建过程中有很多线程都会参与重建，会尝试一个问题：首先获取这个过程会比较慢，每个线程都要执行一遍重写过程，还有一个是这个重建过程可能是底层的一个接口或者是数据库，由于现在是热点key，然后会造成对数据库由很大压力，上面这张图中来描述了这个过程：现在已经到了缓存重建的时间，现在获取缓存它没有获取到数据，那就会去查询数据源，然后进行一个缓存的重建，在这个时间过了之后进行输出，与此同时因为它是一个高并发的一个过程，有很多的线程或者很多的访问都在执行获取缓存，那它发现缓存中数据为空的时候那它也会查询数据源再走一遍这个流程，当它发现缓存重建好了，它在去做缓存的正常输出，这个现象的问题就是说有大量线程都会做缓存重建，查询数据源这样的工作，一个是对数据库有很大的压力，另外一个是它的响应时间会很慢；</p><p>以上问题要怎么解决呢？这里涉及到3个目标和2个解决方法</p><ol><li>三个目标：<ul><li>减少重缓存的次数，不要像上面那样那么多重建缓存；</li><li>数据尽可能一致：重建缓存虽然做了很多优化，但是我们要解决的时候要考虑到数据要尽可能一致；</li><li>减少潜在的危险：例如可能会出现死锁或者线程池大量被hang住；</li></ul></li><li>两个解决：<ul><li>互斥锁（mutex key）；</li><li>永远不过期</li></ul></li></ol><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥锁是比较直观的解决思路：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572533989439.png" srcset="/img/loading.gif" alt="1572533989439"></p><p>首先是获取缓存的时间点，但是我第一个获取缓存它需要做重建的线程如果发现了它已经到了需要重建的时候，那我就会把重建加上查询数据库这个过程加上一把锁，然后当我在这个时间段完成这个工作的时候再把锁解开，再去做一个输出，在这个期间如果有其他线程或者其他访问在做获取缓存的时候它的过程会变成：获取缓存，发现这个重建过程被锁住了，因为只有一个线程可以做这样的事，那我只有去等待，等待完之后再输出，只有到最后一个发现锁解开了的时候我就可以直接获取到输出的结果，这个就是利用互斥锁来解决这个问题，这个思路简单那它可能会有一些问题的，它解决了一些问题，它不需要大量重建过程，但是它还会有等待的过程，会存在大量线程、请求被hang主的问题。</p><p>实例代码：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572533975254.png" srcset="/img/loading.gif" alt="1572533975254"></p><h2 id="永不过期"><a href="#永不过期" class="headerlink" title="永不过期"></a>永不过期</h2><ol><li><p>缓存层面：没有设置过期时间（没有用expire）；</p></li><li><p>功能层面：为每个value添加逻辑过期时间，例如set hello world现在这个world里面要添加一个属性：例如logicTimeOut（逻辑过期时间），在每次获取的时候，去get出来它的逻辑过期时间，我们如果发现它逻辑上已经过期了，那我们就使用单独的一个线程完成缓存的重建，这样就会有一个好处，相比之前的互斥锁的方案它不会有一个等待的过程，而且它也可以保证只有一个线程来完成缓存的重建和数据库的查询，但是它有问题：它会存在数据不一致的情况，因为它没有等到真正缓存重建完然完，可能会拿到老的结果，下面来举个例子：</p></li></ol><p>   首先在T1时间点获取缓存，它发现无需等待，因为我们的缓存永远不会过期，不会存在通过缓存获取不到来完成缓存重建的过程，然后直接就能输出结果，当T2时间点的时候，它发现逻辑过期时间到了，例如它的value包括逻辑过期时间，那么它就需要完成重建缓存，但是它要等T4才能完成，它需要一定时间，这个时候T3去访问的时候依然会输出老的值，由于现在没有缓存过期的情况，虽然现在已经过了逻辑过期时间，但是本身缓存没有过期，那么它就可以输出老的值，当T4完成的时候，我再获取缓存它就会输出新的值，这样就保证了刚才说的2个问题的解决，一个是线程无需等待，另一个是整个缓存的构建、重建只需要一个线程来完成；</p><p>   伪代码：</p><p>   <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572535701123.png" srcset="/img/loading.gif" alt="1572535701123"></p><h2 id="两种方案对比"><a href="#两种方案对比" class="headerlink" title="两种方案对比"></a>两种方案对比</h2><p>   <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572535719544.png" srcset="/img/loading.gif" alt="1572535719544"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>缓存收益：加速读写、降低后端存储负载；</li><li>缓存成本：缓存和存储数据不一致、代码维护成本、运维成本；</li><li>推荐集合剔除、超时、主动更新三种方案共同完成；</li><li>穿透问题：使用缓存空对象和布隆过滤器来解决，注意它们各自的使用场景和局限性；</li><li>无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。有四种批量操作方式：串行命令、串行IO、并行IO、hash_tag；</li><li>雪崩问题：缓存层高可用、客户端降级、提前演练是解决雪崩问题的重要方法；</li><li>热点key问题：互斥锁、“永远不过期”能够在一定程度上解决热点key问题，开发人员在使用时要了解它们各自的使用成本。</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 9.深入Redis Cluster</title>
    <link href="/redis-9.html"/>
    <url>/redis-9.html</url>
    
    <content type="html"><![CDATA[<h1 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h1><h2 id="伸缩原理"><a href="#伸缩原理" class="headerlink" title="伸缩原理"></a>伸缩原理</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572147297362.png" srcset="/img/loading.gif" alt="1572147297362"></p><p>伸就是加节点，缩就是某些节点不需要了，需要将他们进行下线</p><h2 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>准备新节点；</li><li>加入集群（meet）；</li><li>迁移槽和数据，把其他节点的槽数据均匀的移到这个节点，因为一个节点没有数据是没有 任何意义的,这个节点就可以工作了，实现性能的扩展。当然如果是从节点，给它meet就好了，不用做槽的迁移。</li></ul><h3 id="准备新节点"><a href="#准备新节点" class="headerlink" title="准备新节点"></a>准备新节点</h3><ul><li><p>集群模式；</p></li><li><p>配置和其他节点统一；</p></li><li><p>启动后是孤儿节点；</p><pre><code class="hljs bash">redis-server conf/redis-6385.confredis-server conf/redis-6386.conf</code></pre><p>启动之后的效果</p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572147740859.png" srcset="/img/loading.gif" alt="1572147740859" style="zoom:50%;" /></li></ul><h3 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h3><pre><code class="hljs bash">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6385127.0.0.1:6379&gt; cluster meet 127.0.0.1 6386</code></pre><p>加入之后的效果：<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572147701603.png" srcset="/img/loading.gif" alt="1572147701603" style="zoom: 50%;" /></p><p>作用：</p><ul><li>为它迁移槽和数据实现扩容；</li><li>作为从节点负责故障转移；</li></ul><p>使用redis-trib.rb：</p><blockquote><p>在redis中提供了加入节点的功能，我们可以用它提供的工具简单的加入</p></blockquote><ul><li>redis-trib.rb add-node new_host: new_port existing _host:existing_port –slave master-id <arg></li><li>redis-trib.rb add-node 127.0.0.1:6385 127.0.0.1:6379</li><li>建议使用redis-trib:rb能够避免新节点已经加入了其他集群,造成故障。</li></ul><h2 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h2><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ul><li>迁移计划</li><li>迁移数据</li><li>添加从节点</li></ul><h3 id="迁移计划"><a href="#迁移计划" class="headerlink" title="迁移计划"></a>迁移计划</h3><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572148492017.png" srcset="/img/loading.gif" alt="1572148492017"  /><h3 id="迁移数据"><a href="#迁移数据" class="headerlink" title="迁移数据"></a>迁移数据</h3><p>步骤</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572149049846.png" srcset="/img/loading.gif" alt="1572149049846"></p><p>流程图</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572149126364.png" srcset="/img/loading.gif" alt="1572149126364"></p><p>伪代码</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572149146990.png" srcset="/img/loading.gif" alt="1572149146990"></p><h2 id="集群扩容演示"><a href="#集群扩容演示" class="headerlink" title="集群扩容演示"></a>集群扩容演示</h2><p>加入2个节点：7006、7007，7007是7006的从</p><p>首先添加2个配置，并启动</p><pre><code class="hljs bash">[root@mcr2 config] sed <span class="hljs-string">'s/7000/7006/g'</span> redis-7000.conf  &gt; redis-7006.conf[root@mcr2 config] sed <span class="hljs-string">'s/7000/7007/g'</span> redis-7000.conf  &gt; redis-7007.conf[root@mcr2 config] redis-server redis-7006.conf[root@mcr2 config] redis-server redis-7007.conf</code></pre><p>将它们加入到集群</p><pre><code class="hljs bash"><span class="hljs-comment">#将7006加入集群</span>[root@mcr2 config] redis-cli  -p 7000 cluster meet 127.0.0.1 7006OK<span class="hljs-comment">#将7007加入集群</span>[root@mcr2 config] redis-cli -p 7000  cluster meet 127.0.0.1 7007OK<span class="hljs-comment">#查看集群节点信息</span>[root@mcr2 config] redis-cli -p 7000 cluster nodesde08a3a948a73cc2fb8793e122817af1720ed87a 127.0.0.1:7006 master - 0 1572184022492 0 connected....<span class="hljs-comment">#7007复制7006</span>[root@mcr2 config] redis-cli -p 7007 cluster replicate de08a3a948a73cc2fb8793e122817af1720ed87aOK[root@mcr2 config] redis-trib.rb reshard  127.0.0.1:7000&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7000)<span class="hljs-comment">#...</span>S: 8e1ac37cc5ec9c66cbfc1eab81b52cef25e9d255 127.0.0.1:7007   slots: (0 slots) slave   replicates de08a3a948a73cc2fb8793e122817af1720ed87aM: de08a3a948a73cc2fb8793e122817af1720ed87a 127.0.0.1:7006   slots: (0 slots) master   1 additional replica(s)<span class="hljs-comment">#...</span>[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...&gt;&gt;&gt; Check slots coverage...[OK] All 16384 slots covered.<span class="hljs-comment">#你希望迁移多少个槽</span>How many slots <span class="hljs-keyword">do</span> you want to move (from 1 to 16384)? 4096<span class="hljs-comment">#希望哪个id接收这些槽</span>What is the receiving node ID? de08a3a948a73cc2fb8793e122817af1720ed87aPlease enter all the <span class="hljs-built_in">source</span> node IDs.<span class="hljs-comment">#所有的其他节点作为作为resource id</span>  Type <span class="hljs-string">'all'</span> to use all the nodes as <span class="hljs-built_in">source</span> nodes <span class="hljs-keyword">for</span> the <span class="hljs-built_in">hash</span> slots.  Type <span class="hljs-string">'done'</span> once you entered all the <span class="hljs-built_in">source</span> nodes IDs.Source node 1: all...    Moving slot 12287 from 325733e9d4ded75d31c68f978c75357334163428<span class="hljs-comment">#是否想继续？    </span>Do you want to proceed with the proposed reshard plan (yes/no)? yes<span class="hljs-comment">#以上步骤完成迁移，来检验一下</span>[root@mcr2 config] redis-cli -p 7000 cluster slots<span class="hljs-comment">#...</span>2) 1) (<span class="hljs-built_in">integer</span>) 0   2) (<span class="hljs-built_in">integer</span>) 1364   3) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7006   4) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7007<span class="hljs-comment">#...</span></code></pre><h2 id="缩容集群"><a href="#缩容集群" class="headerlink" title="缩容集群"></a>缩容集群</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572157852975.png" srcset="/img/loading.gif" alt="1572157852975"></p><p>集群缩容和扩容有很多相似的地方，例如需要将槽的数据进行迁移，就是上面这张图。</p><p>缩容要对节点进行下线，然后再进行3个步骤：</p><ol><li><p>下线迁移槽：前提是当前下线节点是否有槽，如果没有就不用，                                                    <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572157887160.png" srcset="/img/loading.gif" alt="1572157887160" style="zoom:33%;" />下线迁移槽和前面说的扩容是一样的，扩容：其他节点往迁移slot，下线槽：将下线节点的所有槽均匀迁移给其他节点；</p></li><li><p>忘记节点：Redis Cluster集群这些节点需要忘记它，因为集群节点之间                                                          是共享消息的，你要告诉每个节点去忘记它，<br>命令：<code>redis&gt;cli cluster forget {downNodeId}</code><br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572158164591.png" srcset="/img/loading.gif" alt="1572158164591"></p><p>这里的有效时间是60秒，在60秒之内有一个节点没有忘记它，仍然会有消息，所以说你要想让一个节点真正的下线你需要对所有节点去忘记；</p></li><li><p>关闭节点：当所有节点都忘记它之后再对节点进行关闭。</p></li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p> 将7006和7007进行下线，首先先将7006的槽迁移到其他节点上</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster nodes709ce3bd4d8fba5f62f57d7ec3b64569a070f22d 127.0.0.1:7000 myself,master - 0 0 1 co                                                                nnected 1365-54608e1ac37cc5ec9c66cbfc1eab81b52cef25e9d255 127.0.0.1:7007 slave de08a3a948a73cc2fb                                                                8793e122817af1720ed87a 0 1572187198417 8 connectedde08a3a948a73cc2fb8793e122817af1720ed87a 127.0.0.1:7006 master - 0 1572187201437                                                                 8 connected 0-1364 5461-6826 10923-12287<span class="hljs-comment">#...省略其他节点信息</span>[root@mcr2 config] redis-trib.rb reshard  \--from <span class="hljs-variable">$&#123;7007的node-id&#125;</span>  \--to  <span class="hljs-variable">$&#123;7000的node-id&#125;</span> \--slots 1366 127.0.0.1:7006 <span class="hljs-comment">#在哪里运行</span><span class="hljs-comment">#是否同意</span>Do you want to proceed with the proposed reshard plan (yes/no)? yes<span class="hljs-comment">#然后剩余的槽也分给其他节点</span>[root@mcr2 config] redis-trib.rb reshard \--from <span class="hljs-variable">$&#123;7007的node-id&#125;</span>  \--to  <span class="hljs-variable">$&#123;7001的node-id&#125;</span> \--slots 1366 127.0.0.1:7006[root@mcr2 config] redis-trib.rb reshard \--from <span class="hljs-variable">$&#123;7007的node-id&#125;</span>  \--to  <span class="hljs-variable">$&#123;7002的node-id&#125;</span> \--slots 1365 127.0.0.1:7006<span class="hljs-comment">#查看7006节点，现在它的槽显示0个</span>[root@mcr2 config] redis-cli -p 7000 cluster nodesde08a3a948a73cc2fb8793e122817af1720ed87a 127.0.0.1:7006 master - 0 1572187933544 8 connected</code></pre><p>忘记节点</p><pre><code class="hljs bash">[root@mcr2 config] redis-trib.rb del-node   \127.0.0.1:7000   \ <span class="hljs-comment">#任意节点</span><span class="hljs-variable">$&#123;7007:node-id&#125;</span><span class="hljs-comment">#返回结果</span>&gt;&gt;&gt; Removing node de08a3a948a73cc2fb8793e122817af1720ed87a from cluster 127.0.0.1:7000&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...&gt;&gt;&gt; SHUTDOWN the node.<span class="hljs-comment">#查看7007是否存在</span>[root@mcr2 config] redis-cli -p 7007Could not connect to Redis at 127.0.0.1:7006: Connection refusednot connected&gt; <span class="hljs-built_in">exit</span><span class="hljs-comment">#下线7006</span>[root@mcr2 config] redis-trib.rb del-node   \127.0.0.1:7000   \ <span class="hljs-comment">#任意节点</span><span class="hljs-variable">$&#123;7006:node-id&#125;</span></code></pre><blockquote><p>这里要说一下，下线的时候要先下从节点，然后再下主节点</p></blockquote><h1 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h1><h2 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h2><ol><li>客户端发送向任意节点发送命令</li><li>服务端计算key的ARC16哈希值，更16383去取余，算出它的槽，<ul><li>如果这个数据的哈希算出来的槽是自身的，直接会返回执行结果；<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572163727292.png" srcset="/img/loading.gif" alt="1572163727292"></li><li>如果不是，返回moved异常并告诉客户端这个key属于哪个节点的，客户端拿到这个异常，根据异常去重定向发送给对应的节点去执行<br><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572163776375.png" srcset="/img/loading.gif" alt="1572163776375"></li></ul></li></ol><p>redis-cli</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -c -p 7000<span class="hljs-comment"># -c：使用集群模式，它会帮助你自动完成跳转</span>127.0.0.1:7000&gt; CLUSTER KEYSLOT hello(<span class="hljs-built_in">integer</span>) 866127.0.0.1:7000&gt; <span class="hljs-built_in">set</span> hello worldOK127.0.0.1:7000&gt; CLUSTER KEYSLOT php(<span class="hljs-built_in">integer</span>) 9244127.0.0.1:7000&gt; <span class="hljs-built_in">set</span> php best<span class="hljs-comment"># 自动重定向到7001节点</span>-&gt; Redirected to slot [9244] located at 127.0.0.1:7001OK<span class="hljs-comment">#自动改变连接节点，注意这里编程了7001</span>127.0.0.1:7001&gt;<span class="hljs-comment">#不使用集群模式的情况：</span>[root@mcr2 config] redis-cli  -p 7000127.0.0.1:7000&gt; <span class="hljs-built_in">set</span> php best(error) MOVED 9244 127.0.0.1:7001</code></pre><h2 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h2><p>前面介绍了集群的伸缩，在集群伸缩的过程中就有一个问题：对槽迁移，这个对于客户端来说是一个挑战，因为在客户端中记录的是原节点，当前节点告诉客户端数据的位置在原节点，但是在访问的时候发现key迁移到了目标节点，这个时候就需要考虑设计一种方案解决这个问题，Redis Cluster就考虑了这个问题，下面看下它的实现演示</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572168669668.png" srcset="/img/loading.gif" alt="1572168669668"></p><ol><li>假如说source节点和target节点正在迁移一个槽；</li><li>这个时候客户端发送一条命令；</li><li>服务端会回复客户端这个键是在原节点，但是这个槽已经迁移到了target节点，它会返回一个ask转向异常；</li><li>客户端收到ask异常的时候首先会执行Asking命令，然后给目标节点同时去发送之前的命令；</li><li>然后就会返回对应的结果。</li></ol><h2 id="moved和ask的区别"><a href="#moved和ask的区别" class="headerlink" title="moved和ask的区别"></a>moved和ask的区别</h2><ul><li>两种都是客户端重定向；</li><li>moved：槽已经确定迁移；</li><li>ask：槽在迁移过程中。</li></ul><h2 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h2><h3 id="smart客户端原理"><a href="#smart客户端原理" class="headerlink" title="smart客户端原理"></a>smart客户端原理</h3><ol><li>从集群中选择恶一个可运行的节点，使用 cluster slots初始化槽和节点映射；</li><li>将cluster slots的结果映射到本地，为每个节点创建JedisPool；</li><li>准备执行命令。</li></ol><h3 id="执行命令基本步骤"><a href="#执行命令基本步骤" class="headerlink" title="执行命令基本步骤"></a>执行命令基本步骤</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572179020424.png" srcset="/img/loading.gif" alt="1572179020424"></p><p>JedisCluster内部缓存了slot和节点的关系，而且对于key和slot的关系它是可以知道的，因为这个关系是公开的，它是一个CRC16去对key做一个哈希算出一个16383的模，也就是对应的槽就能找到目标节点，如果在发送命令的时候连接出错，客户端会将它理解为错误的节点，这里会随机选择一个节点，对这个节点发送命令，然后返回moved异常，这个大多数情况下是moved，因为我们在一个很大的集群执行随机节点去执行key肯定会返回moved，然后会重新初始化slot和node的关系再去目标节点发送命令，然后知道响应结果，如果这样的过程超过5次它就会返回一个错误：<code>Too many cluster redirection！</code>，</p><h3 id="JedisCluster执行源码分析"><a href="#JedisCluster执行源码分析" class="headerlink" title="JedisCluster执行源码分析"></a>JedisCluster执行源码分析</h3><p>JedisCluster</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key, <span class="hljs-keyword">final</span> String value)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JedisClusterCommand&lt;String&gt;(connectionHandler, maxAttempts) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">execute</span><span class="hljs-params">(Jedis connection)</span> </span>&#123;        <span class="hljs-keyword">return</span> connection.set(key, value);      &#125;    &#125;.run(key);  &#125;<span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String key)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JedisClusterCommand&lt;String&gt;(connectionHandler, maxAttempts) &#123;      <span class="hljs-meta">@Override</span>      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">execute</span><span class="hljs-params">(Jedis connection)</span> </span>&#123;        <span class="hljs-keyword">return</span> connection.get(key);      &#125;    &#125;.run(key);  &#125;</code></pre><p>从上面看出来，它的每个命令都是通过事先JedisClusterCommand类的execute方法，然后调用run方法，来看一下这个类</p><hr><p>JedisClusterCommand#run</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">run</span><span class="hljs-params">(String key)</span> </span>&#123;    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JedisClusterException(<span class="hljs-string">"No way to dispatch this command to Redis Cluster."</span>);    &#125;    <span class="hljs-keyword">return</span> runWithRetries(SafeEncoder.encode(key), <span class="hljs-keyword">this</span>.maxAttempts, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>);  &#125;</code></pre><p>这里首先判断key是不是空的，这里我们关注的是它的runWithRetries方法</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">runWithRetries</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] key, <span class="hljs-keyword">int</span> attempts, <span class="hljs-keyword">boolean</span> tryRandomNode, <span class="hljs-keyword">boolean</span> asking)</span> </span>&#123;      <span class="hljs-comment">//attempts：尝试，这里初始化为5次</span>    <span class="hljs-keyword">if</span> (attempts &lt;= <span class="hljs-number">0</span>) &#123;     <span class="hljs-comment">//如果attempts小于0，就会返回以下异常</span>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JedisClusterMaxRedirectionsException(<span class="hljs-string">"Too many Cluster redirections?"</span>);   &#125;      Jedis connection = <span class="hljs-keyword">null</span>;   <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//是不是asking状态，下面代码就是进行asking的一些处理代码</span>     <span class="hljs-keyword">if</span> (asking) &#123;              <span class="hljs-comment">//获取新连接</span>       connection = askConnection.get();       <span class="hljs-comment">//执行asking，把刚才的命令重新执行一遍</span>       connection.asking();       <span class="hljs-comment">// if asking success, reset asking flag</span>       asking = <span class="hljs-keyword">false</span>;     &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">//我们先看这里，这里的tryRandomNode：是否是随机节点，这里是false，再前面的run方法传递的是false   </span>       <span class="hljs-keyword">if</span> (tryRandomNode) &#123;         connection = connectionHandler.getConnection();       &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">//connectionHandler：这个就是前面介绍的，在Jedis初始化的时候，会初始化所有的槽和节点的对应关系</span>         <span class="hljs-comment">//这里调用了connectionHandler的getConnectionFromSlot方法，这里的参数是一个方法 JedisClusterCRC16.getSlot(key)，它会根据key为我们计算出对应的槽是哪个，这里作为一个这样的参数传递给getConnectionFromSlot方法，最终获得了一个连接</span>                  connection = connectionHandler.getConnectionFromSlot(JedisClusterCRC16.getSlot(key));       &#125;     &#125;<span class="hljs-comment">//执行命令</span>     <span class="hljs-keyword">return</span> execute(connection);               <span class="hljs-comment">//如果没有节点可拿</span>   &#125; <span class="hljs-keyword">catch</span> (JedisNoReachableClusterNodeException jnrcne) &#123;     <span class="hljs-keyword">throw</span> jnrcne;     <span class="hljs-comment">//连接异常，这里不一定是伸缩导致的异常，可能是网络原因</span>   &#125; <span class="hljs-keyword">catch</span> (JedisConnectionException jce) &#123;     <span class="hljs-comment">// 在递归之前释放当前连接</span>     releaseConnection(connection);     connection = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//判断attempts是否小于等于1</span>     <span class="hljs-keyword">if</span> (attempts &lt;= <span class="hljs-number">1</span>) &#123;     <span class="hljs-comment">//我们需要这个，因为如果节点是不可达的-我们需要最终启动插槽更新，</span>     <span class="hljs-comment">//或者我们可以在没有节点的情况下保持集群状态。</span>     <span class="hljs-comment">//但是现在如果max= 1或2，我们就会经常这样做。对于每个超时请求。</span>     <span class="hljs-comment">//TODO跟踪节点成功或不成功的操作- do只更新</span>     <span class="hljs-comment">//如果这个节点在最后几秒内没有成功的响应</span>              <span class="hljs-comment">//刷新本地缓存</span>       <span class="hljs-keyword">this</span>.connectionHandler.renewSlotCache();       <span class="hljs-comment">//no more redirections left, throw original exception, not JedisClusterMaxRedirectionsException, because it's not MOVED situation</span>       <span class="hljs-keyword">throw</span> jce;     &#125;     <span class="hljs-keyword">return</span> runWithRetries(key, attempts - <span class="hljs-number">1</span>, tryRandomNode, asking);          <span class="hljs-comment">//之前介绍的moved和ask</span>   &#125; <span class="hljs-keyword">catch</span> (JedisRedirectionException jre) &#123;     <span class="hljs-comment">//如果发现是moved 确定槽不在当前节点，</span>     <span class="hljs-keyword">if</span> (jre <span class="hljs-keyword">instanceof</span> JedisMovedDataException) &#123;       <span class="hljs-comment">// it rebuilds cluster's slot cache</span>       <span class="hljs-comment">// recommended by Redis cluster specification</span>        <span class="hljs-comment">//刷新本地缓存</span>       <span class="hljs-keyword">this</span>.connectionHandler.renewSlotCache(connection);     &#125;     <span class="hljs-comment">// release current connection before recursion or renewing</span>     releaseConnection(connection);     connection = <span class="hljs-keyword">null</span>;<span class="hljs-comment">// ask异常 </span>     <span class="hljs-keyword">if</span> (jre <span class="hljs-keyword">instanceof</span> JedisAskDataException) &#123;       asking = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//对连接重定向       </span>       askConnection.set(<span class="hljs-keyword">this</span>.connectionHandler.getConnectionFromNode(jre.getTargetNode()));     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jre <span class="hljs-keyword">instanceof</span> JedisMovedDataException) &#123;     &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> JedisClusterException(jre);     &#125;<span class="hljs-comment">//做重试，这里的asking之前是false，现在设置为了true，回到这个代码的前面</span>     <span class="hljs-keyword">return</span> runWithRetries(key, attempts - <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>, asking);   &#125; <span class="hljs-keyword">finally</span> &#123;     releaseConnection(connection);   &#125; &#125;</code></pre><h1 id="JedisCluster"><a href="#JedisCluster" class="headerlink" title="JedisCluster"></a>JedisCluster</h1><h2 id="JedisCluster基本使用"><a href="#JedisCluster基本使用" class="headerlink" title="JedisCluster基本使用"></a>JedisCluster基本使用</h2><pre><code class="hljs java"><span class="hljs-comment">//定义一个集合，用来存储redis cluster的节点</span>Set&lt;HostAndPort&gt; nodeList= <span class="hljs-keyword">new</span> HashSet&lt;HostAndPort&gt;<span class="hljs-number">0</span>:nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST1, PORT1))nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST2, PORT2)nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST3, PORT3);nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST4, PORT4))nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST5, PORT5))nodeList.add(<span class="hljs-keyword">new</span> HostAndPort(HOST6, PORT6));<span class="hljs-comment">//Cluster有3个参数，集合、超时时间、配置</span><span class="hljs-function">JedisCluster redisCluster new <span class="hljs-title">JedisCluster</span><span class="hljs-params">(nodeList, timeout, poolConfig)</span></span><span class="hljs-function">rediscluster.command...</span></code></pre><blockquote><p>这里不需要关心连接池的归还，在它内部帮我们封装好了</p></blockquote><p>使用技巧</p><ol><li>单例：内置了所有节点的连接池；</li><li>无需手动借还连接池；</li><li>合理设置commons-pool；</li></ol><h2 id="整合Spring"><a href="#整合Spring" class="headerlink" title="整合Spring"></a>整合Spring</h2><blockquote><p>笔者正在补充~</p></blockquote><h2 id="多节点命令"><a href="#多节点命令" class="headerlink" title="多节点命令"></a>多节点命令</h2><p>假如我们要执行一个scan操作扫描节点所有的键值，对于RedisCluster来说它不能支持一个scan命令去扫描所有节点，所以我们有一种要求就是在所有节点去执行这样的命令要怎么做呢？</p><pre><code class="hljs java">∥获取所有节点的JedisPoolMap&lt;String, JedisPool&gt; jedisPoolMap=jedisCLuster.getClusterNodes();<span class="hljs-keyword">for</span>(Entry&lt;String, Jedis Pool&gt; entry: <span class="hljs-function">jedisPoolMap <span class="hljs-title">entrySet</span><span class="hljs-params">()</span>)</span><span class="hljs-function"><span class="hljs-comment">//获取每个节点的Jedis连接</span></span><span class="hljs-function">Jedis jedis</span>=entry.getValue().getResource();<span class="hljs-keyword">if</span>(!isMaster(jedis))&#123;    <span class="hljs-keyword">continue</span>;  &#125;<span class="hljs-comment">//finally close</span>&#125;</code></pre><h2 id="批量命令实现"><a href="#批量命令实现" class="headerlink" title="批量命令实现"></a>批量命令实现</h2><blockquote><p>在RedisCluster中执行批量操作有一个问题：mget、mset必须在一个槽，下面介绍4种方法对这种问题进行优化</p></blockquote><h3 id="串行mget"><a href="#串行mget" class="headerlink" title="串行mget"></a>串行mget</h3><p>执行<code>megt</code>时，我们写一个for循环来执行，通过RedisCluster执行每个key，例如下面这张图：左边的是要执行的批量操作，右边是3个redis节点，这种方法比较简单，当效率是非常差的，它需要n次网络时间</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572188972006-1572188977000.png" srcset="/img/loading.gif" alt="1572188972006"></p><h3 id="串行IO"><a href="#串行IO" class="headerlink" title="串行IO"></a>串行IO</h3><p>它对上面的<code>串行mget</code>方案进行了优化</p><p> 左边仍然是<code>meget</code>操作，右边仍然是对应的3个节点，它有一个不同是在客户端本地做一个内聚，我现在知道所有的key，通过本地的<code>CRC16</code>然后对<code>16383</code>去取余，算出它的槽，知道本地的槽和节点的对应关系就可以将这些key进行分组，这个分组就是按照节点进行分组，给它成立一个字节，各各<code>master</code>节点一个子集，当我们有这个子集之后，我们只需要执行3次<code>pipeline</code>就可以完成对应的<code>mget</code>操作，这样就变成了nodes次网络时间，大大降低网络开销</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572189341535-1572189466437.png" srcset="/img/loading.gif" alt="1572189341535"></p><h3 id="并行IO"><a href="#并行IO" class="headerlink" title="并行IO"></a>并行IO</h3><p>并行IO是对串行IO方案的优化，利用多线程，分别在3个线程下去获取对应节点<code>pipeline</code>的返回值</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572189489205.png" srcset="/img/loading.gif" alt="1572189489205"></p><h3 id="hash-tag"><a href="#hash-tag" class="headerlink" title="hash_tag"></a>hash_tag</h3><p>这是更加极端的方案，将key做一个hash_tag的包装，将tag值用一个大括号去括起来，这样保证所有的key都落到一个redis节点，这样每次mget只需要是一个节点去写就好了</p><h3 id="四种方案优缺点"><a href="#四种方案优缺点" class="headerlink" title="四种方案优缺点"></a>四种方案优缺点</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572189600178.png" srcset="/img/loading.gif" alt="1572189600178"></p><h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><h2 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h2><ul><li>通过ping/pong消息实现故障发现：不需要sentinel</li><li>主观下线和客观下线；</li></ul><h3 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h3><ul><li>定义：某个节点认为另一个节点不可用“偏见”，这是某一个节点的认知，不代表所有节点的认知；</li><li>主观下线流程：<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572265817397.png" srcset="/img/loading.gif" alt="1572265817397"><br>这里抽象2个节点的模型观察，现在有节点1和节点2，节点1会定期发送一个ping消息给节点2，如果发送成功就是代表ping通了， 然后节点2会回复pong消息，节点1会更新与节点2最后的通信时间，如果这个ping失败了，这个通信异常就会断开连接，再下一次触发ping消息的时候，它依然会执行ping/pong这个过程，当它发现与节点2的最后时间超过了<code>node-timeout</code>，我们之前配置的<code>cluster-node-timeout</code>，就会将它标记为<code>pfail</code>,<code>pfail</code>就是主观下线，以上内容就是主观下线的基本流程；</li></ul><h3 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h3><ul><li>定义：当半数以上持有槽的节点都标记某节点主观下线，这里的半数以上是防止网络分区的情况，而且还要是主节点，这是因为在集群模式才有资格进行读写的请求以及进行槽的相关维护，而从节点只负责复制；</li><li>客观下线逻辑流程：<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572266269416.png" srcset="/img/loading.gif" alt="1572266269416"><br>它接受到其他节点发来的ping消息，如果它包含了pfail消息（主观下线），然后它会将主观下线的消息内容添加到自身的故障列表中，这个故障列表中包含了当前节点收到每个节点的对其他节点的信息，假如我当前是节点2，我的故障列表里面有节点1一直到节点n这样为列，故障n为行这样的矩阵列表能知道每个节点对每个节点的看法，这样当它添加之后它会去尝试做客观下线，因为它这个列表中维护了所有故障列表，这个列表也是有周期的，这个周期需要在<code>cluster-node-timeout * 2</code>范围内，这样是为了保证一个很久之前的故障消息不会在我这里很久是有效的，保证了客观下线的公平性和有效性；</li></ul><h3 id="尝试客观下线"><a href="#尝试客观下线" class="headerlink" title="尝试客观下线"></a>尝试客观下线</h3><p><strong>流程</strong></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572266968180.png" srcset="/img/loading.gif" alt="1572266968180"></p><p>它会统计有效下线列表报告中的数量，如果小于集群中持有槽主节点的一半则退出，如果下线报告大于主节点数量一半时会标记故障节点为一个客观下线状态，也就是图中右边部分，并向集群中发送广播通知所有节点将故障节点标识为客观下线</p><ul><li>通知集群内所有节点标记故障节点为客观下线；</li><li>通知故障节点的从节点触发故障转移流程。</li></ul><h2 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h2><p>故障恢复就是在发现主观下线的操作之后后面做了客观下线，然后客观下线通知给从节点，从节点接受到了这个消息之后它就会开始准备做故障恢复从而保证集群的高可用，它主要分为4个部分：</p><ul><li>资格检查：对多个从节点的一个资格进行审查，只有在资格审查范围内的从节点才有资格做故障恢复的工作；</li><li>准备选举时间：这个为了使偏移量最大的一个从节点具备优先级，成为主节点的条件；</li><li>选举投票：对多个选举出来的从节点，主节点要进行一个投票，最终选定谁是成为未来的主节点；</li><li>替换主节点。</li></ul><h3 id="检查资格"><a href="#检查资格" class="headerlink" title="检查资格"></a>检查资格</h3><ul><li>每个从节点检查与故障主节点的断线时间；</li><li>如果超过<code>cluster-node-timeout * cluster-slave-validity-factor</code>取消资格；</li><li>cluster-node-timeout：默认时间是15秒；</li><li>cluster-slave-validity-factor：默认是10，如果都使用默认值的话相当于150秒，每个从节点检查与故障主节点的断线时间超过个150秒就没有资格成为主节点的可能性。</li></ul><h3 id="准备选举时间"><a href="#准备选举时间" class="headerlink" title="准备选举时间"></a>准备选举时间</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572268020906.png" srcset="/img/loading.gif" alt="1572268020906"></p><p>当从节点符合故障转移资格之后，需要更新触发故障选举的时间，只有达到该时间才有可能触发后续的流程，这一步其实是为了保证偏移量比较大的从节点有更小的延迟达到所谓的一个选举时间，为了保证数据的一致性会更高，因为当前主节点已经发生了故障，只有偏移量最大的更接近原来的主节点，它更有可能成为未来的master节点，所有我们会给它更小的选举时间，让它首先去达到这个选举时间，然后完成为未来的选举，让它获得更高的票数，最终成为master节点，从节点拿到选举时间之后它会对主节点发起一个选举，让主节点发起一个选举然后主节点给它进行投票，它的一个优先级更高也就是它的偏移量更大它的选举时间会更短，就是它获得选举时间越短它就更可能获得更多的票数，例如现在这个图中的slave1由于它的偏移量比较大，它获得了更多的票数，然后slave2可能是稍后拿到选举的时间，它只获得了1票，然后这个RedisCluster会规定当你获取了这个集群中主节点的2分之1再加1这个数字之后就可以做一个替换主节点的工作了；</p><h3 id="替换主节点"><a href="#替换主节点" class="headerlink" title="替换主节点"></a>替换主节点</h3><ol><li>当前从节点取消复制变为主节点（slaveof no none）；</li><li>执行cluserDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己；</li><li>向集群广播自己的pong消息，表明已经替换了故障从节点。</li></ol><h2 id="故障转移演练"><a href="#故障转移演练" class="headerlink" title="故障转移演练"></a>故障转移演练</h2><blockquote><p>这里对某节点通过<code>kill    -9 {pid}</code>来模拟宕机的情况，假如6385部署到一台机器上，然后突然发生了宕机，这里就用 <code>kill    -9 {pid}</code>来模拟，看看它能否实现故障转移，故障转移的最终目标就是图的右边，6385成为了一个从节点，6386成为了主节点，当然6385可能是一个失败状态或者故障恢复的状态</p></blockquote><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol><li>执行kill -9节点模拟宕机；</li><li>观察客户端故障恢复时间；</li><li>观察各个节点的日志。</li></ol><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>（1）客户端打印日志存放的目录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276083100.png" srcset="/img/loading.gif" alt="1572276083100"></p><hr><p>（2）这是一个简单的while死循环</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276112807.png" srcset="/img/loading.gif" alt="1572276112807"></p><hr><p>（3）查看客户端的日志</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276191669.png" srcset="/img/loading.gif" alt="1572276191669"></p><hr><p>（4）这个时候将服务端使用kill关闭7000端口</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276152318.png" srcset="/img/loading.gif" alt="1572276152318"></p><hr><p>（5）这个时候就会收到很多异常信息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276220715.png" srcset="/img/loading.gif" alt="1572276220715"></p><hr><p>（6）稍等一会，会发现恢复正常了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276268731.png" srcset="/img/loading.gif" alt="1572276268731"></p><hr><p>（7）这里恢复时间大概20多秒左右，这里包含了主观下线、客观下线和选举的时间，对于一般的应用来说还是可以容忍的，如果你在客户端做了一些对故障容忍的熔断措施，这个故障时间还是比较小的，如果你不容忍这些时间你可以把<code>cluseter-node-timeout</code>调小一些，但是在后面的开发运维场景问题的时候会提到这个参数会影响到带宽的一个传播的速率，就是这个消息传输的频率，可能会加重带宽，所以这个参数是比较综合的参数</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276323869.png" srcset="/img/loading.gif" alt="1572276323869"></p><hr><p>（8）然后看一下节点的变化，之前的7000被kill了之后7000的从节点7003变为了master，7000已经成为了slave节点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276640360.png" srcset="/img/loading.gif" alt="1572276640360"></p><p>（9）这个时候启动7000，</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276817565.png" srcset="/img/loading.gif" alt="1572276817565"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276838894.png" srcset="/img/loading.gif" alt="1572276838894"></p><p>（10）接下来对日志做分析，首先看一下7000</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276892421.png" srcset="/img/loading.gif" alt="1572276892421"></p><p>这里由于使用的是kill操作，所以不会留下日志，只会留下启动和复制master日志</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572276978705.png" srcset="/img/loading.gif" alt="1572276978705"></p><hr><p>看7003</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277091059.png" srcset="/img/loading.gif" alt="1572277091059"></p><p>收到了它主节点下线的消息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277134120.png" srcset="/img/loading.gif" alt="1572277134120"></p><p>选举时间，这里由于搭建的是一主已从的结构，所以只有它能变成主节点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277219789.png" srcset="/img/loading.gif" alt="1572277219789"></p><p>成为master</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277280574.png" srcset="/img/loading.gif" alt="1572277280574"></p><p>清除原来主节点的信息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277295453.png" srcset="/img/loading.gif" alt="1572277295453"></p><hr><p>7002的日志</p><p>标识原来主节点的状态：failing</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277350341.png" srcset="/img/loading.gif" alt="1572277350341"></p><p>它包含了原理主节点的状态，这里进行清除</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572277439124.png" srcset="/img/loading.gif" alt="1572277439124"></p><h1 id="集群开发运维常见问题"><a href="#集群开发运维常见问题" class="headerlink" title="集群开发运维常见问题"></a>集群开发运维常见问题</h1><h2 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h2><p>之前介绍的cluster-require-full-coverage默认为yes，是否需要所有集群节点都是在线状态，而且1684个槽都在一个服务的状态，才会认为集群是完整的对外同服务</p><ul><li>集群中16384个槽全部可用：保证集群完整性；</li><li>节点故障或者正在故障转移：（error） CLUSETRDOWN The cluster is down。</li></ul><p>大多数业务无法容忍，cluster-require-full-coverage建议设置为no</p><h2 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572352974418.png" srcset="/img/loading.gif" alt="1572352974418"></p><p>Redis Cluster会定期交换Gossip消息以及做一些心跳检测</p><ul><li>官方建议：节点不要超过1000个节点；</li><li>PING/PONG消息：节点之间会交换PING/PONG消息</li><li>不容忽视的宽带消耗：当节点过多的时间就会产生一个问题，带宽消耗，因为它在传输的时候会带一下数据量，例如它有多少槽，还需要带对其他节点的认识的信息<ul><li>消息发送频率：节点发现与其它节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息，也就是说这个cluster-node-timeout数字也会决定消息发送频率，这个频率就决定了带宽；</li><li>消息数据量：slot槽数组（2kb空间）和整个集群1/10的状态数据（10个节点状态数据约1kb）</li><li>节点部署的集群规模：集群分布的机器越多且每台机器划分的节点数均匀，则集群内整体的可用带宽越高。</li></ul></li></ul><hr><p>举个例子：</p><p>​    现在有一个集群</p><ul><li>规模：节点200个、20台物理机（每台10个节点）；</li><li>cluser-node-timeout=15000，ping/pong带宽为25MB;</li><li>cluster-node-timeout=20000，ping/pong带宽低于15MB，当然cluster-node-timeout还会涉及到故障转移一个时间的问题，所以在设置的时候要去考虑这个问题，不要只考虑带宽的问题，还要考虑故障转移时间的问题；</li></ul><p>以上问题优化：</p><ul><li>避免“大”集群：避免多业务使用一个集群，大业务可以多集群。有些公司有些项目组会使用非常大的集群，然后很多业务去使用这样的集群，首先它的问题就是说，如果业务很多涉及到里面的人水平也不太相同，一旦有人开发不规范会造成P2P、阻塞这种情况，一个业务会影响带另一个业务，及时是一个分布式的，实际上还是每一个Redis节点，每个Redis节点还是一个单线程模式，对于多个业务的时候，可以使用多个集群，甚至一些大业务可以使用多个集群，因为我们公司之前一个推荐服务，它可以按照不同的推荐类型使用对应的集群，实际上不同推荐类型List之间是没有业务数据相关性的，这个时间可以使用多集群，像这种如果真的需要使用非常大数据的时候，建议使用多个集群；</li><li>cluster-node-timeout：带宽和故障转移速度的均衡：这个影响带宽、故障转移的时间，在设置的时候要对这2个方面进行均衡；</li><li>尽量均匀分配到多机器上：使用多台机器，它既保证高可用，机器越多，主从节点分配会更均匀，带宽也会更加均匀，对于这个问题开发人员不需要太关心，但是运维人员需要多关注，当节点上很多规模的时候，建议使用一些：比如自己开发一套分配规则来达到负载均衡。</li></ul><h2 id="Pub-Sub光爆"><a href="#Pub-Sub光爆" class="headerlink" title="Pub/Sub光爆"></a>Pub/Sub光爆</h2><blockquote><p>发布订阅模式在集群会出现什么问题？</p></blockquote><p>问题：public在进群每个节点广播：加重带宽</p><p>对任意一个节点去执行publish（发布消息），它会将这些消息在集群中进行广播，对一个节点进行发布，其他节点都会订阅到对应的消息，这样会有一个问题，节点带宽的开销会很大；</p><p>解决：单独“走”一套Redis Sentinel</p><hr><p>举一个例子来看下对集群节点发布消息会怎么样</p><p>7000对cluster_pubsub_test频道发布hello</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572354891479.png" srcset="/img/loading.gif" alt="1572354891479"></p><p>7001主节点与它的从节点7003订阅cluster_pubsub_test频道</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572354993873.png" srcset="/img/loading.gif" alt="1572354993873"></p><h2 id="集群倾斜"><a href="#集群倾斜" class="headerlink" title="集群倾斜"></a>集群倾斜</h2><blockquote><p>对于分布式数据库来说存在倾斜问题是比较常见的，来看下RedisCluster它的倾斜问题</p></blockquote><h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><blockquote><p>内存不均，一个节点比其他节点使用的内存多，例如下面这张图的情况，假如这里是3个主从，这是3个主节点，第2个主节点内存使用是比较高的，但是它的对象数又没有太多，那可能就有一些问题</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572355147510.png" srcset="/img/loading.gif" alt="1572355147510"></p><p>它是由这4种情况造成的：</p><ul><li>节点和槽分配不均：假如现在有3个节点，16384进行平均分，假如有一个节点分了1W个槽，它的数据量会到大一些，这是比较正常的情况 ；</li><li>不同槽对应的键值数量差异较大：将槽分配比较均匀，但是有一些槽对应的键值数比较大，就会造成数据倾斜；</li><li>包含bigkey：一个非常大的hash，因为Redis中的数据只能以key为单位进行落地到具体的节点，例如一个hash或者list、set，非常非常大，例如有100W，存在这种key的时候就会造成数据倾斜；</li><li>内存相关配置不一致：像hash、set、list、zset内存配置都有优化参数，例如ziplist优化、整数集合优化，这些对于Redis来说会减少一定内存，假如我们项目中使用了那样的集合、哈希的时候，我们做了优化，但是没有在所有节点做优化就会出现不均匀</li><li>还有一些没有提到的情况<ul><li>客户缓冲区：某一个节点的客户端缓冲区非常高，例如它的节点执行了一些大命令，也会出现这种情况；</li><li>Redis的Key和Value是存在哈希表中的，当key比较多的时候，哈希表会做一个扩容，在扩容的时候正好触发某个数字的时候，例如re哈希要大于2的n次方的时候，它会做一个re哈希，这个时候会多出一个哈希表，假如我们一个键值数非常多的时候，这个哈希表可能占用量就很大，会出现短暂不均匀。</li></ul></li></ul><h4 id="节点和槽分配不均"><a href="#节点和槽分配不均" class="headerlink" title="节点和槽分配不均"></a>节点和槽分配不均</h4><ul><li>redis-trib.rb info ip:port查看节点、槽、键值分布，如果你怀疑有这样问题的时候可以去执行；</li><li>redis-trib.rb rebalance ip:port进行均衡（谨慎使用），它有自己内部实现的算法，这个建议谨慎使用，因为这里一旦涉及迁移槽的问题，就会涉及到客户端，虽然知道智能客户端可以对槽进行兼容，但是一旦涉及到槽的迁移的时候建议谨慎操作，而且建议在自己可执行的计划范围内进行操作；</li></ul><h4 id="不同槽对应键值数量差异较大"><a href="#不同槽对应键值数量差异较大" class="headerlink" title="不同槽对应键值数量差异较大"></a>不同槽对应键值数量差异较大</h4><p>在节点槽分配比较均匀的情况下，一般不会出现这种问题，但是有些槽它对应的键值数量比较多</p><ul><li>CRC16正常情况下比较均匀，这里别人测试很多次了，不用去怀疑；</li><li>可能存在hash_tag：这个是通常的主要原因，在这种槽对应数量不是差异比较大的情况下；</li><li>cluster countkeysinslot {slot}获取槽对应键值个数</li></ul><h4 id="包含bigkye"><a href="#包含bigkye" class="headerlink" title="包含bigkye"></a>包含bigkye</h4><ul><li>bigkey：因为一个key只能落在一个槽上以及对应的一个节点上，假如说有一个大的字符串或者几百万人数甚至上万几十万的哈希，或者set、zset、list等等，就会出现数据倾斜</li><li>从节点：redis-cli  –bigkeys，这里建议在从节点上执行；</li><li>优化：优化数据结构，例如对一个大的列表进行拆分，按哈希进行二次哈希拆分</li></ul><h4 id="内存相关配置不一致"><a href="#内存相关配置不一致" class="headerlink" title="内存相关配置不一致"></a>内存相关配置不一致</h4><ul><li>hash-max-ziplist-value、set-max-intset-entries等，hash-max-ziplist-value是对哈希的优化，当一定条件满足的时候哈希会使用ziplist，set-max-intset-entries：整数集合优化，当有些条件满足的时候，set会使用整数集合来实现内存优化，假如我们集群有6个节点，那其中一个节点使用了这种优化，而且我们集群中大量使用了hash、set，如果一个节点没有配置就会造成节点数据不均匀；</li><li>优化：定期“检查”配置一致性，这对于集群管理是非常重要的，集群经量达成统一</li></ul><h3 id="请求倾斜"><a href="#请求倾斜" class="headerlink" title="请求倾斜"></a>请求倾斜</h3><blockquote><p>某一个节点上的key请求量非常高，也就是俗称的热点问题</p></blockquote><ul><li>热点key：重要的key或者bigkey，举个例子：一个重要明星发布了重要消息，例如新浪微博上面的很多大V，在重要的节日、时间点发了一些重要的消息会落到key上面，假如是有这样的问题，就会出现热点问题，还有一个就是bigkey：hash或者list是一个bigkey，这个bigkey在很多业务场景会用到它，也会有热点的问题</li><li>优化：<ul><li>避免使用bigkey；</li><li>热点不要用hash_tag；</li><li>如果真有这样的热点key，但是对一致性要求不是非常高的情况下可以使用本地缓存+MQ。</li></ul></li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul><li>在集群模式下，从节点是不接受任何读写请求的。<ul><li>假如你对它进行读，它会重定向到负责槽的主节点进行完成；</li><li>有一个命令可以达到读的效果：<code>readonly</code>，它是一个连接级的命令，当连接断了之后你需要再去执行<code>readonly</code>才可以完成这样的工作。</li><li>下面对上述进行演示</li></ul></li></ul><p>首先在7000执行写命令</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572357983112.png" srcset="/img/loading.gif" alt="1572357983112"></p><p>对7003的slave去执行度命令</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572358024669.png" srcset="/img/loading.gif" alt="1572358024669"></p><blockquote><p>这里它不会去执行读的命令</p></blockquote><p>这里先执行readonly，在去读，它就会自己去执行，它可以承担读的工作，但是你需要每次去写readonly</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572358044173.png" srcset="/img/loading.gif" alt="1572358044173"></p><ul><li>如果想完成读写分离是很复杂的<ul><li>首先要面临单机节点的问题 ，单机主从会有问题，例如复制延迟、读取过期数据、从节点故障</li><li>使用Redis Cluster去实现读写分离的时候我们需要知道对应的slave池子，RedisCluster提供了一个命令：cluster slaves {node-id}来获得对应的从节点，所以我们需要实现自己的客户端，这本身是非常复杂的，这里面还涉及到一个问题：它里面会有节点和槽的对应关系，总的来说使用RedisCluster来实现读写分离的成本是非常高的，在真的有这种需求的时候建议去考虑把你的集群规模扩大一些，而不要去考虑使用它的从节点这样的成本非常高，假如你没有这样的成本，你可以去自己实现这样的客户端，虽然整体思路意思说你要维护一个可用的slave池子还要保证槽和节点的关系你能知道，这样就好了，跟之前说的RedisSentinel思路是基本一样的</li></ul></li></ul><h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>官方迁移工具：<code>redis-trib.rb import</code>命令可以将数据迁移到集群，对于我们去升级到集群是非常有帮助的，因为我们之前的数据可能是存在单节点上，但是它有一些问题：</p><ul><li>只能从单机迁移到集群；</li><li>不支持在线迁移：source需要停写，在迁移期间写入的数据是不会被迁移的；</li><li>不支持断点续传：迁移过程中如果有中断它没法记录之前迁移的过程；</li><li>它是一个单线程的，如果你的数据量比较大的话，可能会比较慢。</li></ul><p>在线迁移：</p><ul><li>唯品会：redis-migate-tool</li><li>豌豆荚：redis-port</li></ul><p>这2个工具在很多公司都有使用，它基本原理是单独起一个节点伪装成source节点的slave，这样的话它可以拿到全量数据，而且它还可以得到持续的更新数据，然后它在利用这份更新数据然后再去同步给target节点，在source和target之间做了一层中转站，这个中转站可以拿到source的更新来实现迁移</p><hr><p><strong>演示</strong></p><blockquote><p>这里只演示官方工具：</p></blockquote><p>现在有一个单节点，现在想把这里面的数据迁移到集群上</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359118991.png" srcset="/img/loading.gif" alt="1572359118991"></p><p>通过<code>redis-trib.rb import</code>进行迁移，</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359216532.png" srcset="/img/loading.gif" alt="1572359216532"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359287984.png" srcset="/img/loading.gif" alt="1572359287984"></p><p>，在迁移期间在这个单节点去写数据，等会去对比它是否是一个在线的迁移</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359258889.png" srcset="/img/loading.gif" alt="1572359258889"></p><p>大小</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359369595.png" srcset="/img/loading.gif" alt="1572359369595"></p><p>迁移完成之后来看一下集群的信息，这里可以看到它的大小是10002，而之前是100003，因为在这期间迁移数据，此时在原理的单机节点加入数据是不会同步的，为什么是10002呢？因为<code>redis-trib.rb import</code>使用的是一个scan模式，它是对这个原节点使用scan进行扫描，因为在scan期间加入数据正好被它scan到了被加入进来，有的数据过了scan的一个游标所以它没有进行插入，总之不管它在插入期间进行插入但是呢我们现在再去对原节点操作的时候原节点已经收不到对应的信息了，这个对很多场景是无法容忍的，这个时候可以用上面介绍的2款工具</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572359420312.png" srcset="/img/loading.gif" alt="1572359420312"></p><h2 id="集群vs单机"><a href="#集群vs单机" class="headerlink" title="集群vs单机"></a>集群vs单机</h2><h3 id="集群限制"><a href="#集群限制" class="headerlink" title="集群限制"></a>集群限制</h3><ul><li>key批量操作支持有限：例如mget、mset必须在一个slot，在后面介绍缓存优化与设计会使用一些方法来模拟出mget、mset完成这样的效果，在一定程度上去支持这样的命令，但无法达到原子性；</li><li>key事务和Lua支持有限：例如我们使用事务或者Lua必须将这整个过程中使用key必须在一个节点上，当然这里可以使用像hash_tag让它去到一个节点，但是它使用来说还是会受限的；</li><li>key是数据分区的最小粒度：不支持bigkey分区；</li><li>不支持多个数据库的，在集群模式下只有db 0，没有16个数据库，当然在一帮状态下的单机情况下也不建议使用这种多数据库模式；</li><li>复制只支持一层：不支持树形复制结构，在之前的主从复制中介绍过树形结构的优势，但是在集群模式下是不支持的。</li></ul><h3 id="思考-分布式Redis不一定好"><a href="#思考-分布式Redis不一定好" class="headerlink" title="思考-分布式Redis不一定好"></a>思考-分布式Redis不一定好</h3><ol><li>Redis Cluster：满足容量和性能的扩展性，但在很多业务是不需要的，因为很多业务的QPS是达不到这么高的，或者它的容量达不到这么高，所以大家在企业里要考虑一下自己需不需要Redis Cluster，不要一味去追时髦，不要再不了解的情况下去做申请；<ul><li>大多数时客户端性能会“降低”，比如说批量操作你在怎么优化在多个节点进行操作肯定没有在一个节点高，这里指的是一次命令，因为它涉及到多节点去获取；</li><li>命令无法跨节点时候用：mget、keys、scan、flush、sinter等；</li><li>Lua和事务无法跨节点使用；</li><li>客户端维护更复杂：SDK和应用本身消耗（例如更多的连接池）。</li></ul></li><li>很多场景Redis Sentinel已经做够好了，Redis Sentinel本身是高可用了，解决开发中的一个大的问题，虽然它是一个单点，但它能达到万级别的QPS，对于大部分业务场景是足的。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>Redis cluster数据分区规则采用虚拟槽方式(16384个槽),每个节点负责一<br>部分槽和相关数据,实现数据和请求的负载均衡。</li><li>搭建集群划分四个步骤:准备节点、节点握手、分配槽、复制。<br>redis- trib.rb工具用于快速搭建集群。</li><li>集群伸缩通过在节点之间移动槽和相关数据实现。<ul><li>扩容时根据槽迁移计划把槽从源节点迂移到新节点。</li><li>收缩时如果下线的节点有负责的槽需要迁移到其它节点,再通过 cluster forgeti命，令让集群内所有节点忘记被下线节点。</li></ul></li><li>使用smar客户端操作集群达到通信效率最大化,客户端內部负责计算维<br>护键-&gt;槽-&gt;节点的映射,用于快速定位到目标节点。</li><li>集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线<br>和客观下线,当超过半数主节点认为故障节点为主观下线时标记它为客观<br>下线状态。从节点负责对客观下线的主节点触发故障恢复流程,保证集群<br>的可用性。</li><li>开发运维常见问题包括：超大规模集群带宽消耗，pub/sub广播问题，集群倾斜问题，单机和集群对比等</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 8.初识Redis Cluster</title>
    <link href="/redis-8.html"/>
    <url>/redis-8.html</url>
    
    <content type="html"><![CDATA[<h1 id="呼唤集群"><a href="#呼唤集群" class="headerlink" title="呼唤集群"></a>呼唤集群</h1><h2 id="并发量"><a href="#并发量" class="headerlink" title="并发量"></a>并发量</h2><p>Redis每秒可以达到每秒10W QPS，但是有些业务是需要100W QPS,</p><h2 id="数据量"><a href="#数据量" class="headerlink" title="数据量"></a>数据量</h2><p>现在有一台机器16~256G，假如说一个传统的Redis部署在上面，假如说业务需要500G数据呢？</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>配置“强悍”的机器：超大内存、牛xCPU等，但是随着业务量变得越来越大的时候，单机已经无法满足了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572003131116.png" srcset="/img/loading.gif" alt="1572003131116"></p><h2 id="正确的解决方案"><a href="#正确的解决方案" class="headerlink" title="正确的解决方案"></a>正确的解决方案</h2><p>分布式：简单的认为加机器；</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572003163058.png" srcset="/img/loading.gif" alt="1572003163058"></p><h1 id="数据分布概念"><a href="#数据分布概念" class="headerlink" title="数据分布概念"></a>数据分布概念</h1><p>现在有一份全量的数据，它的单机已经无法满足需求，所以就要对数据进行分区，比如现在有100份数据按照一定的规则分到若干个子集当中，</p><p>它的分区规则：</p><ul><li><p>顺序分区：假如有3个节点<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572003461916.png" srcset="/img/loading.gif" alt="1572003461916" style="zoom: 25%;" /></p></li><li><p>哈希分区：对每个数字做一个hash函数，通过节点去给它取余,例如<code>hash(key)%3</code>，结果是0放1分区，1放2分区，2放3分区，它这里有很的函数，等会会介绍。<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572003650622.png" srcset="/img/loading.gif" alt="1572003650622" style="zoom:25%;" /></p></li></ul><p><strong>数据分布对比</strong></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572003693407.png" srcset="/img/loading.gif" alt="1572003693407"></p><h1 id="节点取余分区"><a href="#节点取余分区" class="headerlink" title="节点取余分区"></a>节点取余分区</h1><p>3个节点中的hash分区： 对每个key去执行一个hansh函数对3去取一个余数，如果是0到1分区，1到2分区，2到3分区…</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572004167066.png" srcset="/img/loading.gif" alt="1572004167066"></p><p>这是一个简单的分区操作，但是有一个问题：如果需要进行扩容，业务量不断增大，3个节点无法满足要求，现在加入一个节点，添加之后有一个问题，数据会发生变化，因为要做的是对每一个数据去取一个hash去取它的节点数的余数，那就会有造成很多的数据偏移，原来在第1个节点的3，原来对3去取余是0，对4取余是3，所以它会到4节点….<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572004395008.png" srcset="/img/loading.gif" alt="1572004395008" style="zoom: 50%;" /></p><p>这里有一种方式叫做“多被扩容”，比如原本是3个节点，扩容的时候再加3个节点也就是3的倍数，这样做可以保留百分50的数据不被迁移，之前这样会迁移百分80会有很明显的降低。如果你希望迁移量少可以使用这种方式，在迁移之后去缓存中第一次可能会取不到数据，这个时候就需要去数据库中获取到那个数据，然后放到Redis中，这样会出现大量的缓存回写，这样对一个系统来说是一个不正常的现象</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572004570436.png" srcset="/img/loading.gif" alt="1572004570436"></p><ul><li>客户端分片：哈希+取余</li><li>节点伸缩：数据节点关系变化，导致数据迁移</li><li>迁移数量和添加节点数量有关：建议翻倍扩容</li></ul><h1 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h1><blockquote><p>前面取余是有问题的，加了节点之后它的数据迁移量是非常大的，无论是百分50还是百分80它影响的范围太大了，一致性hash就解决了这个问题</p></blockquote><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>将数据看成一个环，将数据做一个token环，这个token环的意思代表数据范围，0~2的32次方这样的范围，我们为每个节点去分配一个token，这个token是在范围内，比如节点1的范围：0到多少多少，节点2是多少多少，每一个范围负责一定的数据一部分token，当数据的key对它进行hash计算之后，它是在某范围内，例如图中的范围，它会去顺时针去找节点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572005650015-1572005654310.png" srcset="/img/loading.gif" alt="1572005650015"></p><h2 id="这样做有什么好处？"><a href="#这样做有什么好处？" class="headerlink" title="这样做有什么好处？"></a>这样做有什么好处？</h2><p>假如现在添加一个node5，这个node5是在1和2之间，我们为它分配了一个这样的token，这个时候做一个数据迁移是怎么样的？下一次哈希计算之后它落到node1和node5之间，这个时候数据会到node5上，这样就出现了数据偏移，但是它有一个好处：我添加一个节点之后不会影响node3和node4，只会影响node1、node2这些数据偏移，它的影响范围能缩小很多，尤其是在数据节点非常多的时候，假如环上有1000个节点，那现在在1000个节点中加入一个节点，它影响范围可能就只有1000分之1，一致性哈希在节点比较多的情况去使用，它还是一种缓存的使用方式，因为我原来在node2已经存的数据在node5，因为这个时候它的规格发生了变化，那它只能去node5去取，但node5没有就只能去数据库去回写，虽然它仍然是一个缓存的场景，无法实现将node2的数据迁移到node5这是它的一个问题；</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>客户端分片：哈希+顺时针（优化取舍）</li><li>节点伸缩：只影响邻近节点，但是还是有数据迁移</li><li>翻倍伸缩：现在我在2个节点之间添加一个节点，它没法实现数据的一个负载均衡，因为它添加节点之后，node3和node4还是负责很多数据，然后1和2和5数据量比较小所以它会出现流量和一些数据不均匀的情况，对于分布式数据库来说这不是一个很好的使用方式，所以在真正需要扩容的时候可能会使用翻倍扩容的方式</li></ul><h1 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大，这个槽你可以理解为一个数字，然后它有一定范围，比如0到383，这个是<code>RedisCluster</code>的范围，这个概念是比较抽象的，它每一个槽是负责大数据的一个子集，假如说现在我有10W个数据，16384个槽按照一定的哈希的规则，例如对每一个数据做一个hash，然后对16383进行取余，它落到槽范围内就证明是这个槽管理的数据，下面通过图进行说明</li><li>良好的哈希函数：例如CRC16</li><li>服务端管理节点、槽、数据：例如Redis Cluster</li></ul><h2 id="虚拟槽分配"><a href="#虚拟槽分配" class="headerlink" title="虚拟槽分配"></a>虚拟槽分配</h2><p>Redis Cluster模型</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572006846336.png" srcset="/img/loading.gif" alt="1572006846336"></p><p>现在有5个节点，对槽进行平均分成5份，例如0到3276是归节点1管理，13108到16383是到节点5去管理，对于每个key来将，我们对它做一个哈希，在Redis Cluster里面就是一个CRC16给它做一个哈希，然后对16383去取余，然后它会发送给Redis Cluster任意一个节点，它每一个节点都会记录自己是不是负责这个槽的，假如是算出这个值是100，我们发送给节点1，节点1发现它是在自己负责的槽的范围内，它去把它进行保存给它返回一个结果，如果它发现不在自己槽访问内：由于Redis Cluster节点之间是一个共享消息的模式，我节点1知道剩余的节点负责哪些槽，这样的话返回的结果会告诉你去其他节点去取，具体是哪个节点我也告诉你了，这就是一个服务端去管理数据和槽还有节点关系的一种模式，一致性哈希分布、取余哈希分布都有一个问题：我添加新的节点之后数据会进行迁移，会存在丢数据的可能性，所以它只能作为缓存场景使用，使用虚拟槽就不存在这样的问题，因为每个节点负责的槽范围是固定的，你加一个新节点也没有把其他节点的槽抢走，必须是我这个节点把我这个槽权利去分配给你，把数据根据槽分配给你，这样的话就不会有丢数据的这样的问题；</p><h1 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h1><p>服务端是很多个节点，每个节点负责去读也负责去写，而且节点之间是彼此通信的，它们彼此之间知道彼此负责的槽，然后把16384进行平均，每个节点负责一部分槽，客户端去访问任意节点的时候，如果它去访问的key在对应的节点上就给它直接返回，如果不在对应的节点就告诉它去其他节点去找，但是它不会为你做跳转，它会返回给你对应目标节点的结果，然后你去做对应的跳转，当然这种方式是有问题的：它的性能不够高，而且当节点非常多的时候，命中率不会很高；所以这种情况要使用智能客户端，用它去知道所有节点，客户端也知道每个节点负责哪些槽，而且这个槽和节点的关系发生变化的时候，客户端也会知道，这是一种高效的方式，这个在介绍客户端的时候会去说明，这里就记住几点：</p><ul><li>在Redis Cluster分布式情况下是互相通信的；</li><li>每个节点都会负责读写，因为每个节点都是数据集的一部分，这是分布式的特性；</li></ul><p><strong>Redis Cluster架构</strong></p><ul><li>Redis Cluster会有一堆节点，每个节点负责去读写；</li><li>它有一个meet操作，节点之间是进行相关通信的，meet操作就是完成这个过程的基础；</li><li>指派槽：每个节点指派了对应的槽它才可以去进行正常的读写，你现在去启动节点，然后它指定一个Cluster模式，这个后面可以看到，它不会正常读写，你要为它指派槽，当数据访问过来的时候它去看这个key是不是在自己槽范围内；</li><li>它为了保证高可用，它也提供了复制，每个主节点都有一个从节点，但是它有很多主节点，当主节点出现问题，它通过某种形式也可以实现主备高可用，主节点挂了 ，从节点会顶上来，它内部监控是没有依赖与Sentinel，而是通过节点之间的相互监控来完成的；</li></ul><p><strong>安装</strong></p><ul><li><p>对于节点来说它于普通Redis节点的区别就是它有一个<code>cluster-enabled</code>它是否是集群模式，如果是yes就以集群模式启动</p></li><li><p><code>meet</code>：假如说现在有3个节点，节点A对节点B发送了meet操作，它会返回<code>PONG</code>说明A和B已经可以进行消息交流了，然后当A发送给Cmeet的时候它也返回对应的结果，这个时候A和C根据某种协议通过B对A的了解，B可以找到对应的C，这样就完成了相互通信<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572008784267.png" srcset="/img/loading.gif" alt="1572008784267" style="zoom:25%;" /></p></li><li><p>指派槽：现在有3个主节点，但是有16384个槽，16384是<code>Redis Cluster</code>指定槽的数量，那么我们为了达到负责均衡的效果，会给每个节点指派指定的槽，例如给A节点指派0到5460，B：5461到10922，C：10923到16383，当我们一个key访问过来时候会计算它的哈希值，然后对16383去取一个余数，看它是否在对应一个槽的范围内，如果在就返回结果，如果不在返回对应的一个节点，因为它们直接彼此知道哪些槽是在哪个节点上，对于客户端来说客户端只需要计算一个key算出对应的slot</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1572009121295.png" srcset="/img/loading.gif" alt="1572009121295"></p><p><strong>RedisCluster特性</strong></p><p>它有主从复制，每个主节点都有从节点，而且他是高可用的，哪个主节点挂了，从节点都能完成一个晋升，而且它是分片的：多个主节点进行一个读写</p></li></ul><h1 id="原生安装"><a href="#原生安装" class="headerlink" title="原生安装"></a>原生安装</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><h3 id="两种安装"><a href="#两种安装" class="headerlink" title="两种安装"></a>两种安装</h3><ul><li>原生命令安装</li></ul><blockquote><p>通过RedisCluster协议，通过Redis-Cli从节点启动、meet、分配槽以及、分配主从关系来实现完整的安装过程</p></blockquote><ul><li>官方工具安装</li></ul><blockquote><p>使用Redis提供的ruby工具，它可以省去上面的过程，你只需要简单的配置就能一键安装</p></blockquote><h3 id="理解架构"><a href="#理解架构" class="headerlink" title="理解架构"></a>理解架构</h3><blockquote><p>通过一步一步手动去安装可以充分理解RedisCluster基本架构，</p></blockquote><ol><li>配置开启节点：这和普通启动没有太大区别，它只是加了一些cluster的一些配置</li><li>meet：实现节点之间的相互通信</li><li>指派槽：只有指派槽之后才能实现客户端数据的访问</li><li>主从：有了主从关系就能实现故障自动转移</li></ol><h3 id="配置开启Redis"><a href="#配置开启Redis" class="headerlink" title="配置开启Redis"></a>配置开启Redis</h3><h4 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h4><pre><code class="hljs nginx"><span class="hljs-attribute">port</span> <span class="hljs-variable">$port</span>]daemonize <span class="hljs-literal">yes</span>dir<span class="hljs-string">"/opt/redis/redis/data/</span><span class="hljs-string">dbfilename dump-S&#123;port&#125;. rdb</span><span class="hljs-string">logfile "</span><span class="hljs-variable">$&#123;port&#125;</span>.log<span class="hljs-string">"</span><span class="hljs-string">cluster-enabled yes#当前节点是一个cluster节点</span><span class="hljs-string">cluster-config-file nodes-<span class="hljs-variable">$&#123;port&#125;</span>.conf #为cluster节点添加一个自己的配置文件</span></code></pre><h4 id="开启节点"><a href="#开启节点" class="headerlink" title="开启节点"></a>开启节点</h4><pre><code class="hljs bash">redis-server redis-7000.confredis-server redis-7001.confredis-server redis-7002.confredis-server redis-7003.confredis-server redis-7004.confredis-server redis-7005.conf</code></pre><h4 id="meet"><a href="#meet" class="headerlink" title="meet"></a>meet</h4><p> <strong>语法</strong></p><pre><code class="hljs bash">cluster meet ip port</code></pre><p> <strong>例子</strong></p><pre><code class="hljs bash">redis-cli -h 127.0.0.1 -p 7000 cluster meet 120.0.0.1 7001redis-cli -h 127.0.0.1 -p 7000 cluster meet 120.0.0.1 7002redis-cli -h 127.0.0.1 -p 7000 cluster meet 120.0.0.1 7003redis-cli -h 127.0.0.1 -p 7000 cluster meet 120.0.0.1 7004redis-cli -h 127.0.0.1 -p 7000 cluster meet 120.0.0.1 7005</code></pre><h4 id="Cluster节点主要配置"><a href="#Cluster节点主要配置" class="headerlink" title="Cluster节点主要配置"></a>Cluster节点主要配置</h4><pre><code class="hljs nginx"> <span class="hljs-comment">#代表当前节点是一个cluster节点</span>clustetr-enabled yes<span class="hljs-comment">#单位毫秒，这里可以理解为它是一个故障转移的时间或者节点超时时间，这里不太好说，在Redis源代码中是有很多作用的，例如它是一个主观下线的超时时间以及他是一个ping的最长不能容忍时间的2分之1，一般来说使用默认配置</span>cluster-node-timeout 15000 <span class="hljs-comment">#集群节点配置，这里注意单机多部署，本次演示也是一个单机多部署情况下，都是用端口进行区分的</span>cluster-config-file "nodes.conf"<span class="hljs-comment">#是否需要对集群内所有节点提供服务，才能认为节点是正确的。假如我集群中一个节点挂了，那我对外就不提供服务了，这个默认是yes，在实际生产中这个配置是不合理的，所以一般会配置成no。</span>cluster-require-full-coverage yes</code></pre><h4 id="分配凑"><a href="#分配凑" class="headerlink" title="分配凑"></a>分配凑</h4><p><strong>语法</strong></p><pre><code class="hljs bash">cluster addslots slot [slot...]</code></pre><p><strong>例子</strong></p><pre><code class="hljs bash">redis-cli -h 127.0.0.1 -p 7000 clusuter addslot &#123;0...5461&#125;redis-cli -h 127.0.0.1 -p 7001 clusuter addslot &#123;5462...10922&#125;redis-cli -h 127.0.0.1 -p 7002 clusuter addslot &#123;10923...16383&#125;</code></pre><h4 id="设置主从"><a href="#设置主从" class="headerlink" title="设置主从"></a>设置主从</h4><p><strong>语法</strong></p><pre><code class="hljs bash">cluster replicate node-id <span class="hljs-comment">#集群节点的id,它在你集群节点启动的时候就会进行分配，这里的node-id和runid是不同的，因为runid会随着重启进行重置，而node-id不会被重置</span></code></pre><p><strong>例子</strong></p><pre><code class="hljs bash">redis-cli -h 127.0.0.1 -p 7003 cluster replicate <span class="hljs-variable">$&#123;node-id-7000&#125;</span>redis-cli -h 127.0.0.1 -p 7004 cluster replicate <span class="hljs-variable">$&#123;node-id-7001&#125;</span>redis-cli -h 127.0.0.1 -p 7005 cluster replicate <span class="hljs-variable">$&#123;node-id-7002&#125;</span></code></pre><blockquote><p>这里的node-id是如何获取的在后续的演示中进行介绍</p></blockquote><h2 id="具体安装"><a href="#具体安装" class="headerlink" title="具体安装"></a>具体安装</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code class="hljs bash">vim redis-7000.conf</code></pre><p>redis-7000.conf</p><pre><code class="hljs nginx"><span class="hljs-attribute">port</span> <span class="hljs-number">7000</span>daemonize <span class="hljs-literal">yes</span>dir <span class="hljs-string">"/usr/src/redis/data"</span>logfile <span class="hljs-string">"7000.log"</span>dbfilename <span class="hljs-string">"dump-7000.rdb"</span>cluster-enabled <span class="hljs-literal">yes</span>cluster-config-file nodes-<span class="hljs-number">7000</span>.confcluster-require-full-coverage <span class="hljs-literal">no</span></code></pre><p>其他节点</p><pre><code class="hljs bash">sed <span class="hljs-string">"s/7000/7002/g"</span> redis-7000.conf &gt; redis-7002.confsed <span class="hljs-string">"s/7000/7003/g"</span> redis-7000.conf &gt; redis-7003.confsed <span class="hljs-string">"s/7000/7004/g"</span> redis-7000.conf &gt; redis-7004.confsed <span class="hljs-string">"s/7000/7005/g"</span> redis-7000.conf &gt; redis-7005.conf</code></pre><p>启动</p><pre><code class="hljs bash">[root@mcr2 config] redis-server  redis-7000.conf[root@mcr2 config] redis-server  redis-7001.conf[root@mcr2 config] redis-server  redis-7002.conf[root@mcr2 config] redis-server  redis-7003.conf[root@mcr2 config] redis-server  redis-7004.conf[root@mcr2 config] redis-server  redis-7005.conf[root@mcr2 config] ps -ef | grep redisroot      10200      1  0 12:04 ?        00:00:00 redis-server *:7000 [cluster]root      10215      1  0 12:05 ?        00:00:00 redis-server *:7001 [cluster]root      10220      1  0 12:05 ?        00:00:00 redis-server *:7002 [cluster]root      10224      1  0 12:05 ?        00:00:00 redis-server *:7003 [cluster]root      10228      1  0 12:05 ?        00:00:00 redis-server *:7004 [cluster]root      10232      1  0 12:05 ?        00:00:00 redis-server *:7005 [cluster]root      10236   9913  0 12:05 pts/1    00:00:00 grep --color=auto redis</code></pre><p>现在连接7000端口的节点写入一条数据会出错</p><pre><code class="hljs bash">[root@mcr2 config]<span class="hljs-comment"># redis-cli -p 7000</span>127.0.0.1:7000&gt; <span class="hljs-built_in">set</span> k1 v1(error) CLUSTERDOWN The cluster is down</code></pre><blockquote><p>这是说你还没有分配槽，所以无法写入数据</p></blockquote><p>data文件中查看自动生成的文件：</p><pre><code class="hljs bash">[root@mcr2 data] ll<span class="hljs-comment"># xx.log...</span>-rw-r--r-- 1 root root     112 10月 26 12:04 nodes-7000.conf-rw-r--r-- 1 root root     112 10月 26 12:05 nodes-7001.conf-rw-r--r-- 1 root root     112 10月 26 12:05 nodes-7002.conf-rw-r--r-- 1 root root     112 10月 26 12:05 nodes-7003.conf-rw-r--r-- 1 root root     112 10月 26 12:05 nodes-7004.conf-rw-r--r-- 1 root root     112 10月 26 12:05 nodes-7005.conf[root@mcr2 data] cat nodes-7001.confb8706be32b3021222237479148acfbdeb9af9e55 :0 myself,master - 0 0 0 connectedvars currentEpoch 0 lastVoteEpoch 0</code></pre><blockquote><p>这里的<code>b8706be32b3021222237479148acfbdeb9af9e55</code>是nodeid，它的角色是<code>master</code>，myself表示自己，假如当前假如了后期节点的时候它就会有一些其他节点可以看到</p></blockquote><p>也可以通过命令去查看</p><pre><code class="hljs bash">[root@mcr2 data] redis-cli -p 7000 cluster nodes7486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 :7000 myself,master - 0 0 0 connected</code></pre><p>集群信息</p><pre><code class="hljs bash">[root@mcr2 data]<span class="hljs-comment"># redis-cli -p 7000 cluster info</span>cluster_state:fail<span class="hljs-comment">#集群状态：fail失败</span>cluster_slots_assigned:0<span class="hljs-comment">#集群分配的槽</span>cluster_slots_ok:0<span class="hljs-comment">#集配成功的槽</span>cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:1cluster_size:0cluster_current_epoch:0cluster_my_epoch:0cluster_stats_messages_sent:0cluster_stats_messages_received:0</code></pre><h3 id="meet-1"><a href="#meet-1" class="headerlink" title="meet"></a>meet</h3><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p  7000 cluster meet 127.0.0.1 7001OK[root@mcr2 config] redis-cli -p  7000 cluster meet 127.0.0.1 7002OK[root@mcr2 config] redis-cli -p  7000 cluster meet 127.0.0.1 7003OK[root@mcr2 config] redis-cli -p  7000 cluster meet 127.0.0.1 7004OK[root@mcr2 config] redis-cli -p  7000 cluster meet 127.0.0.1 7005OK</code></pre><p>meet完之后查看节点</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster nodesea47d9f8edeb000478512389731ca9132a69713d 127.0.0.1:7004 master - 0 1572078449112                                                                 3 connected16d4832afd3a8acdb4435e1be4acc733ec6377dd 127.0.0.1:7003 master - 0 1572078449614                                                                 5 connectedb8706be32b3021222237479148acfbdeb9af9e55 127.0.0.1:7001 master - 0 1572078450118                                                                 2 connected7486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 127.0.0.1:7000 myself,master - 0 0 1 co                                                                nnected67dcb98c8e4d12dc0f7a523b744566610821d8f2 127.0.0.1:7005 master - 0 1572078451125                                                                 4 connectedfc9247fe63eeb84196cc2fd0fe936627e1ed767a 127.0.0.1:7002 master - 0 1572078452132                                                                 0 connected</code></pre><h2 id="分配槽"><a href="#分配槽" class="headerlink" title="分配槽"></a>分配槽</h2><p>现在没分配槽的时候是不能进行读写的</p><pre><code class="hljs bash">[root@mcr2 config]  redis-cli -p 7000127.0.0.1:7000&gt; <span class="hljs-built_in">set</span> k1 v1(error) CLUSTERDOWN The cluster is down</code></pre><p>这里一个个设置很麻烦，这里写一个脚本</p><pre><code class="hljs bash">[root@mcr2 script] vim addslots.shstart=<span class="hljs-variable">$1</span>end=<span class="hljs-variable">$2</span>port=<span class="hljs-variable">$3</span><span class="hljs-keyword">for</span> slot <span class="hljs-keyword">in</span> `seq <span class="hljs-variable">$&#123;start&#125;</span> <span class="hljs-variable">$&#123;end&#125;</span>`<span class="hljs-keyword">do</span>        <span class="hljs-built_in">echo</span> <span class="hljs-string">"slot:<span class="hljs-variable">$&#123;slot&#125;</span>"</span>        redis-cli -p <span class="hljs-variable">$&#123;port&#125;</span> cluster addslots <span class="hljs-variable">$&#123;slot&#125;</span><span class="hljs-keyword">done</span></code></pre><p>执行脚本</p><pre><code class="hljs bash">[root@mcr2 script] sh addslots.sh  0 5461 7000</code></pre><p>查看信息</p><pre><code class="hljs bash">[root@mcr2 script] redis-cli -p 7000127.0.0.1:7000&gt; cluster infocluster_state:okcluster_slots_assigned:5462cluster_slots_ok:5462<span class="hljs-comment"># 5462个槽</span>cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:1cluster_current_epoch:5cluster_my_epoch:1cluster_stats_messages_sent:2277cluster_stats_messages_received:2277127.0.0.1:7000&gt; CLUSTER NODES....<span class="hljs-comment">#  nnected 0-5461 槽信息</span>7486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 127.0.0.1:7000 myself,master - 0 0 1 co                                                                nnected 0-5461</code></pre><p>其他节点分槽</p><pre><code class="hljs bash">[root@mcr2 script] sh addslots.sh  5462 10922 7001[root@mcr2 script] sh addslots.sh  10923 16383 7002</code></pre><p>现在查看cluster信息</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:5cluster_my_epoch:1cluster_stats_messages_sent:3114cluster_stats_messages_received:3114</code></pre><blockquote><p>这里集群状态是ok的，其他节点留着做从节点</p></blockquote><h2 id="主从分配"><a href="#主从分配" class="headerlink" title="主从分配"></a>主从分配</h2><p>前面介绍过，想要一个节点变成一个节点的从节点要通过<code>cluster replicate +node-id</code>，这里查看集群中的node-id</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster nodesea47d9f8edeb000478512389731ca9132a69713d 127.0.0.1:7004 master - 0 1572079922359 3 connected16d4832afd3a8acdb4435e1be4acc733ec6377dd 127.0.0.1:7003 master - 0 1572079920347 5 connectedb8706be32b3021222237479148acfbdeb9af9e55 127.0.0.1:7001 master - 0 1572079923367 2 connected 5462-109227486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 127.0.0.1:7000 myself,master - 0 0 1 connected 0-546167dcb98c8e4d12dc0f7a523b744566610821d8f2 127.0.0.1:7005 master - 0 1572079921353 4 connectedfc9247fe63eeb84196cc2fd0fe936627e1ed767a 127.0.0.1:7002 master - 0 1572079924374 0 connected 10923-16383</code></pre><p>7003端口的节点做7000端口节点的从节点</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7003 cluster replicate 7486b5c98c7c644bdcc992ec8a0b0a9d711c5a49OK</code></pre><p>这里再次使用<code>cluster nodes</code>，可以看到，它是一个slave节点</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster nodes16d4832afd3a8acdb4435e1be4acc733ec6377dd 127.0.0.1:7003 slave 7486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 0 1572080237607 5 connected</code></pre><p>7004端口复制7001</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7004 cluster replicate b8706be32b3021222237479148acfbdeb9af9e55OK</code></pre><p>7005复制7002</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7005 cluster replicate fc9247fe63eeb84196cc2fd0fe936627e1ed767aOK</code></pre><p>现在一个3主3从的集群就搭建完成了</p><pre><code class="hljs bash">[root@mcr2 config]<span class="hljs-comment"># redis-cli -p 7000 cluster nodes</span>ea47d9f8edeb000478512389731ca9132a69713d 127.0.0.1:7004 slave b8706be32b30212222                                                                37479148acfbdeb9af9e55 0 1572080526708 3 connected16d4832afd3a8acdb4435e1be4acc733ec6377dd 127.0.0.1:7003 slave 7486b5c98c7c644bdc                                                                c992ec8a0b0a9d711c5a49 0 1572080529728 5 connectedb8706be32b3021222237479148acfbdeb9af9e55 127.0.0.1:7001 master - 0 1572080530735                                                                 2 connected 5462-109227486b5c98c7c644bdcc992ec8a0b0a9d711c5a49 127.0.0.1:7000 myself,master - 0 0 1 co                                                                nnected 0-546167dcb98c8e4d12dc0f7a523b744566610821d8f2 127.0.0.1:7005 slave fc9247fe63eeb84196                                                                cc2fd0fe936627e1ed767a 0 1572080531743 4 connectedfc9247fe63eeb84196cc2fd0fe936627e1ed767a 127.0.0.1:7002 master - 0 1572080528217                                                                 0 connected 10923-16383</code></pre><p>查看槽的分布信息</p><pre><code class="hljs bash">[root@mcr2 config]<span class="hljs-comment"># redis-cli -p 7000 cluster slots</span>1) 1) (<span class="hljs-built_in">integer</span>) 5462   2) (<span class="hljs-built_in">integer</span>) 10922   3) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7001   4) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 70042) 1) (<span class="hljs-built_in">integer</span>) 0   2) (<span class="hljs-built_in">integer</span>) 5461   3) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7000   4) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 70033) 1) (<span class="hljs-built_in">integer</span>) 10923   2) (<span class="hljs-built_in">integer</span>) 16383   3) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7002   4) 1) <span class="hljs-string">"127.0.0.1"</span>      2) (<span class="hljs-built_in">integer</span>) 7005</code></pre><h1 id="官方工具安装"><a href="#官方工具安装" class="headerlink" title="官方工具安装"></a>官方工具安装</h1><h2 id="Ruby环境准备"><a href="#Ruby环境准备" class="headerlink" title="Ruby环境准备"></a>Ruby环境准备</h2><blockquote><p>RedisCluster提供了Ruby安装脚本，相比我们使用Redis-cli简单很多，但是使用它需要环境搭建，这里就来介绍一下Ruby环境</p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>下载、编译、安装Ruby</li><li>安装<code>rubygem redis</code>客户端</li><li>安装<code>redis-trib.rb</code></li></ol><p>（1）下载ruby</p><pre><code class="hljs bash">wget https://cache.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz</code></pre><p>（2）安装ruby</p><pre><code class="hljs bash">tar -xvf ruby-2.3.1.tar.gz ./configure -prefix=/usr/<span class="hljs-built_in">local</span>/rubymakemake install<span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/rubycp bin/ruby /usr/<span class="hljs-built_in">local</span>/bin</code></pre><p>（3）安装 rubygem redis</p><pre><code class="hljs bash">wget http://rubygems.org/downloads/redis-3.3.0.gemgem install -i redis-3.3.0.gemgem list --check redis gem</code></pre><p>（4）安装redis-trib.rb</p><pre><code class="hljs bash">cp $<span class="hljs-variable">$&#123;REDIS_HOME&#125;</span>/src/redis-trib.rb /usr/<span class="hljs-built_in">local</span>/bin</code></pre><h2 id="ruby环境准备-操作"><a href="#ruby环境准备-操作" class="headerlink" title="ruby环境准备-操作"></a>ruby环境准备-操作</h2><pre><code class="hljs bash">[root@mcr2 opt] wget https://cache.rubylang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz[root@mcr2 opt] tar -xvf ruby-2.3.1.tar.gz  -C /usr/src[root@mcr2 opt] <span class="hljs-built_in">cd</span> /usr/src/ruby-2.3.1/[root@mcr2 ruby-2.3.1] ./configure -prefix=/usr/<span class="hljs-built_in">local</span>/ruby[root@mcr2 ruby-2.3.1] make &amp;&amp; make install....等待[root@mcr2 ruby-2.3.1] cp ruby /usr/<span class="hljs-built_in">local</span>/bin[root@mcr2 ruby-2.3.1] ruby  -vruby 2.3.1p112 (2016-04-26 revision 54768) [x86_64-linux][root@mcr2 bin] <span class="hljs-built_in">pwd</span>/usr/<span class="hljs-built_in">local</span>/ruby/bin[root@mcr2 bin] cp gem /usr/<span class="hljs-built_in">local</span>/bin/</code></pre><p>安装redis客户端</p><pre><code class="hljs bash">[root@mcr2 src] <span class="hljs-built_in">pwd</span>/usr/src[root@mcr2 src] wget http://rubygems.org/downloads/redis3.3.0.gem[root@mcr2 src] gem install -l redis-3.3.0.gem<span class="hljs-comment">#检查是否有让edis</span>[root@mcr2 src] gem list -- check redis gem*** LOCAL GEMS ***bigdecimal (1.2.0)io-console (0.4.2)json (1.7.7)psych (2.0.0)rdoc (4.0.0)redis (3.3.0)[root@mcr2 redis] <span class="hljs-built_in">cd</span> /usr/src/redis/src[root@mcr2 src] ./redis-trib.rb....</code></pre><h2 id="redis-trib构建集群"><a href="#redis-trib构建集群" class="headerlink" title="redis-trib构建集群"></a>redis-trib构建集群</h2><p>将<code>redis-trib.rb</code>命令放到全局</p><pre><code class="hljs bash">cp <span class="hljs-variable">$&#123;REDIS_HOME&#125;</span>/src/redis-trib.rb /usr/<span class="hljs-built_in">local</span>/bin</code></pre><p>一键开启</p><blockquote><p>这里的节点端口分别为8000、8001、8002、8003、8004、8005</p></blockquote><pre><code class="hljs bash">./redis-trib.rb create --replicas 1 127.0.0.1:8000\ 127.0.0.1:8001\127.0.0.1:8002 127.00.1:8003\127.0.0.1:8004 127.0.0.1:8005</code></pre><blockquote><p>这里的语法为 ./redis-trib.rb create –replicas  [ 从节点数量 ]    ip:[port]    [ ip:[port]  ] …，这里我们只要一个从节点，所有写的是1，在我们执行的命令中，前面3个是主节点，后面3个是从节点，也就是8000和8003对应、8001和8004、8002和8005，如果你需要2个从节点，那你在主节点后面加6个从节点，当你所填的数量以及它的格式不符合标准，它会返回给你错误</p></blockquote><p>首先将之前的redis集群全部关闭</p><pre><code class="hljs bash">[root@mcr2 config] ps -ef | grep redis-server | grep 700 | awk <span class="hljs-string">'&#123;print $2&#125;'</span> | xargs <span class="hljs-built_in">kill</span></code></pre><p>将data目录的数据清除</p><pre><code class="hljs bash">[root@mcr2 config] <span class="hljs-built_in">cd</span> ../data[root@mcr2 data] rm -rf *</code></pre><p>启动redis服务</p><pre><code class="hljs bash">[root@mcr2 config] redis-server redis-7000.conf[root@mcr2 config] redis-server redis-7001.conf[root@mcr2 config] redis-server redis-7002.conf[root@mcr2 config] redis-server redis-7003.conf[root@mcr2 config] redis-server redis-7004.conf[root@mcr2 config] redis-server redis-7005.conf</code></pre><p>使用<code>redis-trib.rb</code>搭建集群</p><pre><code class="hljs bash">[root@mcr2 config] redis-trib.rb  create   --replicas 1 \&gt;  127.0.0.1:7000  127.0.0.1:7001  127.0.0.1:7002 \&gt;  127.0.0.1:7003  127.0.0.1:7004  127.0.0.1:7005</code></pre><p>执行完上面的命令会有这些内容，这里是主从对应关系</p><pre><code class="hljs bash">Adding replica 127.0.0.1:7003 to 127.0.0.1:7000Adding replica 127.0.0.1:7004 to 127.0.0.1:7001Adding replica 127.0.0.1:7005 to 127.0.0.1:7002</code></pre><p>还有node-id，槽的范围，节点是从还是主</p><pre><code class="hljs bash">M: 709ce3bd4d8fba5f62f57d7ec3b64569a070f22d 127.0.0.1:7000   slots:0-5460 (5461 slots) masterM: d030b2dc316d9c58a4a0b14dcc31e49108d76f9f 127.0.0.1:7001   slots:5461-10922 (5462 slots) masterM: 325733e9d4ded75d31c68f978c75357334163428 127.0.0.1:7002   slots:10923-16383 (5461 slots) masterS: 7a0624a0256fc0f00c1c66096dafda41157fc9dc 127.0.0.1:7003   replicates 709ce3bd4d8fba5f62f57d7ec3b64569a070f22dS: 4052a3fa7cfe1b2ce293b05223516d5819c34ef0 127.0.0.1:7004   replicates d030b2dc316d9c58a4a0b14dcc31e49108d76f9fS: df4b8f2b54c36853d234a079cc273ad300917f2c 127.0.0.1:7005   replicates 325733e9d4ded75d31c68f978c75357334163428</code></pre><p>最后它问你同意这个配置吗，这里输入yes</p><pre><code class="hljs bash">Can I <span class="hljs-built_in">set</span> the above configuration? (<span class="hljs-built_in">type</span> <span class="hljs-string">'yes'</span> to accept): yes</code></pre><p>这里环境就搭建完成了，来检验一下</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 7000 cluster nodesdf4b8f2b54c36853d234a079cc273ad300917f2c 127.0.0.1:7005 slave 325733e9d4ded75d31c68f978c75357334163428 0 1572138063357 6 connected709ce3bd4d8fba5f62f57d7ec3b64569a070f22d 127.0.0.1:7000 myself,master - 0 0 1 connected 0-54604052a3fa7cfe1b2ce293b05223516d5819c34ef0 127.0.0.1:7004 slave d030b2dc316d9c58a4a0b14dcc31e49108d76f9f 0 1572138060334 5 connectedd030b2dc316d9c58a4a0b14dcc31e49108d76f9f 127.0.0.1:7001 master - 0 1572138062348 2 connected 5461-109227a0624a0256fc0f00c1c66096dafda41157fc9dc 127.0.0.1:7003 slave 709ce3bd4d8fba5f62f57d7ec3b64569a070f22d 0 1572138057313 4 connected325733e9d4ded75d31c68f978c75357334163428 127.0.0.1:7002 master - 0 1572138061342 3 connected 10923-16383[root@mcr2 config] redis-cli -p 7000 cluster infocluster_state:okcluster_slots_assigned:16384cluster_slots_ok:16384cluster_slots_pfail:0cluster_slots_fail:0cluster_known_nodes:6cluster_size:3cluster_current_epoch:6cluster_my_epoch:1cluster_stats_messages_sent:106cluster_stats_messages_received:106</code></pre><h1 id="原生命令和redis-trib-rb对比"><a href="#原生命令和redis-trib-rb对比" class="headerlink" title="原生命令和redis-trib.rb对比"></a>原生命令和redis-trib.rb对比</h1><h2 id="原生命令安装"><a href="#原生命令安装" class="headerlink" title="原生命令安装"></a>原生命令安装</h2><ul><li>理解Redis Cluster架构；</li><li>生产环境不使用。</li></ul><h2 id="官方工具安装-1"><a href="#官方工具安装-1" class="headerlink" title="官方工具安装"></a>官方工具安装</h2><ul><li>高效、准确</li><li>生产环境可以使用。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>可视化部署；</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 7.RedisSentinel</title>
    <link href="/redis-7.html"/>
    <url>/redis-7.html</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制高可用"><a href="#主从复制高可用" class="headerlink" title="主从复制高可用"></a>主从复制高可用</h1><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ul><li>为主提供备份，当主挂掉在备份中有一个完整的数据</li><li>为主实现一个分流，将大部分读放到从节点中去执行，减轻主节压力</li></ul><h2 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h2><p>如果说主节点挂掉了，那么当有客户端传送写的命令就无法进行执行了，在生产环境中是无法忍受的，我们不得不手动的将主节点进行重启，然后将其中一个<code>slave</code>节点执行<code>slaveof no one</code>将它变为一个<code>master</code>节点，然后再将其他节点对这个<code>master</code>节点进行复制，然后去迁移使用Redis的客户端，这个功能可以用脚本来实现，但是有几个点是很复杂的：</p><ol><li>你怎么判断一个<code>Redis</code>节点有问题</li><li>怎么去通知客户端；</li><li>一个完整的过程怎么去保证一个完整事务的实现，对于一般的开发中或者运维人员来说单独实现这样的功能是比较困难的</li></ol><p>Redis也想到了这样的问题，它为我们提供了<code>Redis Sentinel</code>这样一个高可用实现</p><h1 id="Redis-Sentinel基本架构"><a href="#Redis-Sentinel基本架构" class="headerlink" title="Redis Sentinel基本架构"></a>Redis Sentinel基本架构</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571664454309.png" srcset="/img/loading.gif" alt="1571664454309"></p><p>前面提到的几个问题，通过<code>Redis Sentinel</code>都能解决，在<code>Redis</code>做主从复制时，如果使用了<code>Redis Sentinel</code>，当<code>master</code> 节点挂了之后它会执行以下步骤：</p><ol><li>多个sentinel发现并确认master有问题；</li><li>选举出一个<code>sentinel</code>做为领导；</li><li>选出一个slave做为<code>master</code>；</li><li>通知其余slave成为新的master的slave；</li><li>通知客户端主从变化；</li><li>等待老的master复活成新的master的slave。</li></ol><p>Redis Sentinel会分为多个节点，你可以把它想象成<code>Redis</code>的进程，但<code>Redis Sentinel</code>不会去存储数据，它作用是对<code>Redis</code>一个故障判断和故障转移的处理和通知客户端的过程，在图中可以看出它是有多个，这样可以提高监控能力，如果一个<code>Sentinel</code>节点挂了还是可以保证进行监控的作用；</p><hr><p>现在客户端不会从<code>Redis</code>直接获取信息，它不再记录Redis的地址，它会记录<code>Redis Sentinel</code>的地址，例如可以写多个<code>Redis Sentinel</code>，客户端通过<code>Redis Sentinel</code>获取<code>Redis</code>的地址，这样做有什么好处？首先<code>Redis Sentinel</code>会对<code>Redis</code>节点进行监控，它知道谁是<code>master</code>、<code>slave</code>节点，在这里，由于master节点可能会挂掉，<code>Redis Sentinel</code>会对客户端进行一个通知谁是主节点，对于客户端来说就不用关心谁是<code>master</code>，这样在master出现故障的时候，<code>Redis Sentinel</code>会进行一个故障转移，这个时候由于<code>master</code>节点改变了，之前需要在客户端修改<code>Redis</code>的<code>master</code>节点连接信息，现在就不再需要这么做，因为<code>Redis Sentinel</code>会通知客户端新的<code>master</code>节点是哪个；</p><hr><p><code>Redis Sentinel</code>还可以监控多个<code>master-slave</code>,这个在它内部是有实现的，这样就可以实现一套<code>Redis Sentinel</code>监控多台<code>master-slave</code>，这样可以有效减少资源，每套<code>master-slave</code>会使用一个<code>master-name</code>的一个配置做一个标识</p><h1 id="Redis-Sentine安装"><a href="#Redis-Sentine安装" class="headerlink" title="Redis Sentine安装"></a>Redis Sentine安装</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>配置开启中从节点；</li><li>配置开启sentinel监控主节点（sentinel是特殊的Redis）</li><li>实际应用多台机器；</li><li>详细配置节点。</li></ol><h3 id="Redis主节点"><a href="#Redis主节点" class="headerlink" title="Redis主节点"></a>Redis主节点</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571667275501.png" srcset="/img/loading.gif" alt="1571667275501"></p><h3 id="Redis从节点"><a href="#Redis从节点" class="headerlink" title="Redis从节点"></a>Redis从节点</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571667303435.png" srcset="/img/loading.gif" alt="1571667303435"></p><h3 id="sentinel主要配置"><a href="#sentinel主要配置" class="headerlink" title="sentinel主要配置"></a>sentinel主要配置</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571667449325.png" srcset="/img/loading.gif" alt="1571667449325"></p><blockquote><p>图中4-7配置是它的核心配置，这里简单的进行介绍一下：</p><p>4：监控主节点的名字是什么，ip是什么，最后这个“2”表示我们几个<code>sentinel</code>对这个<code>master</code>    认为它有问题了才发动故障转移；</p><p>5：<code>sentinel</code>对master节点定时进行ping操作，如果ping不通就代表是有问题的；</p><p>6：当选了新的<code>master</code>之后，把其他老的<code>slave</code>对新的<code>master</code>进行复制，这里指复制的行为是并发的还是串行的，1表示每次只能复制一个，优点是可以减轻<code>master</code>的压力</p><p>7：这里先不说</p></blockquote><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><pre><code class="hljs bash">vim redis-7000.conf<span class="hljs-comment">#内容：</span>port 7000daemonize yespidfile /var/run/redis-7000.pidlogfile <span class="hljs-string">"7000.log"</span>dir <span class="hljs-string">"/usr/src/redis/data"</span></code></pre><h3 id="从节点"><a href="#从节点" class="headerlink" title="从节点"></a>从节点</h3><pre><code class="hljs bash">sed <span class="hljs-string">"s/7000/7001/g"</span> redis-7000.conf &gt;  redis-7001.confsed <span class="hljs-string">"s/7000/7002/g"</span> redis-7000.conf &gt;  redis-7002.conf<span class="hljs-built_in">echo</span> <span class="hljs-string">"slaveof 192.168.202.102 7000"</span> &gt;&gt; redis-7001.conf<span class="hljs-built_in">echo</span> <span class="hljs-string">"slaveof 192.168.202.102 7000"</span> &gt;&gt; redis-7002.conf</code></pre><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code class="hljs bash">redis-server redis-7000.confredis-server redis-7001.confredis-server redis-7002.conf</code></pre><h3 id="安装Redis-Sentine"><a href="#安装Redis-Sentine" class="headerlink" title="安装Redis Sentine"></a>安装Redis Sentine</h3><p>Sentine配置模板在Redis目录名为：<code>sentinel.conf</code>，这里将它拷贝到config目录中进行一个配置</p><pre><code class="hljs bash">cp sentinel.conf config<span class="hljs-built_in">cd</span> config<span class="hljs-comment">#去注释</span>cat sentinel.conf  | grep -v <span class="hljs-string">"#"</span> | grep -v <span class="hljs-string">"^$"</span> &gt; redis-sentinel-26379.conf</code></pre><p>redis-sentinel-26379.conf内容：</p><pre><code class="hljs nginx"><span class="hljs-attribute">port</span> <span class="hljs-number">26379</span>daemonize <span class="hljs-literal">yes</span>dir <span class="hljs-string">"/usr/src/redis/data/"</span>logfile <span class="hljs-string">"26379.log"</span>sentinel monitor mymaster <span class="hljs-number">192.168.202.102</span> <span class="hljs-number">7000</span> <span class="hljs-number">2</span>sentinel down-after-milliseconds mymaster <span class="hljs-number">30000</span>sentinel parallel-syncs mymaster <span class="hljs-number">1</span>sentinel failover-timeout mymaster <span class="hljs-number">180000</span></code></pre><blockquote><p>这里没有配置从节点信息，只配置了主节点信息，因为它可以通过主节点中执行<code>info replication</code>来获取从节点信息</p></blockquote><p>启动</p><pre><code class="hljs bash">redis-sentinel redis-sentinel-26379.conf</code></pre><p>配置多个并启动</p><pre><code class="hljs java">sed <span class="hljs-string">"s/26379/26380/g"</span> redis-sentinel-<span class="hljs-number">26379</span>.conf &gt; redis-sentinel-<span class="hljs-number">26380</span>.confsed <span class="hljs-string">"s/26379/26381/g"</span> redis-sentinel-<span class="hljs-number">26379</span>.conf &gt; redis-sentinel-<span class="hljs-number">26381</span>.confredis-sentinel redis-sentinel-<span class="hljs-number">26380</span>.confredis-sentinel redis-sentinel-<span class="hljs-number">26381</span>.conf</code></pre><p>查看信息</p><pre><code class="hljs bash">redis-cli  -p 26379 info<span class="hljs-comment"># Server</span>redis_version:3.0.7redis_git_sha1:00000000redis_git_dirty:0redis_build_id:525f217f06e56f1redis_mode:sentinelos:Linux 3.10.0-1062.1.2.el7.x86_64 x86_64arch_bits:64multiplexing_api:epollgcc_version:4.8.5process_id:2781run_id:07bfbcc4b430d20a96e8700fe936b556a8ec6067tcp_port:26379uptime_in_seconds:1021uptime_in_days:0hz:13lru_clock:11420702config_file:/usr/src/redis/config/redis-sentinel-26379.conf<span class="hljs-comment"># Sentinel</span>sentinel_masters:1sentinel_tilt:0sentinel_running_scripts:0sentinel_scripts_queue_length:0master0:name=mymaster,status=ok,address=127.0.0.1:7000,slaves=2,sentinels=3</code></pre><blockquote><p>这里看最后一个：这里的sentinels为3，这就意味着，它们之间是能互相感知的</p></blockquote><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571759631135.png" srcset="/img/loading.gif" alt="1571759631135"></p><h1 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h1><blockquote><p>通过<code>Redis</code>的故障进行演练，为了演练这个东西，首先将<code>master</code>节点直接干掉，然后我们去写一个客户端，不断的去死循环客户端实现，当它自动去做故障转移的时候观察一下客户端的反应，最后再来分析<code>master</code>、<code>slave</code>日志</p></blockquote><p> pom依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.28<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>Java代码</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.jedis.demo;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSentinelFailoverTest</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(RedisSentinelFailoverTest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">final</span> String masterName = <span class="hljs-string">"mymaster"</span>;        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();        sentinels.add(<span class="hljs-string">"mcr2.com:26379"</span>);        sentinels.add(<span class="hljs-string">"mcr2.com:26380"</span>);        sentinels.add(<span class="hljs-string">"mcr2.com:26381"</span>);        JedisSentinelPool jedisSentinelPool = <span class="hljs-keyword">new</span> JedisSentinelPool(masterName, sentinels);        <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;            counter++;            Jedis jedis = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;                jedis = jedisSentinelPool.getResource();                <span class="hljs-keyword">int</span> index = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">100000</span>);                String key = <span class="hljs-string">"k-"</span> + index;                String value = <span class="hljs-string">"v-"</span> + index;                jedis.set(key, value);                <span class="hljs-keyword">if</span> (counter % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123;                    logger.info(<span class="hljs-string">"&#123;&#125; value is &#123;&#125;"</span>, key, jedis.get(key));                &#125;                TimeUnit.MICROSECONDS.sleep(<span class="hljs-number">1000</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                logger.error(e.getMessage(), e);                e.printStackTrace();            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">if</span> (jedis != <span class="hljs-keyword">null</span>) &#123;                    jedis.close();                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><p>杀掉主节点</p><pre><code class="hljs bash">[root@mcr2 config] ps -ef | grep redis-server | grep 7000[root@mcr2 config] <span class="hljs-built_in">kill</span> -9 6276</code></pre><p>这个时候的主节点变为了：</p><pre><code class="hljs bash">[root@mcr2 config] redis-cli -p 26379 infomaster0:name=mymaster,status=ok,address=192.168.202.102:7001,slaves=2,sentinels=3</code></pre><p>这个时候的控制台上依旧可以正常执行命令</p><h1 id="三个定时器"><a href="#三个定时器" class="headerlink" title="三个定时器"></a>三个定时器</h1><ol><li><p>每10秒每个sentinel对master和slave执行info</p><ul><li><p>发现slave节点</p></li><li><p>确认主从关系</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571838045174-1571838045933.png" srcset="/img/loading.gif" alt="1571838045174"></p></li></ul></li><li><p>每2秒每个sentinel通过master节点的channel交换信息（pub/sub）</p><ul><li><p>通过<code>_sasentinel_:heloo</code>频道交互</p></li><li><p>交互对节点的“看法”和自身信息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571838089475-1571838118960.png" srcset="/img/loading.gif" alt="1571838089475"></p></li></ul></li><li><p>每1秒每个sentinel对其他sentinel和redis执行ping</p></li></ol><ul><li><p>心跳检测，失败判断依据</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571838194743.png" srcset="/img/loading.gif" alt="1571838194743"></p></li></ul><h1 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h1><pre><code class="hljs nginx"><span class="hljs-comment"># 监控master节点，参数： quorum：法定人数，当达到一个法定人数时候才可以做下一步工作,这里配置的quorum配置的是一个2，这个2一般来说是这样的格式：例如现在有3个sentinel节点，那么就配置2，如果有5个就配3，建议是`节点数除以2去+1`，这里补充一下：sentinel节点最好是3个以上的基数，就像zoomkeeper那样的规则</span><span class="hljs-attribute">sentinel</span> monitor &lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; <span class="hljs-comment"># 例子</span>sentinel monitor myMaster <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">6379</span> <span class="hljs-number">2</span>sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;<span class="hljs-comment"># 主观下线的判断，一个sentinel对master或者slave节点的要求，前面说过：每个Sentinel会每一个去ping slave和master，如果超过30秒还是没有收到回复，它就会做下线的判断</span>sentinel down-after-milliseconds mymaster <span class="hljs-number">30000</span></code></pre><ul><li><p>主观下线：每个sentinel节点对Redis节点失败的“偏见”</p></li><li><p>客观下线：所有sentinel节点对Redis节点失败“达成共识”（超过quorum个统一），</p><p><code>sentinel is-master-down-by-addr</code>：问一下对应的sentinel节点是否你也认为当前这个master节点节点做一个客观下线</p></li></ul><h1 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h1><ul><li><p>原因：只有一个sentinel节点完成故障转移</p></li><li><p>选举：通过<code>sentinel is-master-down-by-addr</code>命令都希望成为领导者，<code>sentinel is-master-down-by-addr</code>有2个作用：</p><p>（1）对<code>master</code>节点的失败判定；</p><p>（2）用来进行领导者选举。</p><ol><li>每个做主观下线的<code>sentinel</code>节点向其他<code>sentinel</code>节点发送命令，要求它设置为领导者，例如有3个<code>sentinel</code>节点，1完成主观下线，然后1去问2、3你是否同意自己成为领导者；</li><li>收到命令的<code>sentinel</code>节点如果没有同意其他sentinel节点发送的命令，那么将同意该请求，否则拒绝；</li><li>如果该<code>sentinel</code>节点发现自己的票数已经超过个<code>sentinel</code>集合半数且超过<code>quorum</code>，那么它将成为领导者；</li><li>如果此过程有多个sentinel节点成为了领导者，那么将等待一段时间重新进行选举。</li></ol></li></ul><h1 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h1><ul><li>从slave节点中选出一个“合适的”节点作为新的master节点；<ul><li>选择<code>slave-priority</code>（slave节点优先级）最高的slave节点，如果存在则返回，不存在则继续，<code>slave-priority</code>表示优先级，这个配置一般是不配置的，所以在slave节点中优先级都是一样的，这个在什么场景下会使用呢？比如说现在一个master，2个slave节点，然后希望性能好的机器变成master，这个时候就会用到<code>slave-priority</code>；</li><li>上面继续的话：选择复制偏移量最大的slave节点（复制的最完整），如果它和master偏移量比较接近就正面它与master数据一致性会更高一点，因为这个时候master节点挂掉了，可能出现了数据问题，这个时候写入量最大的节点变成master，如果存在则返回，不存在则继续，</li><li>上面继续的话：选择runId最小的slave节点。</li></ul></li><li>对上面的slave节点执行<code>slaveof no one</code>命令让其成为<code>master</code>节点，复制规则和<code>parallel-syncs</code>参数有关，<code>parallel-syncs</code>：假如说现在<code>Redis</code>上是一主三从，现在主挂掉了，sentinel选择了一个<code>slave</code>节点作为<code>master</code>，剩下其他的去复制这个<code>master</code>，如果这个<code>parallel-syncs</code>参数为2的话，2个slave去同时做复制操作，这个是对<code>master</code>端做优化的，它就只做一次<code>RDB</code>生成而减少一定成本，但是它会去完成<code>RDB</code>文件操作以及<code>buffer</code>的发送，对于<code>master</code>节点是有一定开销的，这个过程中它会占用很多的网络资源去传输<code>RDB</code>文件，这个要根据<code>Redis</code>的<code>master</code>使用的内存大小有关的，加入这个参数配置为1的话，它们是一个顺序的过程，首先的一个slave节点去完成复制，第二个节点去完成复制，这样有效减少<code>master</code>节点开销，例如你希望所有slave节点快速的进行恢复，例如你用了读写分离的东西，你 希望能快速恢复这个参数可以设置大一点，如果你希望资源得到合理的保护那就配置为1；</li><li>更新对原来<code>master</code>节点设置为<code>slave</code>，并保持着对其“关注”，当其恢复后命令它去复制新的<code>master</code>节点；</li></ul><h1 id="常见开发运维问题"><a href="#常见开发运维问题" class="headerlink" title="常见开发运维问题"></a>常见开发运维问题</h1><h2 id="节点运维"><a href="#节点运维" class="headerlink" title="节点运维"></a>节点运维</h2><ul><li>机器下线：例如过保等情况，公司、个人的机器都有一个保质期，这个这个保质期内会对它进行下线，比如说这个机器已经使用了5年，它现在不在自保范围内，那么我们就需要将它进行下线，这个机器上会有很多服务，其中就有Redis服务，这里有Sentinel、主节点、从节点；</li><li>机器性能不足：一些很老的机器某些硬件可能不太稳定，例如CPU、内存、硬盘、网络这些都不是很问题，例如网络切换到一个万兆网卡，硬盘为了满足性能要求会使用SSD，内存需要在一个更大的机器上去运行，CPU要换更好的，这个时候就需要对机器做一个上下线操作；</li><li>节点自身故障：节点出现问题，但是由于某些原因暂时找不到这个问题的存在点，有的时候因为机器、系统一些原因造成的，这个时候可能会对它做一个迁移或者下线，将它做到其他机器。</li></ul><h3 id="主节点-1"><a href="#主节点-1" class="headerlink" title="主节点"></a>主节点</h3><pre><code class="hljs bash">sentinel failover &lt;masterName&gt; <span class="hljs-comment">#故障转移过程，这是一个手动的过程，它去忽略了主观下线、客观下线、领导者选举，这里的领导者是执行这个命令的节点，它已经确定你要下线master，这里就会执行进行故障转移</span></code></pre><h3 id="从节点-1"><a href="#从节点-1" class="headerlink" title="从节点"></a>从节点</h3><ul><li>确认是临时下线还是永久下线，临时下线是暂时关闭掉之后重启，永久下线表示我真的不需要它了，不在这个机器上了就需要干掉，这个时候还要做一些清理工作，例如一些配置、一些数据以及RDB、AOF都要做一些处理，因为单机多部署的话可能一些配置文件在启动其他进程的时候会有一些干扰，而且从节点在下线的时候要考虑一个读写分离的情况，因为有的时候使用读写分离从节点是一个读写分离的进程，它有很多的客户端去连接；</li><li>Sentinel同上</li></ul><h3 id="节点上线"><a href="#节点上线" class="headerlink" title="节点上线"></a>节点上线</h3><ul><li>主节点：希望某个从节点升为主节点，执行命令<code>sentinel failover</code>，并调整希望变成主节点的优先级；</li><li>从节点：<code>slaveof</code>即可，sentinel节点可以感知；</li><li>sentinel节点：参考其他sentinel节点启动即可，通过channel实现信息共享。</li></ul><h1 id="高可用读写分离"><a href="#高可用读写分离" class="headerlink" title="高可用读写分离"></a>高可用读写分离</h1><blockquote><p>去看一看JedisSentinelPool的实现</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 6.Redis复制原理和优化</title>
    <link href="/redis-6.html"/>
    <url>/redis-6.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是主从复制"><a href="#什么是主从复制" class="headerlink" title="什么是主从复制"></a>什么是主从复制</h1><h2 id="单机有什么问题？"><a href="#单机有什么问题？" class="headerlink" title="单机有什么问题？"></a>单机有什么问题？</h2><ul><li>在一台机器去部署一个<code>Redis</code>节点，如果我们机器发生故障，例如机器磁盘、CPU、主板坏了，那我们客户端怎么连接<code>Redis</code>？</li><li>Redis节点宕掉了，需要进行重启，这里重启期间，客户端是连接不上<code>Redis</code>的,而且你也不能在第一时间发现<code>Redis</code>宕掉了；</li><li>假如机器有<code>16G</code>内存，而Redis用了<code>12G</code>内存，现在有一个需求：我真的需要64G内存，那么单机是满足不了的，那这样是不是需要买个更好的机器，例如买个<code>128G</code>的内存；</li><li><code>Redis</code>号称可以达到10W的QPS，我的业务需要100W的QPS，那我怎么去做呢？</li></ul><hr><h2 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><blockquote><p>以上提到的QPS瓶颈是分布式来解决的问题，而故障是高可用问题，下面来讲高可用问题</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571484445203.png" srcset="/img/loading.gif" alt="1571484445203"></p><p>图中<code>master</code>节点是主节点，<code>slave</code>节点是一个从节点，它一开始本身也是一个主节点，它也可以对外提供正常的服务，当然从节点也可以提供正常服务的。假如左边是一个有数据的Redis，右边是没有数据的Redis，此时它就会进行一个复制的操作，那么右边的数据会将左边的数据同步过来，然后左边的数据不断的去写数据，右边的数据会做一个同步的更新，这里就能起到一个备份的效果，这样的话就可以为我们更才主机宕机的情况提供类似的支援。</p><h2 id="一主多从"><a href="#一主多从" class="headerlink" title="一主多从"></a>一主多从</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571484530557.png" srcset="/img/loading.gif" alt="1571484530557"></p><p>以上提到的是一主义从模式，Redis还提供了一主多从的模式，这样就可以做出更多高可用的选择，例如<code>master</code>和一个<code>slave</code>同时挂掉了，那么还可以有多个备份，同时还可以提供另外的功能，做一个刚才提到的读写分离，相当于<code>Redis</code>的<code>master</code>节点可能有多读写，已经达到了极限，这个时候我们可以有多份从，这样可以把读的流量进行分流来实现负载均衡</p><h2 id="主从复制的作用-1"><a href="#主从复制的作用-1" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h2><ol><li>它为一个数据提供了多个副本，这个副本可以成为我们高可用、分布式的基础；</li><li>扩展了读的性能。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>一个<code>master</code>可以有多个<code>slave</code>，每个slave还可以有slave；</li><li>一个<code>slave</code>只能有一个<code>master</code>；</li><li>数据流向是单向的，必须从master流向<code>slave</code></li></ol><h1 id="复制的配置"><a href="#复制的配置" class="headerlink" title="复制的配置"></a>复制的配置</h1><h2 id="两种实现方式"><a href="#两种实现方式" class="headerlink" title="两种实现方式"></a>两种实现方式</h2><h3 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h3><p>希望6380成为6379的从节点，在6380执行<code>slaveof 127.0.0.1:6379</code>，当它执行这条命令之后，然后就实现了复制的流程，这个复制是非常复杂的，它包括了全量复制、前面的建立连接、各种机制的确认都会有很多的过程；</p><pre><code class="hljs bash">redis-6380&gt;slaveof 127.0.0.1:6379OK</code></pre><blockquote><p>上面代码是一个异步过程，它会立即返回OK，它实际上是需要很多步骤和时间的</p></blockquote><p>取消复制：</p><pre><code class="hljs bash">redis-6380&gt; slaveof on noneOK</code></pre><blockquote><p>这里取消之后，它之前从主节点获取的数据并不会被清除，而是说我们6379新写入的数据不会同步到6380，至于6380要做什么处理，比如我想去<code>slaveof</code>新的主，这里要注意：新的主的数据同步给从节点数据，它的首先第一步会将从节点的数据清除掉</p></blockquote><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> ip port<span class="hljs-comment"># port主节点</span>slave-read-only <span class="hljs-literal">yes</span><span class="hljs-comment"># 希望从节点只做读的操作设置为yes</span></code></pre><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>master配置：</p><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span>pidfile /var/run/redis-<span class="hljs-number">6379</span>.pidport <span class="hljs-number">6379</span>logfile <span class="hljs-string">"6379.conf"</span><span class="hljs-comment">#save 900 1</span><span class="hljs-comment">#save 300 10</span><span class="hljs-comment">#save 60 10000</span>dbfilename dump-<span class="hljs-number">6379</span>.rdbdir /usr/src/redis/data</code></pre><p>slave配置：</p><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">yes</span>pidfile /var/run/redis-<span class="hljs-number">6380</span>.pidport <span class="hljs-number">6380</span>logfile <span class="hljs-string">"6380.conf"</span><span class="hljs-comment">#save 900 1</span><span class="hljs-comment">#save 300 10</span><span class="hljs-comment">#save 60 10000</span>dbfilename dump-<span class="hljs-number">6380</span>.rdbdir /usr/src/redis/dataslaveof <span class="hljs-number">127.0.0.1</span> <span class="hljs-number">6379</span></code></pre><p>数据同步：</p><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1OK127.0.0.1:6379&gt;127.0.0.1:6380&gt; get k1<span class="hljs-string">"v1"</span>127.0.0.1:6380&gt;</code></pre><p>查看节点信息：</p><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication<span class="hljs-comment"># Replication</span>role:master<span class="hljs-comment"># 角色,master代表主</span>connected_slaves:1<span class="hljs-comment"># 子节点数量</span>slave0:ip=127.0.0.1,port=6380,state=online,offset=646,lag=0<span class="hljs-comment"># 子节点信息</span>...127.0.0.1:6380&gt; info replication<span class="hljs-comment"># Replication</span>role:slave<span class="hljs-comment"># 角色,slave代表从  </span>master_host:127.0.0.1<span class="hljs-comment"># 从的端口号</span>master_port:6379<span class="hljs-comment"># 从的端口</span>master_link_status:up <span class="hljs-comment"># 连接主的状态</span>...</code></pre><h1 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h1><h2 id="runid"><a href="#runid" class="headerlink" title="runid"></a>runid</h2><blockquote><p>在介绍全量复制之前，来看一下什么是<code>runid</code></p></blockquote><p>查看<code>runid</code></p><pre><code class="hljs bash">[root@mcr2 /] redis-cli  -p 6379 info server | grep runrun_id:eed56e3b451472234709f80d43cccaecc1010555[root@mcr2 /] redis-cli  -p 6380 info server | grep runrun_id:7ef316df1ae60b0d57510542ff3a5d8734c752ac</code></pre><p><code>runid</code>的作用是做一个标识，假如说<code>6380</code>去复制<code>6379</code>，然后就知道6379对应的<code>runid</code>，在<code>6380</code>这做一个标识，当突然之间<code>6379</code>的<code>runid</code>发生了变化，可能它做了一个重启或者重大变化，这个时候我<code>6380</code>就感觉到它应该是做了很多变化需要把他数据同步过来，在6380第一次启动的时候它压根不知道<code>6379</code>这个端口对应的runid，对它来说是一个全新的数据，这个时候它会进行一个全量复制</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><blockquote><p>数据写入量的字节，记录写了多少数据，对于6379去执行<code>set hello</code>，它会把这个命令同步给6380，它也会记录这个偏移量，就相对于写偏移量，当这2个偏移量达到一致的时候，这就是主从数据同步的过程。有一种情况：6379比6380偏移量大，就可能出现主从不一致</p></blockquote><p>查看偏移量</p><pre><code class="hljs bash">127.0.0.1:6379&gt; info replication ...master_repl_offset:1597...127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1OK127.0.0.1:6379&gt; info replication slave0:ip=127.0.0.1,port=6380,state=online,offset=2111,lag=1 <span class="hljs-comment">#从节点信息,这里偏移量是一致的</span>master_repl_offset:2111</code></pre><h2 id="全量复制分析"><a href="#全量复制分析" class="headerlink" title="全量复制分析"></a>全量复制分析</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571539767138.png" srcset="/img/loading.gif" alt="1571539767138"></p><p>对组从复制做一个简单的分析，如果对一个存了很多数据的master节点，这里一个slave节点去做一个复制，我们最想要一个把<code>master</code>先前的数据或者当前的数同步过来的，同时还希望这个<code>master</code>在同步过程期间写的数据也同步过来，这样就可以达到数据的完全同步的效果。在<code>Redis</code>提供了全量复制一个功能，就是完成上述的过程，它首先将本身<code>RDB</code>文件也就是当前状态去同步给<code>slave</code>，在此期间它写入的命令会单独去记录起来，然后当这个<code>RDB</code>文件加载完之后它会通过偏移量的对比，将这个期间产生的写入的值同步给<code>slave</code>。图中表示了复制的一个过程，它内部有一个<code>psync</code>命令是用来做同步的，实际上它在<code>Redis2.8</code>之前它是叫<code>sync</code>，在这之后就叫<code>psync</code>了，它可以完成全量复制和部分复制功能，首先先不管部分复制，来说下全量复制，它有2个参数，<code>runid、偏移量</code>，通过这条命令报告给主节点自己的偏移量是多少，然后主节点可能会把对应偏移量之后的数据同步给它，对于我们第一次复制来说的问题就说主的runid是多少，而且也不知道偏移量是多少，在这里参数传递为：<code>? -1</code>，master收到这个命令能感觉出来，你是要做全量复制的，因为你根本不知道我是谁，而且没有传偏移量，现在master就告诉从节点，我的runid是多少和偏移量是多少，slave这个时候会保存master的基本信息，在这之后master会做一个RDB的生成，使用前面介绍的<code>bgsave</code>，因为它是一个快照，这个快照有一个优点就是说生成越快越好，传输越快越好，master要将全量数据同步给slave，然后还要将部分数据也就是RDB开始生成到RDB传输这个过程中一个新增命令进行一个保存，然后在RDB删了之后将这些命令给它传输过去，在<code>Redis</code>中有一个复制缓冲区<code>repl-back-buffer</code>，它可以记录最新写入的命令，这样就能实现上述的效果，在删了RDB之后会做一个<code>send buffer</code>,<code>send buffer</code>之后它会清除老的数据，然后将RDB进行加载同时将buffer中的数据也加载进来，这样就保证<code>master</code>和<code>slave</code>完全同步，这样就使用了数据副本的功能。</p><h2 id="全量复制开销"><a href="#全量复制开销" class="headerlink" title="全量复制开销"></a>全量复制开销</h2><ol><li>因为需要传递一个RDB，它要做bgsave，它本身是一个fork操作生成一个子进程，对CPU、内存、硬盘都会有一定开销；</li><li>生成RDB之后还要进行网络传输时间；</li><li>从节点清空数据时间，如果从节点之前有很多数据，清空也是需要时间的；</li><li>从节点加载RDB的时间；</li><li>如果在做主从全量复制最后一步加载RDB成功之后，如果我们AOF开启的话，它会执行AOF重写，这样保证AOF是最新的状态。</li></ol><h2 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h2><p>分析一下全量复制有什么问题，上面描述的开销以外，它会有一个问题就是说，假如master和slave的网络发生了走动，一段时间内这些数据就会进行丢失，对于slave来说这段时间master更新数据它不知道，最简单的解决办法就是在做一次全量复制，在<code>Redis2.8</code> 之前是这么做的，很显然前面分析了全量复制的一个开销，其实它有各种问题，因为本身在做一个生成子进程、传输RDB，但在单机多部署的话，你做的资源隔离在好，很多资源是无法做到隔离的，所以在<code>Redis2.8</code>中提供了部分复制功能，希望如果发生类似抖动的时候，可以有一种机制将这个损失降低到最低，图中描述了它是如何实现的：</p><p>如果它们之间发生了抖动，相对于连接断开了，但是在master写命令的时候，它会写一份复制缓冲区的命令，当slave在去连接master的时候也就这网络抖动结束之后，它会进行一条<code>pysnc {offset} {runid}</code>命令，就是把自己当前的偏移量传输给master还要给一个<code>runid</code>，就相对于slave想对master去执行一个<code>psync</code>命令，告诉master当前自己的offset是多少，如果master发现你传输的偏移量是在它buffer范围内的，它这个buffer相对于一个对列有一个最开始和最后一名的<code>offset</code>，如果slave的<code>offset</code>不在这个期间内就证明slave错过了很多数据，毕竟它的buffer是有限的，它的buffer默认是<code>1M</code>，通常为了保证全量 复制的成功，如果我们把它配置很大，这样它可以在一个很大的范围内进行保存，这样<code>offset</code>的命中率会很高，就可以进行一个全量复制，当它发生你的offset在它的范围内它会返回<code>continue</code>,它会从buffer对列中从offset开始到结尾一个数据全部给<code>slave</code>，这样的话<code>master</code>和<code>slave</code>就达到了一个一致，后面的写命令也会全部同步过来达到一个数据副本而有效降低了全量复制的开销</p><h1 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ol><li>读写分离：读流量分摊到从节点；</li><li>可能遇到问题：<ul><li>复制数据延迟：对于大多情况下去写一个master，它会做一个异步同步，将这个数据复制给slave，这本身会有一个时间差，而且当master发生阻塞的时候，它会延迟接受这条写的命令，然后可能会发生一些读写不一致的情况，对于大多数情况下，还是不用考虑读写 分离数据不一致的问题的，如果为了防止这样的问题，你可以对偏移量做监控，当监控到有问题的时候做一些处理，例如切换到master上；</li><li>读到过期数据：Redis删除过期数据有2种策略：<ul><li>它去操作key的时候，它才去看key有没有过期，如果过期了就将它删除，然后再返回给客户端空的操作；</li><li>它会有一个定时任务，每次去采集一些key，看它有没有过期，这就会照成一种情况，当过期数量非常多，而且采集速度根本比不上过期数据的产生速度的时候就会造成很多过期数据没有删除，但是Redis中master和slave是达成这样一个约定的：slave节点是不能处理数据的，就会造成slave可能会读到脏的数据，例如client没有及时将过期数据找到然后把这个删除命令同步给slave的时候，因为slave没有删除数据的权限所以不会将过期数据删除，就会造成slave去读到过期数据，但在<code>Redis3.2</code>中已经解决了这样的问题。</li></ul></li><li>从节点故障：如果从节点发生故障的时候，怎么将从节点的客户端进行一个迁移，它的成本是非常高的，你可以用一些手段来解决。你在考虑使用读写分离之前首先要考虑如何去优化主节点，因为Redis的性能是非常高的，大部分场景基本上是可以满足的，你可以优化一些内存的参数、AOF的策略这些东西，然后当我们实在不行的话可以考虑读写分离；这个时候你可以去使用<code>Redis</code>官方的一些分布式<code>Redis Cluster</code>包括其他开源的分布式方案来解决类似的问题；</li></ul></li></ol><h2 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h2><ol><li>例如maxmemory不一致：丢失数据，例如主节点配置<code>4G</code>，从节点配置<code>2G</code>，这样做主从复制是可以正常进行的，全量复制可以进行，<code>master</code>传输RDB给<code>slave</code>，然后加载之后发现它过大，然后它就会触发它自己的<code>maxmemory policy</code>也就是最大内存的触发策略，将数据进行淘汰，这个过程中有可能会产生OAM那样的问题，假如这里过期数据比较多就是设置TTL的数据比较多，那么<code>maxmemory policy</code>的一个过期策略以剔除这个过期数据为优先的策略，那么过期数据就会被剔除，这里对于数据来说它已经不是一个实现数据副本的功能了，但是它也不会报任何错误。当我们在做一些类似于高可用的时候，需要将从节点变成主节点的时候，就会发现数据已经丢失了，而且已经无法挽回了，这里避免这种情况可以使用一些标准的工具进行安装并且做一个监控；</li><li>例如数据结构优化参数（例如hash-max-ziplist-entries）：内存不一致；</li></ol><h2 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h2><blockquote><p>前面已经提到全量复制的开销是非常大的，下面来分析一下如何去避免这样的问题。</p></blockquote><ol><li>第一次全量复制<ul><li>第一次不可避免；</li><li>小主节点、低峰：<code>maxmemory</code>不要设置过大，这样我们一个bgsave、传输、加载都会很快， 而且开销也能减小，还有一种处理方式，在夜间访问量低的时候整个Redis集群或者Redis对应的机器负载比较低的时候我们来做这样的操作来避免问题。</li></ul></li><li>节点运行ID不匹配<ul><li>主节点重启（运行ID变化）：对于slave来说，它会保存之前主节点的<code>runid</code>，如果它发现<code>runid</code>发生变化，它就会认为这个数据可能是不安全的，它认为当前master是不安全的，因为slave无法知道master是谁，最简单的方式就是做一次全量复制，这个暂时是无法避免的，在<code>Redis4.0</code>中它提供了<code>PSYNC  2</code>规则可以有效解决这类问题，就是说如果runid发生变化，它做一个故障转移的时候可以有效避免全量复制；</li><li>故障转移，例如哨兵或集群。</li></ul></li><li>复制积压缓冲区不足<ul><li>网路中断，部分复制无法满足：将最新的写入命令写入到缓冲区，它是一个对列，它的一个默认值是<code>1M</code>，如果发生网络抖动的情况下就可以使用部分复制，如果你的slave偏移量是在缓冲区的范围内那么就可以完成部分复制，有效避免全量复制的问题，当然如果slave的offset是在这个之外，那么就没办法，只能做一次全量复制了，当然比较简单的方法就是你可以把这个缓冲区去调大一点；</li><li>增大复制缓冲区设置<code>rel-backlog-size</code>，网络“增强”，例如设置为10M来降低全量复制可能产生的情况，有一种比较科学的方法你可以这么去算，假设一般的网络的一个断开时间或者产生故障时间可能是分钟级别的，那我们可以根据我们当前的QPS写的数量，统计每分钟有多少字节，然后再乘以你对应的发生故障的分钟，这个就是复制缓冲区理想的值。</li></ul></li></ol><h2 id="避免-复制风暴"><a href="#避免-复制风暴" class="headerlink" title="避免 复制风暴"></a>避免 复制风暴</h2><h3 id="单主节点复制风暴"><a href="#单主节点复制风暴" class="headerlink" title="单主节点复制风暴"></a>单主节点复制风暴</h3><ul><li>问题：主节点重启，多从节点复制：假如说一个master节点挂了很多从节点，那么master节点挂了之后重启，这个时候所有slave节点都要做一个主从复制，因为它的runid已经发生了变化，这里的开销是非常大的，首先要将RDB生成，然后进行传输，当然对于Redis来说它有效去优化了这个东西，它可以只生成一份RDB文件，但是它要做多次传输，整个过程是对CPU、内存、网络、硬盘都会有一定开销；</li><li>解决：更换复制措施<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571544297928.png" srcset="/img/loading.gif" alt="1571544297928" style="zoom: 33%;" />，相对于master挂一个slave，slave还挂slave，这样master来说，它能减轻压力，这样把所有问题都控制在slave1节点上，这样有效减少master节点一个负载，但是这种架构还是有问题的，这种架构可以称为树形架构，它有一个问：假如你在做读写分离的时候，slave1出现了问题，你怎么去处理，还有在高可用分布式环境下怎么去进行一个故障转移这些都是一些问题，这个要根据业务场景来进行判断；</li></ul><h3 id="单机器复制风暴"><a href="#单机器复制风暴" class="headerlink" title="单机器复制风暴"></a>单机器复制风暴</h3><p>如果你只想做一个高可用，而不做一个读写分离的话，一个节点就够了，这个时候如果出现问题就将它去晋升，然后给它自动加一个slave就好了</p><ul><li><p>问题：如右图：机器宕机后，大量全量复制<img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571544649954.png" srcset="/img/loading.gif" alt="1571544649954" style="zoom: 33%;" />，假如我们机器上全都是master，然后机器发生了重启，这个时候就是一个灾难，相当于所有slave都去拉这台机器的全量复制，那样的开销是非常大的，因为这个时候所有节点都要做<code>bgsave</code>，然后所以节点都要传输一份<code>RDB</code>到相应的机器，无论是CPU、带宽都是巨大的开销，可能会造成内存池满的情况；</p></li><li><p>解决：主节点分散多机器：在部署的时候我们自己去写一些部署程序的时候会刻意将master分布到不同机器上，这样有效去避免问题；还要一种好的方法：如果出现类似问题我们完全可以采用高可用的架构，master挂掉之后slave晋升成master，这样的话它就不会有类似的问题了。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 5.常见的持久化开发运维问题</title>
    <link href="/redis-5.html"/>
    <url>/redis-5.html</url>
    
    <content type="html"><![CDATA[<h1 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a>fork操作</h1><h2 id="同步操作"><a href="#同步操作" class="headerlink" title="同步操作"></a>同步操作</h2><ul><li>提交<code>bgsave</code>、<code>bgrewriteaof</code>命令时会执<code>fork</code>操作，<code>fork</code>操作只是做一个内存页的拷贝，而不是做一个内存的拷贝，所以在大部分情况下速度是非常快的，但是如果本身这个<code>fork</code>操作比较慢，或者说卡在某一个地方，那么它会卡在<code>Redis</code>的主线程；</li><li><code>fork</code>操作的执行时间和内存的量有关系，内存量越大内存页的数据也会较大，而且和机型有关，虚机、物理机还有略有不同，虚机就会慢一些，这里如果执行时间需要1秒，对于<code>Redis</code>来说就会卡住一秒，对于每秒执行QPS上万的应用，那么它就会卡一秒，如果你的超时时间设置过下就会造成客户端超时；</li><li>info：<code>latest_fork_user</code>查看上一次执行fork的微妙数，如果这个数比较大可能会阻塞<code>Redis</code>，需要做一些重点关注可以做一些监控；</li></ul><h2 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h2><ul><li>优先使用物理机或者高效支持<code>fork</code>操作的虚拟化技术；</li><li>控制<code>Redis</code>实例最大可用内存：<code>maxmemory</code>；</li><li>合理配置Linux内存分配策略：<code>vm.overcommit_memory=1</code>；<a href="https://blog.csdn.net/houjixin/article/details/46412557" target="_blank" rel="noopener">（介绍）</a>，在Linux中默认是0，当它发现没有足够内存去做内存分配的时候，它就不去分配，对于<code>fork</code>来说，它会造成<code>fork</code>的阻塞，如果希望<code>fork</code>不会阻塞将它设置为1；</li><li>降低<code>fork</code>频率：例如放宽<code>AOF</code>重写自动触发机制，不必要的全量复制；</li></ul><h1 id="子进程开销和优化"><a href="#子进程开销和优化" class="headerlink" title="子进程开销和优化"></a>子进程开销和优化</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><h3 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h3><p>CPU的开销体现来文件的重写，在<code>Redis</code>执行<code>bgsave</code>、<code>bgrewriteaof</code>都会将内存的数据写到硬盘，实际上硬盘上的开销之外，它本身是一个CPU机密的操作，因为它的写入是一个非常集中的过程，所以通常这个子进程一个CPU的开销会大于90以上；</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>不做CPU绑定，不让<code>Redis</code>进程绑定到一个CPU上，这样的话如果发生了这样的子进程的话，它会和父进程集中的去消耗CPU，会对主进程造成很大的资源影响；</li><li>不要和CPU密集型的一些应用部署在一起，这样就能保证不会产生CPU内的过渡竞争；</li><li>在单机多部署的时候，要保证不要发生大量的 AOF重写、RDB的<code>bgsave</code>的过程，这样可以节省一定的CPU；</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="开销-1"><a href="#开销-1" class="headerlink" title="开销"></a>开销</h3><p>因为Redis在fork的时候会生成一个子进程，它理论上的占用内存等于父进程的，但是Linux有一个写时复制的机制：<code>copy-on-write</code><a href="https://juejin.im/post/5bd96bcaf265da396b72f855" target="_blank" rel="noopener">（介绍）</a>，父子进程共享物理进程页，但是当父进程要写请求的时候会创建一个副本，它这个时候才会消耗内存，而在整个期间子进程会共享<code>fork</code>时父进程一个内存的快早，就是说你在<code>AOF重写</code>或者bgsave产生子进程的过程中，如果你的父进程的内存页会大量的写入，就会证明你的一个子进程的内存开销比较大，因为它要做一个 副本，如果你没什么写入的话，实际上它也开销不了多少内存；</p><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><ul><li>不允许单机多部署的时候产生大量的重写，这样你内存开销也会比较小；</li><li>在主进程写入量比较少的时候去做一个AOF重写或bgsave，这样会节省一定内存；</li><li>我们可以在<code>Linux</code>上做一些优化的工作，<code>Linux</code>在<code>6.38版本</code>中增加了一个叫<code>tph</code>特性，它的意思说，它支持大的内存页的分配，但是这个对于我们刚才说的<code>copy-on-write</code>是有一定问题的，我们写入量大的时候，那么它每次的内存页由原来的<code>4k</code>变成了<code>2m</code>，这样会极大增加内存副本产生概率以及它的大小，这是为了增加<code>fork</code>的速度,但实际上对于我们<code>Redis</code>来说不是好的解决方案，通常会禁止掉：<code>echo never &gt;/sys/kernel/mm/transparent_hugepage/enabled</code></li></ul><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><h3 id="开销-2"><a href="#开销-2" class="headerlink" title="开销"></a>开销</h3><p>AOF和RDB文件写入量是比较大的话会对硬盘造成一定开销，我们可以去结合iostat，iotop这样的工具分析</p><h3 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h3><ul><li>不要和高硬盘负载服务部署一起：存储服务、消息队列服务等；</li><li>Redis配置文件中<code>no-appendfsync-on-rewrite=yes</code>，在AOF重写期间，不要进行正常的AOF去追加一个操作，这样可能会减少我们硬盘的开销；</li><li>根据写入量决定硬盘类型：例如ssd；</li><li>单机多实例持久化文件目录可以考虑分盘、资源限制的操作；</li></ul><h1 id="AOF阻塞"><a href="#AOF阻塞" class="headerlink" title="AOF阻塞"></a>AOF阻塞</h1><h2 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h2><p>如果我们使用<code>AOF</code>的策略，我们通常使用每秒刷盘的策略，刷盘策略流程图如下，首先主线程写入<code>AOF</code>缓冲区，同时它有一个<code>AOF</code>同步线程负责每秒去同步刷盘的动作，它还会记录最近一次的同步时间，主线程还会负责对你上次AOF同步的时间，如果距离上次同步时间在2秒之内，主线程就会返回，如果距离上次同步时间超过2秒，那么主线程会阻塞，直到同步完成，实际上也是为了保证AOF安全性的一种策略，主线程为了达到每秒刷盘的效果，它会阻塞直到同步完成，这里会产生2个问题：</p><p>（1）主线程不能阻塞，因为它要负责我们的日常命令的处理，它是非常宝贵的资源；</p><p>（2）每秒刷盘的策略不会真正只丢1秒的数据，它可能会丢2秒的东西。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571475697141.png" srcset="/img/loading.gif" alt="1571475697141"></p><h2 id="AOF阻塞定位"><a href="#AOF阻塞定位" class="headerlink" title="AOF阻塞定位"></a>AOF阻塞定位</h2><p>Redis日志：</p><pre><code class="hljs vim">Asynchronous aoF fsync <span class="hljs-keyword">is</span> taking too long(disk <span class="hljs-keyword">is</span> busyWriting the aof <span class="hljs-keyword">buffer</span> without waiting <span class="hljs-keyword">for</span> fsync <span class="hljs-keyword">to</span> <span class="hljs-built_in">complete</span>,this may slow down redis</code></pre><hr><p><code>info persistence</code>选项中的aof delayed fsync，它会记录你上诉过程的数量，每发生一次加1，但是这个累计过程无法看到，例如某段时间发生的次数，这里需要你单独做一个收集</p><pre><code class="hljs bash">info persistence127.0.0.1: 6379&gt; info persistenceaof delayed fsync: 100</code></pre><hr><p>通过硬盘观察，执行Linux的top命令，是否有发生IO资源比较紧张的时候</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571477131262.png" srcset="/img/loading.gif" alt="1571477131262"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】 4.持久化</title>
    <link href="/redis-4.html"/>
    <url>/redis-4.html</url>
    
    <content type="html"><![CDATA[<h1 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h1><h2 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h2><p> 持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。<br>持久化 Redis 所有数据保持在内存中，对数据的更新将异步地保存到磁盘上。 </p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571240413585.png" srcset="/img/loading.gif" alt="1571240413585">  </p><h2 id="持久化的实现方式"><a href="#持久化的实现方式" class="headerlink" title="持久化的实现方式"></a>持久化的实现方式</h2><h3 id="快照方式持久化"><a href="#快照方式持久化" class="headerlink" title="快照方式持久化"></a>快照方式持久化</h3><p>快照方式持久化就是在某时刻把所有数据进行完整备份。</p><p>例：Mysql 的 Dump 方式、Redis 的 RDB 方式。</p><h3 id="写日志方式持久化"><a href="#写日志方式持久化" class="headerlink" title="写日志方式持久化"></a>写日志方式持久化</h3><p>写日志方式持久化就是把用户执行的所有写指令（增删改）备份到文件中，还原数据时只需要把备份的所有指令重新执行一遍即可。</p><p>例：Mysql 的 Binlog、Redis 的 AOF、Hbase 的 HLog。</p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><h2 id="什么是-RDB"><a href="#什么是-RDB" class="headerlink" title="什么是 RDB"></a>什么是 RDB</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571240680932.png" srcset="/img/loading.gif" alt="1571240680932"></p><p> RDB 持久化方式能够在指定的时间间隔能对你的数据进行快照存储。<br>在默认情况下， Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。<br>在 Redis 运行时， RDB 程序将当前内存中的数据库快照保存到磁盘文件中， 在 Redis 重启动时， RDB 程序可以通过载入 RDB 文件来还原数据库的状态。 </p><h2 id="RDB-的三种主要触发机制"><a href="#RDB-的三种主要触发机制" class="headerlink" title="RDB 的三种主要触发机制"></a>RDB 的三种主要触发机制</h2><h3 id="save-命令（同步数据到磁盘上）"><a href="#save-命令（同步数据到磁盘上）" class="headerlink" title="save 命令（同步数据到磁盘上）"></a>save 命令（同步数据到磁盘上）</h3><p><code>save</code> 属于O（n）命令执行一个同步操作，以 RDB 文件的方式保存所有数据的快照。</p><pre><code class="hljs bash">127.0.0.1:6379&gt; saveOK</code></pre><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571240796252.png" srcset="/img/loading.gif" alt="1571240796252"></p><p> 由于 <code>save</code> 命令是同步命令，会占用 <code>Redis</code> 的主进程。若 <code>Redis</code> 数据非常多时，<code>save</code> 命令执行速度会非常慢，阻塞所有客户端的请求。<br>因此很少在生产环境直接使用 SAVE 命令，可以使用 <code>BGSAVE</code> 命令代替。如果在 <code>BGSAVE</code> 命令的保存数据的子进程发生错误的时，用 SAVE 命令保存最新的数据是最后的手段。 </p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571240834372.png" srcset="/img/loading.gif" alt="1571240834372"></p><h3 id="bgsave-命令（异步保存数据到磁盘上）"><a href="#bgsave-命令（异步保存数据到磁盘上）" class="headerlink" title="bgsave 命令（异步保存数据到磁盘上）"></a>bgsave 命令（异步保存数据到磁盘上）</h3><p><code>bgsave</code> 命令执行一个异步操作，以 RDB 文件的方式保存所有数据的快照。</p><pre><code class="hljs bash">127.0.0.1:6379&gt; bgsaveBackground saving started</code></pre><p> Redis 使用 Linux 系统的 <code>fock()</code> 生成一个子进程来将 DB 数据保存到磁盘，主进程继续提供服务以供客户端调用。<br>如果操作成功，可以通过客户端命令 LASTSAVE 来检查操作结果。 </p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571240943676.png" srcset="/img/loading.gif" alt="1571240943676"></p><h3 id="save-与-bgsave-对比"><a href="#save-与-bgsave-对比" class="headerlink" title="save 与 bgsave 对比"></a>save 与 bgsave 对比</h3><table><thead><tr><th align="left">命令</th><th align="left">save</th><th align="left">bgsave</th></tr></thead><tbody><tr><td align="left">IO 类型</td><td align="left">同步</td><td align="left">异步</td></tr><tr><td align="left">阻塞？</td><td align="left">是</td><td align="left">是（阻塞发生在 fock ()，通常非常快）</td></tr><tr><td align="left">复杂度</td><td align="left">O(n)</td><td align="left">O(n)</td></tr><tr><td align="left">优点</td><td align="left">不会消耗额外的内存</td><td align="left">不阻塞客户端命令</td></tr><tr><td align="left">缺点</td><td align="left">阻塞客户端命令</td><td align="left">需要 fock 子进程，消耗内存</td></tr></tbody></table><h3 id="自动生成-RDB"><a href="#自动生成-RDB" class="headerlink" title="自动生成 RDB"></a>自动生成 RDB</h3><p>除了手动执行 <code>save</code> 和 <code>bgsave</code> 命令实现 RDB 持久化以外，Redis 还提供了自动自动生成 RDB 的方式。</p><p>你可以通过配置文件对 Redis 进行设置， 让它在 “N 秒内数据集至少有 M 个改动” 这一条件被满足时， 自动进行数据集保存操作。<br>比如说， 以下设置会让 Redis 在满足 “60 秒内有至少有 1000 个键被改动” 这一条件时， 自动进行数据集保存操作：</p><pre><code class="hljs bash">save 60 1000</code></pre><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571241038316.png" srcset="/img/loading.gif" alt="1571241038316"></p><h2 id="触发机制-不容忽视的方式"><a href="#触发机制-不容忽视的方式" class="headerlink" title="触发机制-不容忽视的方式"></a>触发机制-不容忽视的方式</h2><ol><li>全量复制</li><li>debug reload</li><li>shutdown</li></ol><h2 id="RDB-相关配置"><a href="#RDB-相关配置" class="headerlink" title="RDB 相关配置"></a>RDB 相关配置</h2><pre><code class="hljs properties"><span class="hljs-comment"># RDB自动持久化规则</span><span class="hljs-comment"># 当 900 秒内有至少有 1 个键被改动时，自动进行数据集保存操作</span><span class="hljs-attr">save</span> <span class="hljs-string">900 1</span><span class="hljs-comment"># 当 300 秒内有至少有 10 个键被改动时，自动进行数据集保存操作</span><span class="hljs-attr">save</span> <span class="hljs-string">300 10</span><span class="hljs-comment"># 当 60 秒内有至少有 10000 个键被改动时，自动进行数据集保存操作</span><span class="hljs-attr">save</span> <span class="hljs-string">60 10000</span><span class="hljs-comment"># RDB持久化文件名</span><span class="hljs-attr">dbfilename</span> <span class="hljs-string">dump-$&#123;port&#125;.rdb</span><span class="hljs-comment"># 数据持久化文件存储目录</span><span class="hljs-attr">dir</span> <span class="hljs-string">/var/lib/redis</span><span class="hljs-comment"># bgsave发生错误时是否停止写入，通常为yes</span><span class="hljs-meta">stop-writes-on-bgsave-error</span> <span class="hljs-string">yes</span><span class="hljs-comment"># rdb文件是否使用压缩格式</span><span class="hljs-attr">rdbcompression</span> <span class="hljs-string">yes</span><span class="hljs-comment"># 是否对rdb文件进行校验和检验，通常为yes</span><span class="hljs-attr">rdbchecksum</span> <span class="hljs-string">yes</span></code></pre><h2 id="RDB-的优点"><a href="#RDB-的优点" class="headerlink" title="RDB 的优点"></a>RDB 的优点</h2><ol><li>RDB 是一个非常紧凑的文件，它保存了某个时间点得数据集，非常适用于数据集的备份，比如你可以在每个小时报保存一下过去 24 小时内的数据，同时每天保存过去 30 天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。</li><li>RDB 是一个紧凑的单一文件，很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。</li><li>RDB 在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以 RDB 持久化方式可以最大化 redis 的性能。</li><li>与 AOF 相比，在恢复大的数据集的时候，RDB 方式会更快一些。</li></ol><h2 id="RDB-的缺点"><a href="#RDB-的缺点" class="headerlink" title="RDB 的缺点"></a>RDB 的缺点</h2><ol><li>耗时、耗性能。RDB 需要经常 fork 子进程来保存数据集到硬盘上，当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且 CPU 性能不是很好的情况下，这种情况会持续 1 秒，AOF 也需要 fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。</li><li>不可控、丢失数据。如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么 RDB 不适合你。虽然你可以配置不同的 save 时间点 (例如每隔 5 分钟并且对数据集有 100 个写的操作)，是 Redis 要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔 5 分钟或者更久做一次完整的保存，万一在 Redis 意外宕机，你可能会丢失几分钟的数据。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>RDB</code>是<code>Redis</code>内存到硬盘的快照，用于持久化；</li><li>save通常会阻塞<code>Redis</code>;</li><li><code>bgsave</code>不会阻塞<code>Redis</code>，但是会fork新进程；</li><li><code>save</code>自动配置满足任一就会被执行；</li><li>有些触发机制不容忽视。</li></ol><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><h2 id="什么是-AOF"><a href="#什么是-AOF" class="headerlink" title="什么是 AOF"></a>什么是 AOF</h2><p>快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。<br>你可以在配置文件中打开 AOF 方式：</p><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span></code></pre><p>打开 AOF 后， 每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</p><p>AOF 运行原理 - 创建</p><p>  <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1460000016021226.png" srcset="/img/loading.gif" alt="1460000016021226">  </p><p>AOF 运行原理 - 恢复</p><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1460000016021227.png" srcset="/img/loading.gif" alt="1460000016021227.png"> </p><h2 id="AOF-持久化的三种策略"><a href="#AOF-持久化的三种策略" class="headerlink" title="AOF 持久化的三种策略"></a>AOF 持久化的三种策略</h2><h3 id="always"><a href="#always" class="headerlink" title="always"></a>always</h3><p>你可以通过配置文件配置 Redis 多久才将数据 fsync 到磁盘一次。每次有新命令追加到 AOF 文件时就执行一次 fsync ：非常慢，也非常安全。</p><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1460000016021228-1571313423491.png" srcset="/img/loading.gif" alt="1460000016021228"> </p><h3 id="everysec"><a href="#everysec" class="headerlink" title="everysec"></a>everysec</h3><p>每秒 fsync 一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。<br>推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。</p><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1460000016021229.png" srcset="/img/loading.gif" alt="img"> </p><h3 id="no"><a href="#no" class="headerlink" title="no"></a>no</h3><p>从不 fsync ：将数据交给操作系统来处理，由操作系统来决定什么时候同步数据。更快，也更不安全的选择。</p><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1460000016021230.png" srcset="/img/loading.gif" alt="no"></p><h3 id="always、everysec、no-对比"><a href="#always、everysec、no-对比" class="headerlink" title="always、everysec、no 对比"></a>always、everysec、no 对比</h3><table><thead><tr><th align="center">命令</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">不丢失数据</td><td align="center">IO 开销大，一般 SATA 磁盘只有几百 TPS</td></tr><tr><td align="center">everysec</td><td align="center">每秒进行与 fsync，最多丢失 1 秒数据</td><td align="center">可能丢失 1 秒数据</td></tr><tr><td align="center">no</td><td align="center">不用管</td><td align="center">不可控</td></tr></tbody></table><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>因为 <code>AOF</code> 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， <code>AOF</code> 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 <code>INCR</code> ， 那么仅仅是为了保存这个计数器的当前值， <code>AOF</code> 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。<br>为了处理这种情况， <code>Redis</code> 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 <code>AOF</code> 文件进行重建（rebuild）。执行 <code>bgrewriteaof</code> 命令， <code>Redis</code> 将生成一个新的 <code>AOF</code> 文件， 这个文件包含重建当前数据集所需的最少命令。<br><code>Redis 2.2</code> 需要自己手动执行 <code>bgrewriteaof</code> 命令； <code>Redis 2.4</code> 则可以通过配置自动触发 <code>AOF</code> 重写。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571316511368.png" srcset="/img/loading.gif" alt="1571316511368">  </p><h3 id="AOF-重写的作用"><a href="#AOF-重写的作用" class="headerlink" title="AOF 重写的作用"></a>AOF 重写的作用</h3><ul><li>减少磁盘占用量</li><li>加速数据恢复</li></ul><h3 id="AOF-重写的实现方式"><a href="#AOF-重写的实现方式" class="headerlink" title="AOF 重写的实现方式"></a>AOF 重写的实现方式</h3><ul><li><p><strong>bgrewriteaof 命令</strong></p><p>Redis bgrewriteaof 命令用于异步执行一个 AOF（AppendOnly File）文件重写操作。重写会创建一个当前 AOF 文件的体积优化版本。<br>即使 bgrewriteaof 执行失败，也不会有任何数据丢失，因为旧的 AOF 文件在 bgrewriteaof 成功之前不会被修改。<br>AOF 重写由 Redis 自行触发，bgrewriteaof 仅仅用于手动触发重写操作。<br>具体内容:</p><ul><li>如果一个子 Redis 是通过磁盘快照创建的，AOF 重写将会在 RDB 终止后才开始保存。这种情况下 BGREWRITEAOF 任然会返回 OK 状态码。从 Redis 2.6 起你可以通过 INFO 命令查看 AOF 重写执行情况。</li><li>如果只在执行的 AOF 重写返回一个错误，AOF 重写将会在稍后一点的时间重新调用。</li></ul></li></ul><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/3606763245-5b73cfc6d009c_articlex.jpg" srcset="/img/loading.gif" alt="3606763245-5b73cfc6d009c_articlex"></p><ul><li>AOF 重写配置</li></ul><table><thead><tr><th align="left">配置名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">auto-aof-rewrite-min-size</td><td align="left">触发 AOF 文件执行重写的最小尺寸</td></tr><tr><td align="left">auto-aof-rewrite-percentage</td><td align="left">触发 AOF 文件执行重写的增长率</td></tr></tbody></table><table><thead><tr><th align="left">统计名</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">aof_current_size</td><td align="left">AOF 文件当前尺寸（字节）</td></tr><tr><td align="left">aof_base_size</td><td align="left">AOF 文件上次启动和重写时的尺寸（字节）</td></tr></tbody></table><blockquote><p>AOF 重写自动触发机制，需要同时满足下面两个条件：</p><ul><li>aof_current_size &gt; auto-aof-rewrite-min-size</li><li>(aof_current_size - aof_base_size) * 100 / aof_base_size &gt; auto-aof-rewrite-percentage</li></ul></blockquote><p>假设 Redis 的配置项为：</p><pre><code class="hljs pseudocode">auto-aof-rewrite-min-size 64mbauto-aof-rewrite-percentage 100</code></pre><p> 当 AOF 文件的体积大于 64Mb，并且 AOF 文件的体积比上一次重写之久的体积大了至少一倍（100%）时，Redis 将执行 bgrewriteaof 命令进行重写。 </p><h3 id="AOF-重写的流程"><a href="#AOF-重写的流程" class="headerlink" title="AOF 重写的流程"></a>AOF 重写的流程</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571317003921.png" srcset="/img/loading.gif" alt="1571317003921"></p><h2 id="AOF-相关配置"><a href="#AOF-相关配置" class="headerlink" title="AOF 相关配置"></a>AOF 相关配置</h2><pre><code class="hljs pseudocode"># 开启AOF持久化方式appendonly yes# AOF持久化文件名appendfilename appendonly-&lt;port&gt;.aof# 每秒把缓冲区的数据同步到磁盘appendfsync everysec# 数据持久化文件存储目录dir &#x2F;var&#x2F;lib&#x2F;redis# 是否在执行重写时不同步数据到AOF文件# 这里的 yes，就是执行重写时不同步数据到AOF文件no-appendfsync-on-rewrite yes# 触发AOF文件执行重写的最小尺寸auto-aof-rewrite-min-size 64mb# 触发AOF文件执行重写的增长率auto-aof-rewrite-percentage 100</code></pre><h2 id="AOF-的优点"><a href="#AOF-的优点" class="headerlink" title="AOF 的优点"></a>AOF 的优点</h2><ol><li>使用 <code>AOF</code> 会让你的 <code>Redis</code> 更加耐久：你可以使用不同的 <code>fsync</code> 策略：无 <code>fsync</code>，每秒 <code>fsync</code>，每次写的时候 <code>fsync</code>。使用默认的每秒 <code>fsync</code> 策略，<code>Redis</code> 的性能依然很好 (<code>fsync</code> 是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你最多丢失 1 秒的数据。</li><li><code>AOF</code> 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因 (磁盘空间已满，写的过程中宕机等等) 未执行完整的写入命令，你也也可使用 <code>redis-check-aof</code> 工具修复这些问题。</li><li><code>Redis</code> 可以在 <code>AOF</code> 文件体积变得过大时，自动地在后台对 <code>AOF</code> 进行重写： 重写后的新 <code>AOF</code> 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 <code>Redis</code> 在创建新 <code>AOF</code> 文件的过程中，会继续将命令追加到现有的 <code>AOF</code> 文件里面，即使重写过程中发生停机，现有的 <code>AOF</code> 文件也不会丢失。 而一旦新 <code>AOF</code> 文件创建完毕，<code>Redis</code> 就会从旧 <code>AOF</code> 文件切换到新 <code>AOF</code> 文件，并开始对新 <code>AOF</code> 文件进行追加操作。</li><li><code>AOF</code> 文件有序地保存了对数据库执行的所有写入作， 这些写入操作以 Redis 协议的格式保存， 因此 <code>AOF</code> 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 <code>FLUSHALL</code> 命令， 但只要 <code>AOF</code> 文件未被重写， 那么只要停止服务器， 移除 <code>AOF</code> 文件末尾的 <code>FLUSHALL</code> 命令， 并重启 <code>Redis</code> ， 就可以将数据集恢复到 <code>FLUSHALL</code> 执行之前的状态。</li></ol><h2 id="AOF-的缺点"><a href="#AOF-的缺点" class="headerlink" title="AOF 的缺点"></a>AOF 的缺点</h2><ol><li>对于相同的数据集来说，<code>AOF</code> 文件的体积通常要大于 <code>RDB</code> 文件的体积;</li><li>根据所使用的 <code>fsync</code> 策略，AOF 的速度可能会慢于 <code>RDB</code> 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 <code>fsync</code> 可以让 <code>AOF</code> 的速度和 <code>RDB</code> 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，<code>RDB</code> 可以提供更有保证的最大延迟时间（latency）。</li></ol><h1 id="RDB-和-AOF-的抉择"><a href="#RDB-和-AOF-的抉择" class="headerlink" title="RDB 和 AOF 的抉择"></a>RDB 和 AOF 的抉择</h1><h2 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h2><table><thead><tr><th align="left">命令</th><th align="left">RDB</th><th align="left">AOF</th></tr></thead><tbody><tr><td align="left">启动优先级</td><td align="left">低</td><td align="left">高</td></tr><tr><td align="left">体积</td><td align="left">小</td><td align="left">大</td></tr><tr><td align="left">恢复速度</td><td align="left">快</td><td align="left">慢</td></tr><tr><td align="left">数据安全性</td><td align="left">丢数据</td><td align="left">根据策略决定</td></tr><tr><td align="left">较重</td><td align="left">重</td><td align="left">轻</td></tr></tbody></table><p><code>RDB</code>是一个很重的操作，因为它要将全部的<code>Redis</code>数据挪到硬盘中，这个操作就涉及到很多方便，我们要把这个数据全部由内存去导到硬盘，首先硬盘写入量就很大而且它是一个CPU密集形操作，同时它还执行<code>bgsave</code>的话会执行一个<code>fork</code>会产生一定内存开销；</p><p><code>AOF</code>来说不讨论重新，它本身是一个追加日志，对于大部分情况下，对硬盘是有一定压力，但总体是很轻的。</p><h2 id="RDB最佳策略"><a href="#RDB最佳策略" class="headerlink" title="RDB最佳策略"></a>RDB最佳策略</h2><ul><li>把RDB“关”掉：这里的关是一个引号，因为后面会介绍<code>Redis</code>主从复制，<code>Redis</code>主从复制它起到一个全量复制，需要主节点去执行一次<code>bgsave</code>然后把<code>rdb文件</code>传给从节点，来实现一个复制的效果，第一次全量复制，所以这里的关是永远关不掉的；</li><li>集中管理：<code>RDB</code>是一个很重的操作，对于我们数据备份是有一定作用的，假如我们真的想按天、按小时来比较大的量级来备份数据，或者按天来备份数据那么<code>RDB</code>是一个不错的选择，因为它的文件大小比较小，它的传输速度比较快，对于管理有优势；</li><li>主从，从开？：在别的场景下有的时候是需要在从节点去开一下<code>RDB</code>，这样就可以在本地去保存一个历史的<code>RDB</code>文件这样是有一定优势的但是一定要控制<code>save</code>不要太频繁，这样及时是从节点，虽然不进行<code>Redis</code> 的一个读写，但是我们所有的<code>Redis</code>都是一个混合部署（单机多部署），<code>RDB</code>是一个很重的操作会多硬盘、CPU、内存有一定影响，这个要根据实际开发来进行设定。</li></ul><h2 id="AOP最佳策略"><a href="#AOP最佳策略" class="headerlink" title="AOP最佳策略"></a>AOP最佳策略</h2><ul><li>“开”：缓存和存储：大部分情况是建议开的，这样可以体现<code>Redis</code>的特点，可以持久化，在大部分情况下只会丢一秒数据，通常设置策略为每秒去刷新磁盘，但是有的时候，例如缓存的场景，它完全拿<code>Redis</code>当一个缓存，即使里面数据丢了，那也无所谓，只需要下次加载的时候从数据源加载进来就好，而且它对数据源压力也没有那么大，假如你的访问对数据源没有那么大，缓存也只是起到一定的缓存作用时候，这样时候可以关闭掉，<code>AOF</code>是有一定的开销的；</li><li><code>AOF</code>重写集中管理：这样以后会提到，大概说一下，在单机多部署的情况下， 如果<code>AOF</code>集中发生大量的<code>fork</code>，但是我们机器内存比如是百分百的话，大部分情况下会分配百分60~70的内存给<code>Redis</code>，留20-30给<code>fork</code>做操作，假如集中做<code>fork</code>,有可能会出现内存爆满的情况；</li><li>everysec：建议使用每秒去刷盘。</li></ul><h2 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a>最佳策略</h2><p>无论使用<code>AOF</code>、<code>RDB</code>，都可以去参考</p><ul><li>小分片：我们使用使用<code>maxmemory</code>为<code>Redis</code>进行规划，例如我们每个<code>Redis</code>一个<code>maxmemory</code>只设置最大内存为<code>4G</code>,这样无论是<code>fork</code>还是<code>RDB</code>复制的传输它都会较小的开销；</li><li>缓存或存储：小分片就是处理这些问题的最好方法，当然它也有一定的问题，在分布式情况下我们要产生更多一个<code>Redis</code>进程，那样可能对CPU占用会更多一些，还有前面提到的根据存储和缓存的特性去决定使用哪种策略；</li><li>监控（硬盘、内存、负载、网络）：这个相信在各各公司都会有开发软件去监控机器的方面，这样可以对机器有一个全面了解，然后在定位问题的时候去抓到一个关键点；</li><li>足够的内存：前面提到不要有百分百内存把它全都布满，布满的情况会产生很多问题，像fork、其他内存的飙升例如客户端缓冲区它不受<code>maxmemory</code>的限制类似这样的问题，它都是有额外的内存消耗的，在实际部署中一定要根据场景进行选择。</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】  3.瑞士军刀</title>
    <link href="/redis-3.html"/>
    <url>/redis-3.html</url>
    
    <content type="html"><![CDATA[<h1 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571141370781.png" srcset="/img/loading.gif" alt="1571141370781"></p><p><code>Redis</code>是一个单线程，当有多个命令发送过来时，它是会进行排队的执行命令，执行完成之后返回一个结果给客户端，这边标题讲的是慢查询，在图上慢查询会出现在第三阶段</p><ul><li>慢查询是指执行命令所消耗的时间，注意：这里不包括排队、网络都不算；</li><li>客户端超时不一定有慢查询，但慢查询是客户端超时的一个可能因素。</li></ul><h2 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h2><h3 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h3><ol><li>慢查询是一个先进先出对列，假如我们一条命令在第三步过程中，它被列入慢查询范围内，它就会进入一个对列，其实它是用<code>Redis</code>列表来  实现的，但是它是一个先进先出的对列；</li><li>当你的对列满了之后，最先进的会被的一个T出去，比如我们慢查询的列表是一个固定长度的；</li><li>对列保存在内存当中，当<code>Redis</code>进行重启之后，不会持久化，而是随着重启而消失。</li></ol><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571142116030.png" srcset="/img/loading.gif" alt=""></p><p>这里你设给<code>Redis</code>设置一个超时时间，客户端发送命令时，如果命令超过了给定的时间，那么就会进入慢查询对列中；这里还给<code>Redis</code>设置了慢查询对列设置了长度，限制对列中的慢查询命令的数量，当对列满的时候，再进入一条会将最前面进的T掉</p><h3 id="slowlog-log-slower-than"><a href="#slowlog-log-slower-than" class="headerlink" title="slowlog-log-slower-than"></a>slowlog-log-slower-than</h3><ol><li><code>slowlog-log-slower-than</code>，慢查询阈值（单位：微妙），当命令大于多少的时候，我们将它介入到慢查询的范围内；</li><li><code>slowlog-log-slower-than=0</code> ，如果想记录所有命令，就将它设置为0；但一般不会这么做，但是在一些特定场合也会有帮助，比如你想知道每条命令的执行时间，在客户端中是不会返回执行时间的，这里就设置为0</li><li><code>slowlog-log-slower-than&lt;0</code>，不记录如何命令。</li></ol><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><ol><li>默认值<ul><li>config get slowlog-max-len=128</li><li>config get slowlog-log-slower-than=10000</li></ul></li><li>修改配置文件重启，这种操作不建议去使用，这种操作是在第一次运行<code>Redis</code>的时候去进行，如果你的<code>Redis</code>启动了不建议使用这种方式；</li><li>动态配置；<ul><li>config set slowlog-max-len 1000</li><li>config set slowlog-log-slower-than 1000</li></ul></li></ol><h2 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h2><ol><li>slowlog get [n]：获取慢查询对列，这里的n可以限制对列的长度，比如n是10，那么列表中最多只能查询出10条记录；</li><li>slowlog len：获取慢查询对列长度，如果你想知道慢查询对列中有多少个慢查询可以使用这种命令</li><li>slowlog reset：清空慢查询对列；</li></ol><h2 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h2><ol><li><code>slowlog-max-len</code> 对列长度不要设置过小，通常设置1000左右，它默认是128，对列是存在内存当中的，当我们<code>Redis</code>重启之后它的列表就清空了，它是一个先进先出的对列，随着我们慢查询数量不断增加，最开始的慢查询就会丢掉，对于分析一个历史的问题可能不是很方便，所以需要设置大一些；</li><li><code>slowlog-log-slower-than</code> 超时时间不要设置过大，默认10ms，通常设置1ms，例如我们<code>Redis</code>的QPS是万级别的，我们希望它一秒执行一万次，那么平均时间是<code>0.01</code>毫秒，加入说我们设置过大的话，必须10毫秒才能记录这条命令，对于我们来说它可能超过1毫秒就对我们<code>QPS</code>是有影响的，这里要根据<code>QPS</code>来决定你一个阈值大小；</li><li>理解命令生命周期；</li><li>定期持久化慢查询，这个针对第二条，慢查询存储在内存当中，如果通过<code>slowlog get</code>这样的命令，定期将慢查询持久化到其他的数据源，比如说<code>mysql</code>，这样就可以查看到历史的慢查询操作，因为我们无论设置多大的长度（slowlog-log-slower-then），当慢查询逐步增多的时候，最开始的命令会被丢掉，当我们查一些历史问题时这些数据是非常关键的，所以你可以使用一些手段或者开源的软件来实现这些功能。</li></ol><h1 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h1><h2 id="什么流水线"><a href="#什么流水线" class="headerlink" title="什么流水线"></a>什么流水线</h2><h3 id="一次网络命令通信模型"><a href="#一次网络命令通信模型" class="headerlink" title="一次网络命令通信模型"></a>一次网络命令通信模型</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571144910775.png" srcset="/img/loading.gif" alt="1571144910775"></p><p>客户端通过网络将命令传输给服务端，当服务端会有一些排队、命令将它忽略，将它归纳成计算，然后把结果进行返回，一次命令时间=1次网路时间+1次命令时间；</p><h3 id="批量网络命令通信模型"><a href="#批量网络命令通信模型" class="headerlink" title="批量网络命令通信模型"></a>批量网络命令通信模型</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571145159164-1571145214835.png" srcset="/img/loading.gif" alt="1571145159164"></p><p>之前学过<code>mget</code>、<code>mset</code>这样的操作，假如<code>Redis</code>中没有这行命令，我们只能将命令以n次命令进行循环一个操作，n次时间=n次网络时间+n次命令时间；</p><p>一次命令时间是非常快的，<code>Redis</code>的QPS可以达到万级，那么网络相反，有很大的不同，因为我们可能存的是一个内网，可能是一个外网，甚至可能是一个跨机房、跨地区的有很多可能。我们想实现这样的命令需要怎么去做呢？比如我们有m次get操作可以使用mget、mset，那我想实现m次hmset，有没mhset 呢？Redis是没有的，或者我们想同时执行mset、mget这样的操作命令进行一个统一发送要怎么做呢？这就是流水线帮我们实现的功能。</p><p>流水线</p><p>它是将一批命令进行一个批量打包，在服务端进行批量计算，然后按顺序将结果返回给我们，这就是一个流水线，我们一次pipeline（n跳命令）=1次网络时间+n次命令时间，可以大大减少我们网络的开销，这就是流水线</p><h3 id="流水线作用"><a href="#流水线作用" class="headerlink" title="流水线作用"></a>流水线作用</h3><table><thead><tr><th align="center">命令</th><th align="center">N个命令操作</th><th align="center">1次pipeline（n个命令）</th></tr></thead><tbody><tr><td align="center">时间</td><td align="center">n次网络时间+n次命令</td><td align="center">1次网络时间+n次命令</td></tr><tr><td align="center">数据量</td><td align="center">1条命令</td><td align="center">n条命令</td></tr></tbody></table><p>注意：</p><ol><li><code>Redis</code>的命令时间是微秒级别，<code>Redis</code>执行命令的时间本身是非常快的</li><li><code>pipeline</code>每次条数要控制（网路），<code>Redis</code>的网络会成为瓶颈，因为我们网络环境肯定会相对复杂一些，所以<code>pipeline</code>就是为了解决n次操作网络的时间减小</li></ol><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571228474052.png" srcset="/img/loading.gif" alt="1571228474052"></p><p>这张地图上：北京到上海有1千3百公里，光速=3*108米秒=30000公里/秒，这里把复杂的网络环境进行忽略，而是完全将1千3百公里看成一个光纤，而且把光纤=光速的2/3，那么一条命令的传输时间=（1300 * 2）/(300000 * 2/3)=13毫秒，我一条命令在Redis看来就几微妙，但是在一个网络的传输时间是一个13毫秒，这里想象想做一个批量操作，没有使用<code>pipeline</code>这样的功能而是使用传统的一个循环的遍历，那我们的<code>Redis</code>使用效率不会很高，如果使用了<code>pipeline</code>，那时间消耗会被在网络上消耗一次，它命令批量会执行比较多，这只是一个极端的例子</p><h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><h3 id="不使用pipeline"><a href="#不使用pipeline" class="headerlink" title="不使用pipeline"></a>不使用pipeline</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571147034871.png" srcset="/img/loading.gif" alt="1571147034871"></p><h3 id="使用pipeline"><a href="#使用pipeline" class="headerlink" title="使用pipeline"></a>使用pipeline</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571147128248.png" srcset="/img/loading.gif" alt="1571147128248"></p><h2 id="与原生操作对比"><a href="#与原生操作对比" class="headerlink" title="与原生操作对比"></a>与原生操作对比</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571147368279.png" srcset="/img/loading.gif" alt="1571147368279"></p><ul><li>M操作：M操作属于原子操作，在<code>Redis</code>服务端它是有这样的原生命令的，所以它会其他操作在一个对列中是一个派对的效果；</li><li>pipeline：假如pipeline携带了1000条命令，而且我们是在一个非常高的QPS环境下去执行的话，那它到redis的时候，它是将pipeline中的命令进行拆分，这里的命令不是原子的命令，这里返回的结果是按顺序的。</li></ul><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li>注意每次<code>pipeline</code>携带数据量， <code>pipeline</code>可以提高我们并发的效率，就是批量的效率，但是并不能无节制的去使用，如果实现100万次的批量操作，那<code>Redis</code>将100万个命令一次一次发送，比如会对网络以及客户端等待时间都会造成影响；</li><li><code>pipeline</code>每次只能作用在一个<code>Redis</code>节点上；</li><li>M操作与<code>pipeline</code>区别一定要注意。</li></ol><h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ul><li>发布者（publisher）</li><li>订阅者（subscriber）</li><li>频道（channel）</li></ul><p>发布者来发布消息，订阅者来订阅频道，发布者会发布对应的频道上，发布者发布了订阅者订阅的频道，订阅者就能收到消息</p><h2 id="发布命令"><a href="#发布命令" class="headerlink" title="发布命令"></a>发布命令</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571150382094.png" srcset="/img/loading.gif" alt="1571150382094"></p><p>这里如果发送给频道一个消息，这个频道中没有订阅者时，返回：0</p><h2 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571150465419.png" srcset="/img/loading.gif" alt="1571150465419"></p><h2 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571150478793.png" srcset="/img/loading.gif" alt="1571150478793"></p><h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571150551396.png" srcset="/img/loading.gif" alt="1571150551396"></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>它于发布订阅的区别在于：发布者发布的消息只有一个订阅者能收到，这是一个抢的功能，而且<code>Redis</code>也没有提供这样的功能，使用list阻塞的去拉的功能，大家去抢这个东西。当你在开发的这样的功能时，要搞清楚你是希望消费者都收到还是只有一个收到。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>搞清楚发布订阅模式中的角色；</li><li>重要的API；</li><li>消息队列和发布订阅的使用场景。</li></ol><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571151448862.png" srcset="/img/loading.gif" alt="1571151448862"></p><p>图中有一个字符串叫做<code>“big”</code>，其中下面对应的是每一个字母的asics码，可以看到字母B的asics码是98，也就是对应的二进制，实际上在 <code>Redis</code>中可以对位进行操作，假如说设置了一个<code>set key</code>它的值为<code>“big”</code>，然后<code>get</code>的时候是可以取到<code>big</code>的结果，我们还可以取到它每一个位对应的值</p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> hello bigOK127.0.0.1:6382&gt; GETBIT hello 0 <span class="hljs-comment">#取第一位字节</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6382&gt; GETBIT hello 1 <span class="hljs-comment">#取第二位字节</span>(<span class="hljs-built_in">integer</span>) 1</code></pre><p>对于<code>Redis</code>来说，实际上是可以直接操作位的，下面来介绍下相关的API</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="setbit"><a href="#setbit" class="headerlink" title="setbit"></a>setbit</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571151608426.png" srcset="/img/loading.gif" alt="1571151608426"></p><blockquote><p>返回结果是它之前对应位的值，这里之前没有设置值，这里返回0</p></blockquote><p>结果为：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571151685655.png" srcset="/img/loading.gif" alt="1571151685655"></p><p>注意：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152327730.png" srcset="/img/loading.gif" alt="1571152327730"></p><p>在这里设置索引为50，位为1的情况，其他未设置的它会自动补0，这个操作本身就会比较慢，所以不在一个很短的位图上突然做很大的偏移量，这就会引起很多问题</p><h3 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h3><p> <img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152470270.png" srcset="/img/loading.gif" alt="1571152470270"></p><h3 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a>bitcount</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152540234.png" srcset="/img/loading.gif" alt="1571152540234"></p><h3 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152615140.png" srcset="/img/loading.gif" alt="1571152615140"></p><h3 id="bitpos"><a href="#bitpos" class="headerlink" title="bitpos"></a>bitpos</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152708769.png" srcset="/img/loading.gif" alt="1571152708769"></p><h2 id="独立用户统计"><a href="#独立用户统计" class="headerlink" title="独立用户统计"></a>独立用户统计</h2><ol><li>使用set和Bitmap对比</li><li>1亿用户，5千万独立访问</li></ol><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152865462.png" srcset="/img/loading.gif" alt="1571152865462"></p><h2 id="独立用户统计（续）"><a href="#独立用户统计（续）" class="headerlink" title="独立用户统计（续）"></a>独立用户统计（续）</h2><p>只有10万独立用户呢？</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571152954190.png" srcset="/img/loading.gif" alt="1571152954190"></p><h2 id="使用经验"><a href="#使用经验" class="headerlink" title="使用经验"></a>使用经验</h2><ol><li>type=string，最大512MB,对于大部分独立用户是可以满足的，假如说我们两无法满足的时候，我们可以将key进行拆分，使用多个key实现这个功能；</li><li>注意setbit时的偏移量，可能有较大耗时；</li><li>位图不是绝对好。</li></ol><h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><h2 id="新的数据结构"><a href="#新的数据结构" class="headerlink" title="新的数据结构"></a>新的数据结构</h2><ol><li>基于 HyperLogLog算法:极小空间完成独立数量统计；</li><li>2.本质还是字符串。</li></ol><h2 id="三个命令-1"><a href="#三个命令-1" class="headerlink" title="三个命令"></a>三个命令</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>pfadd key element [element…]:向 hyperloglog添加元素</li><li>pfcount key[key…]:计算 hyperloglog的独立总数</li><li>pfmerge deskey sourcekey[ sourcekey…J:合并多个 hyperloglog</li></ol><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571154873586.png" srcset="/img/loading.gif" alt="1571154873586"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571154949028.png" srcset="/img/loading.gif" alt="1571154949028"></p><h2 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h2><p>插入百万条记录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155041539.png" srcset="/img/loading.gif" alt="1571155041539"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155066244.png" srcset="/img/loading.gif" alt="1571155066244"></p><h2 id="使用经验-1"><a href="#使用经验-1" class="headerlink" title="使用经验"></a>使用经验</h2><ol><li>是否能容忍错误？（错误率：0.81%）</li><li>是否需要单条记录？</li></ol><h1 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h1><h2 id="GEO是什么？"><a href="#GEO是什么？" class="headerlink" title="GEO是什么？"></a>GEO是什么？</h2><blockquote><p>GEO是<code>Redis3.2</code>新增的特性，用于计算地理位置信息相关的功能</p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155474248.png" srcset="/img/loading.gif" alt="1571155474248"></p><h2 id="5个城市经纬度"><a href="#5个城市经纬度" class="headerlink" title="5个城市经纬度"></a>5个城市经纬度</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155530668.png" srcset="/img/loading.gif" alt="1571155530668"></p><h2 id="相关命令-1"><a href="#相关命令-1" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="geoadd"><a href="#geoadd" class="headerlink" title="geoadd"></a>geoadd</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155587057.png" srcset="/img/loading.gif" alt="1571155587057"></p><h3 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a>geopos</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155627868.png" srcset="/img/loading.gif" alt="1571155627868"></p><h3 id="geodist"><a href="#geodist" class="headerlink" title="geodist"></a>geodist</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155666402.png" srcset="/img/loading.gif" alt="1571155666402"></p><h3 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a>georadius</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155685404.png" srcset="/img/loading.gif" alt="1571155685404"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1571155764137.png" srcset="/img/loading.gif" alt="1571155764137"></p><h2 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h2><ol><li>since 3.2+提供的功能</li><li>type geoKey=zset</li><li>没有删除API:<code>zrem key member</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】  2.客户端使用</title>
    <link href="/redis-2.html"/>
    <url>/redis-2.html</url>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>创建一个<code>maven工程</code>，在<code>pom.xml</code>中加入依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h1 id="Jedis直连"><a href="#Jedis直连" class="headerlink" title="Jedis直连"></a>Jedis直连</h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.jedis.demo;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectConnectionDemo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer PORT = <span class="hljs-number">6382</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URI = <span class="hljs-string">"mcr2.com"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Jedis jedis = <span class="hljs-keyword">new</span> Jedis(URI, PORT);    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        kv();        list();        set();        zSet();    &#125;    <span class="hljs-comment">// kv</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kv</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"========================kv"</span>);        <span class="hljs-comment">//获取Redis客户端</span>        <span class="hljs-comment">//set</span>        jedis.set(<span class="hljs-string">"name"</span>, <span class="hljs-string">"shui"</span>);        <span class="hljs-comment">//get</span>        String name = jedis.get(<span class="hljs-string">"name"</span>);        System.out.println(name);    &#125;    <span class="hljs-comment">// list</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">list</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"========================list"</span>);        jedis.del(<span class="hljs-string">"list"</span>);        jedis.rpush(<span class="hljs-string">"list"</span>, <span class="hljs-string">"1"</span>);        jedis.rpush(<span class="hljs-string">"list"</span>, <span class="hljs-string">"2"</span>);        jedis.rpush(<span class="hljs-string">"list"</span>, <span class="hljs-string">"3"</span>);        jedis.rpush(<span class="hljs-string">"list"</span>, <span class="hljs-string">"4"</span>);        jedis.lrange(<span class="hljs-string">"list"</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).forEach(System.out::println);    &#125;    <span class="hljs-comment">// set</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"========================set"</span>);        jedis.del(<span class="hljs-string">"set"</span>);        jedis.sadd(<span class="hljs-string">"set"</span>, <span class="hljs-string">"a"</span>);        jedis.sadd(<span class="hljs-string">"set"</span>, <span class="hljs-string">"b"</span>);        jedis.sadd(<span class="hljs-string">"set"</span>, <span class="hljs-string">"b"</span>);        jedis.smembers(<span class="hljs-string">"set"</span>).forEach(System.out::println);    &#125;    <span class="hljs-comment">// zSet</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">zSet</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"========================zSet"</span>);        jedis.del(<span class="hljs-string">"zset"</span>);        jedis.zadd(<span class="hljs-string">"zset"</span>, <span class="hljs-number">99</span>, <span class="hljs-string">"tom"</span>);        jedis.zadd(<span class="hljs-string">"zset"</span>, <span class="hljs-number">66</span>, <span class="hljs-string">"perter"</span>);        jedis.zadd(<span class="hljs-string">"zset"</span>, <span class="hljs-number">33</span>, <span class="hljs-string">"james"</span>);        System.out.println(jedis.zrangeWithScores(<span class="hljs-string">"zset"</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>));    &#125;&#125;</code></pre><h1 id="Jedis连接池配置"><a href="#Jedis连接池配置" class="headerlink" title="Jedis连接池配置"></a>Jedis连接池配置</h1><h2 id="配置列表"><a href="#配置列表" class="headerlink" title="配置列表"></a>配置列表</h2><table><thead><tr><th align="center">参数名</th><th align="center">含义</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">maxTotal</td><td align="center">资源最大连接数</td><td align="center">8</td></tr><tr><td align="center">maxIdel</td><td align="center">资源池允许最大空闲连接数</td><td align="center">8</td></tr><tr><td align="center">minIdle</td><td align="center">资源池确保最少空闲连接数</td><td align="center">0</td></tr><tr><td align="center">jmxEnabled</td><td align="center">是否开启jmx监控，可用于监控</td><td align="center">true</td></tr><tr><td align="center">blockWhenExhausted</td><td align="center">当资源池用尽后，调用者是否的要等待。只有当为true时，下面的maxWaitMillis才会生效</td><td align="center">true</td></tr><tr><td align="center">maxWaitMillis</td><td align="center">当资源池连接用尽后，调用者的最大等待时间（单位为毫秒）</td><td align="center">-1表示永不超时</td></tr><tr><td align="center">testOnBorrow</td><td align="center">向资源池借用连接时是否做连接有效性检测（ping），无效连接会被移除</td><td align="center">false</td></tr><tr><td align="center">testOnReturn</td><td align="center">向资源池归还连接时是否做连接有效性检测（ping），无效连接会被移除</td><td align="center">false</td></tr></tbody></table><h2 id="适合的maxTotal"><a href="#适合的maxTotal" class="headerlink" title="适合的maxTotal"></a>适合的maxTotal</h2><p>比较难确定的，举个例子：</p><ol><li>命令平均执行时间0.1ms=0.0001s;</li><li>业务需要50000 QPS;</li><li>maxTotal理论值=0.001*50000=50个。实际值要偏大一些。</li></ol><p>设置maxTotal需要考虑的问题：</p><ol><li>业务希望Redis并发量；</li><li>客户端执行命令时间；</li><li>Redis资源：例如<code>nodes(例如应用个数)* maxTotal</code>是不能超过Redis的最大连接数。（config get maxclients）</li></ol><h2 id="适合的maxIdel和minIdle"><a href="#适合的maxIdel和minIdle" class="headerlink" title="适合的maxIdel和minIdle"></a>适合的maxIdel和minIdle</h2><p>建议<code>maxIdel</code>=<code>minIdle</code>,假如我现在<code>maxTotal：100</code>,<code>maxIdel：50</code>,现在允许最大的空闲数也就是50，假如现在已经在一个高峰期，我资源中的连接池已经通过<code>getResource</code>获取到了，这个时候第51个连接需要通过<code>new Jedis</code>以及<code>cp的三次握</code>手才能到新的连接，实际上这本身是有一定开销的，通常我们会将这2个属性设置成一样减少创建新连接的开销</p><hr><p>建议预热minIdle，在JedisPool初始化的时候，在第一次<code>getResource</code>的时候，依然是通过<code>new</code>来完成的，对于一些并发量特别大的应用来说，它认为第一次<code>new</code>还是不能容忍，这个时候可以在应用初始化的时候提前去<code>new</code>一些<code>getResource</code>去让它做一些操作</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="获取连接超时"><a href="#获取连接超时" class="headerlink" title="获取连接超时"></a>获取连接超时</h3><pre><code class="hljs java">redis clients. jedis exceptions. JedisConnectionException: Could not get a resource from the poolCaused by: java util. NoSuch Element Exception: Timeout waiting <span class="hljs-keyword">for</span> idle objectat org.apache commons. pool2 impl. GenericObjectPool. borrowobject(GenericObjectPool java: <span class="hljs-number">449</span>)</code></pre><h3 id="连接池资源耗尽"><a href="#连接池资源耗尽" class="headerlink" title="连接池资源耗尽"></a>连接池资源耗尽</h3><blockquote><p>在连接数到最大的时候，按道理现在会出现一个等的行为，但在我这设置为不等，它就会告诉你池子的资源耗尽</p></blockquote><pre><code class="hljs java">redis clients. jedis. exceptions. Jedis ConnectionException: Could not get a resource from the poolCaused by: java util. NoSuchElementEXception: Pool exhaustedat org. apache commons. pool2impl. GenericObjectPool. borrowobject(GenericObjectPool java: <span class="hljs-number">464</span>)</code></pre><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul><li>慢查询阻塞：池子连接都被hang住；</li></ul><blockquote><p>假如我们连接池中设置<code>maxTotal：8</code>,假如现在有8个线程正在执行一个操作，对于Redis来说，无论借还执行操作都是非常快的，在某一个瞬间这些操作都被hang住了，这些操作执行非常慢，例如这8个都在执行<code>keys</code> * 或者某些原因Redis单线程被阻塞了这8个连接都要对这个操作进行等待，在等待期间，这个时候再去一个<code>getResouce</code>就会出现刚才那样的情况<code>连接池资源耗尽</code></p></blockquote><ul><li>资源池参数不合理：例如QPS高、池子小;</li></ul><blockquote><p>假如QPS为100w，但池子还设置成8，这样就不是很合理</p></blockquote><ul><li>连接泄露（没有close()）：此类问题比较难定位，例如<code>client list</code>、<code>netstat</code>等，最重要的是代码;</li><li>DNS异常等。</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>模拟连接泄露</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.shui.jedis.demo;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisPoolOptimizeTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();        jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);        jedisPoolConfig.setMaxWaitMillis(<span class="hljs-number">1000</span>);        JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, <span class="hljs-string">"mcr2.com"</span>, <span class="hljs-number">6382</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            Jedis jedis = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">try</span> &#123;                jedis = jedisPool.getResource();                System.out.println(jedis.ping());            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();            &#125;            System.out.println(jedisPool.getResource().ping());        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java">PONGPONGPONGPONGPONGPONGPONGPONGPONGPONGredis.clients.jedis.exceptions.JedisException: Could not get a resource from the poolat redis.clients.util.Pool.getResource(Pool.java:<span class="hljs-number">51</span>)at redis.clients.jedis.JedisPool.getResource(JedisPool.java:<span class="hljs-number">226</span>)at com.shui.jedis.demo.JedisPoolOptimizeTest.main(JedisPoolOptimizeTest.java:<span class="hljs-number">18</span>)Caused by: java.util.NoSuchElementException: Timeout waiting <span class="hljs-keyword">for</span> idle objectat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:<span class="hljs-number">449</span>)at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:<span class="hljs-number">363</span>)at redis.clients.util.Pool.getResource(Pool.java:<span class="hljs-number">49</span>)... <span class="hljs-number">2</span> moreException in thread <span class="hljs-string">"main"</span> redis.clients.jedis.exceptions.JedisException: Could not get a resource from the poolat redis.clients.util.Pool.getResource(Pool.java:<span class="hljs-number">51</span>)at redis.clients.jedis.JedisPool.getResource(JedisPool.java:<span class="hljs-number">226</span>)at com.shui.jedis.demo.JedisPoolOptimizeTest.main(JedisPoolOptimizeTest.java:<span class="hljs-number">23</span>)Caused by: java.util.NoSuchElementException: Timeout waiting <span class="hljs-keyword">for</span> idle objectat org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:<span class="hljs-number">449</span>)at org.apache.commons.pool2.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:<span class="hljs-number">363</span>)at redis.clients.util.Pool.getResource(Pool.java:<span class="hljs-number">49</span>)... <span class="hljs-number">2</span> more</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 Redis-学习笔记 】  1.基本使用</title>
    <link href="/redis-1.html"/>
    <url>/redis-1.html</url>
    
    <content type="html"><![CDATA[<h1 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /optwget  http://download.redis.io/releases/redis-3.0.7.tar.gztar -zxvf redis-3.0.7.tar.gz -C /usr/src<span class="hljs-built_in">cd</span> /usr/srcmv redis-3.0.7/ redis<span class="hljs-built_in">cd</span> redis/make &amp;&amp; make install</code></pre><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>由于<code>Redis</code>是一个单线程，所以在服务器上会启动3个<code>Redis</code>来提高性能，我们这里先不介绍启动多个<code>Redis</code>，这里为了区分配置文件，将配置文章由<code>redis-prot.conf</code>命名</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src/redismkdir configcp redis.conf config/cat redis.conf | grep -v <span class="hljs-string">"#"</span> | grep -v <span class="hljs-string">"^$"</span> &gt; redis-6382.conf</code></pre><p><code>redis-6382.conf</code>内容：</p><pre><code class="hljs vim">daemonize yesport <span class="hljs-number">6382</span>dir <span class="hljs-string">"/usr/src/redis/data"</span>logfile <span class="hljs-string">"6382.log"</span></code></pre><p>在<code>redis</code>文件中创建<code>data</code>目录</p><pre><code class="hljs bash">mkdir data</code></pre><p>启动</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/src/redisredis-server  config/redis-6382.conf</code></pre><h2 id="使用redis-cli连接redis服务"><a href="#使用redis-cli连接redis服务" class="headerlink" title="使用redis-cli连接redis服务"></a>使用<code>redis-cli</code>连接<code>redis</code>服务</h2><pre><code class="hljs bash">redis-cli  -p 6382</code></pre><h1 id="API的使用和理解"><a href="#API的使用和理解" class="headerlink" title="API的使用和理解"></a>API的使用和理解</h1><h2 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p><strong>语法</strong></p><blockquote><p>keys [pattern]</p></blockquote><p><strong>演示</strong></p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> k1 v1OK127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> k2 v2OK127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> k3 v3OK127.0.0.1:6382&gt; KEYS *1) <span class="hljs-string">"k3"</span>2) <span class="hljs-string">"k1"</span>3) <span class="hljs-string">"k2"</span>127.0.0.1:6382&gt; mset hello world hehe haha php good phe thisOK127.0.0.1:6382&gt; KEYS he*1) <span class="hljs-string">"hello"</span>2) <span class="hljs-string">"hehe"</span>127.0.0.1:6382&gt; KEYS he[h<span class="hljs-_">-l</span>]*1) <span class="hljs-string">"hello"</span>2) <span class="hljs-string">"hehe"</span>127.0.0.1:6382&gt; KEYS ph?1) <span class="hljs-string">"php"</span>2) <span class="hljs-string">"phe"</span></code></pre><p><strong>说明</strong></p><blockquote><p>keys命令一般不再生产环境使用</p></blockquote><h3 id="dbsize"><a href="#dbsize" class="headerlink" title="dbsize"></a>dbsize</h3><p><strong>演示</strong></p><pre><code class="hljs bash">127.0.0.1:6382&gt; DBSIZE(<span class="hljs-built_in">integer</span>) 7127.0.0.1:6382&gt;</code></pre><p><strong>说明</strong></p><blockquote><p><code>dbsize</code>是可以在线上使用的，它不是对<code>redis</code>全局遍历一逼，<code>redis</code>内置了一个计数器，它会实时更新计数器的总数</p></blockquote><h3 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h3><p><strong>语法</strong></p><pre><code class="hljs bash">exists key <span class="hljs-comment">#检查key是否存在，1：true，0：false</span></code></pre><p><strong>演示</strong></p><pre><code class="hljs bash">127.0.0.1:6382&gt; SET a bOK127.0.0.1:6382&gt; EXISTS a(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; del a<span class="hljs-comment">#根据key进行删除</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; EXISTS a(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6382&gt;</code></pre><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><p><strong>语法</strong></p><pre><code class="hljs bash">del key [key…]<span class="hljs-comment">#删除指定key-value，可以删除多个</span></code></pre><p><strong>演示</strong></p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> a bOK127.0.0.1:6382&gt; get a<span class="hljs-string">"b"</span>127.0.0.1:6382&gt; del a(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; get a(nil)127.0.0.1:6382&gt;</code></pre><h3 id="expire、ttl、persist"><a href="#expire、ttl、persist" class="headerlink" title="expire、ttl、persist"></a>expire、ttl、persist</h3><p><strong>语法</strong></p><pre><code class="hljs bash">expire key seconds<span class="hljs-comment">#key在seconds秒后过期</span>ttl key<span class="hljs-comment">#查看key剩余的过期时间</span>persist key<span class="hljs-comment">#去掉key的过期时间</span></code></pre><p><strong>演示</strong></p><p>设置过期时间</p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> hello wolrdOK127.0.0.1:6382&gt; EXPIRE hello 20(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; ttl hello(<span class="hljs-built_in">integer</span>) 16127.0.0.1:6382&gt; get hello<span class="hljs-string">"wolrd"</span><span class="hljs-comment">#过期时间过去之后</span>127.0.0.1:6382&gt; ttl hello(<span class="hljs-built_in">integer</span>) -2<span class="hljs-comment">#-2表示已经不存在了</span>127.0.0.1:6382&gt; get hello(nil)</code></pre><p>去掉过期时间</p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> hello worldOK127.0.0.1:6382&gt; expire hello 20(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; ttl hello(<span class="hljs-built_in">integer</span>) 17127.0.0.1:6382&gt; PERSIST hello(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6382&gt; ttl hello(<span class="hljs-built_in">integer</span>) -1<span class="hljs-comment">#-1表示没有过期时间</span></code></pre><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><strong>语法</strong></p><pre><code class="hljs bash"><span class="hljs-built_in">type</span> key<span class="hljs-comment">#返回key的类型</span></code></pre><p><strong>演示</strong></p><pre><code class="hljs bash">127.0.0.1:6382&gt; <span class="hljs-built_in">set</span> k vOK127.0.0.1:6382&gt; TYPE kstring</code></pre><h3 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570946588148.png" srcset="/img/loading.gif" alt="1570946588148"></p><p>对于<code>redis</code>内部来说，它有自己的内部编码；</p><p>举个例子：</p><p>看图中的<code>hash</code>，它对用户来说它是一个<code>hash</code>，但对于它内部来说，可能是<code>hashtable</code>、<code>ziplist</code>，那么<code>redis</code>为什么要这么做呢？</p><p>首先<code>redis</code>是一个内存的数据库，对于内存来说是非常昂贵的，假设我们在使用某一种数据结构的时候以空间换取时间的话，我们就可以使用压缩的结构，比如<code>hahs</code>的<code>ziplist</code>结构，当它的元素比较小的时候，那么我就可以使用空间换时间，因为它的元素比较小，在做一些遍历查找它也不会消耗很多的时间，这样使用更小的空间来达到更优的内存使用效果。</p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ul><li>一次只执行一条命令</li><li>拒绝慢命令<ul><li>key</li><li>flushall</li><li>flushdb</li><li>slow lua script</li><li>mutil/exec</li><li>operate big value(collection)</li></ul></li><li>其实不是单线程<ul><li>fysnc file descriptor </li><li>close file descriptor </li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="incr、decr、incrby、decrby"><a href="#incr、decr、incrby、decrby" class="headerlink" title="incr、decr、incrby、decrby"></a>incr、decr、incrby、decrby</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1835062274102102.png" srcset="/img/loading.gif" alt="incr、decr、incrby、decrby"></p><h3 id="set、setnx、setxx"><a href="#set、setnx、setxx" class="headerlink" title="set、setnx、setxx"></a>set、setnx、setxx</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/18040409055744.png" srcset="/img/loading.gif" alt="incr、decr、incrby、decrby"></p><h3 id="mget、mset"><a href="#mget、mset" class="headerlink" title="mget、mset"></a>mget、mset</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570953277140.png" srcset="/img/loading.gif" alt="1570953277140"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570953443449.png" srcset="/img/loading.gif" alt="1570953443449"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570953459051.png" srcset="/img/loading.gif" alt="1570953459051"></p><h3 id="getset、append、strlen"><a href="#getset、append、strlen" class="headerlink" title="getset、append、strlen"></a>getset、append、strlen</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570953545704.png" srcset="/img/loading.gif" alt="1570953545704"></p><h3 id="incrbyfloat、getrange、setrange"><a href="#incrbyfloat、getrange、setrange" class="headerlink" title="incrbyfloat、getrange、setrange"></a>incrbyfloat、getrange、setrange</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570953706510.png" srcset="/img/loading.gif" alt="1570953706510"></p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><h3 id="hget、hset、hdel"><a href="#hget、hset、hdel" class="headerlink" title="hget、hset、hdel"></a>hget、hset、hdel</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570954168175.png" srcset="/img/loading.gif" alt="1570954168175"></p><h3 id="hexists、hlen"><a href="#hexists、hlen" class="headerlink" title="hexists、hlen"></a>hexists、hlen</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570954337386.png" srcset="/img/loading.gif" alt="1570954337386"></p><h3 id="hmget、hmset"><a href="#hmget、hmset" class="headerlink" title="hmget、hmset"></a>hmget、hmset</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570954768771.png" srcset="/img/loading.gif" alt="1570954768771"></p><h3 id="hgetall、hvals、hkeys"><a href="#hgetall、hvals、hkeys" class="headerlink" title="hgetall、hvals、hkeys"></a>hgetall、hvals、hkeys</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570955042992.png" srcset="/img/loading.gif" alt="1570955042992"></p><h3 id="hsetnx、hincrby、hincrbyfloat"><a href="#hsetnx、hincrby、hincrbyfloat" class="headerlink" title="hsetnx、hincrby、hincrbyfloat"></a>hsetnx、hincrby、hincrbyfloat</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570955599297.png" srcset="/img/loading.gif" alt="1570955599297"></p><h3 id="相似的API"><a href="#相似的API" class="headerlink" title="相似的API"></a>相似的API</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570955212178.png" srcset="/img/loading.gif" alt="1570955212178"></p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="增-rpush"><a href="#增-rpush" class="headerlink" title="增-rpush"></a>增-rpush</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956073816.png" srcset="/img/loading.gif" alt="1570956073816"></p><h3 id="增-lpush"><a href="#增-lpush" class="headerlink" title="增-lpush"></a>增-lpush</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956130261.png" srcset="/img/loading.gif" alt="1570956130261"></p><h3 id="增-linsert"><a href="#增-linsert" class="headerlink" title="增-linsert"></a>增-linsert</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956211897.png" srcset="/img/loading.gif" alt="1570956211897"></p><h3 id="删-lpop"><a href="#删-lpop" class="headerlink" title="删-lpop"></a>删-lpop</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956226489.png" srcset="/img/loading.gif" alt="1570956226489"></p><h3 id="删-rpop"><a href="#删-rpop" class="headerlink" title="删-rpop"></a>删-rpop</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956245391.png" srcset="/img/loading.gif" alt="1570956245391"></p><h3 id="删-lrem"><a href="#删-lrem" class="headerlink" title="删-lrem"></a>删-lrem</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956295624.png" srcset="/img/loading.gif" alt="1570956295624"></p><pre><code class="hljs bash">lrem listkey 0 a<span class="hljs-comment">#删除所有等于a的元素</span>lrem listkey -1 c<span class="hljs-comment">#从右边开始，把最右边的c删除</span></code></pre><h3 id="删-ltrim"><a href="#删-ltrim" class="headerlink" title="删-ltrim"></a>删-ltrim</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956626328.png" srcset="/img/loading.gif" alt="1570956626328">     </p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956651183.png" srcset="/img/loading.gif" alt="1570956651183"></p><pre><code class="hljs bash">ltrim listkye 1 4<span class="hljs-comment">#保留1-4的数据</span></code></pre><h3 id="查-lrange"><a href="#查-lrange" class="headerlink" title="查-lrange"></a>查-lrange</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956744153.png" srcset="/img/loading.gif" alt="1570956744153"></p><h3 id="查-lindex"><a href="#查-lindex" class="headerlink" title="查-lindex"></a>查-lindex</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570956823765.png" srcset="/img/loading.gif" alt="1570956823765"></p><h3 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570957349048.png" srcset="/img/loading.gif" alt="1570957349048"></p><h3 id="blpop、brpop"><a href="#blpop、brpop" class="headerlink" title="blpop、brpop"></a>blpop、brpop</h3><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1570957222653.png" srcset="/img/loading.gif" alt="1570957222653"></p><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ul><li>LRPUSH+LPOP=Stack</li><li>LPUSH+RPOP=Queue</li><li>LPUSH+LTRIM=Capped Collection</li><li>LPUSH+BRPOP=Message Queue</li></ul>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 六、RBAC 】 4.基于数据库Rbac数据模型控制权限</title>
    <link href="/spring-security-6.4.html"/>
    <url>/spring-security-6.4.html</url>
    
    <content type="html"><![CDATA[<h1 id="基于数据库Rbac数据模型控制权限"><a href="#基于数据库Rbac数据模型控制权限" class="headerlink" title="基于数据库Rbac数据模型控制权限"></a>基于数据库Rbac数据模型控制权限</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568633214421.png" srcset="/img/loading.gif" alt="1568633214421"></p><p>一般的内部管理系统，权限比较复杂，通常权限都是动态配置的，也就是下面我们要讲的的rbac模型</p><h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><p>详细原理请度娘，这里只是涉及到企业权限的功能级权限，数据级权限还要我们自己控制（用户只能看见它相关的业务表数据）</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568633350762.png" srcset="/img/loading.gif" alt="1568633350762"></p><p>为了方便演示，这里重新创建一个子工厂：mcr-auth-authorize，pom.xml如下：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>RbacService</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.rbac.service;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用户权限判断接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RbacService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(HttpServletRequest request, Authentication authentication)</span></span>;&#125;</code></pre><p>RbacServiceImpl</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.rbac.service;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.util.AntPathMatcher;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"rbacService"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RbacServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RbacService</span> </span>&#123;    <span class="hljs-keyword">private</span> AntPathMatcher antPathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPermission</span><span class="hljs-params">(HttpServletRequest request, Authentication authentication)</span> </span>&#123;        Object principal = authentication.getPrincipal();        <span class="hljs-keyword">boolean</span> hasPermission = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (principal <span class="hljs-keyword">instanceof</span> UserDetails) &#123;            String username = ((UserDetails) principal).getUsername();            <span class="hljs-comment">//读取用户所拥有权限的所有URL 这个应该根据用户名从数据库中查询 此处只是模拟</span>            List&lt;String&gt; urls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();            <span class="hljs-keyword">for</span> (String url : urls) &#123;                <span class="hljs-comment">//匹配 /user/* 这种格式</span>                <span class="hljs-keyword">if</span> (antPathMatcher.match(url, request.getRequestURI())) &#123;                    hasPermission = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> hasPermission;    &#125;&#125;</code></pre><p>demo#pom.xml</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-authorize<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>DemoAuthorizeConfigProvider</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 业务模块权限配置实现</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order</span>(Integer.MAX_VALUE)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAuthorizeConfigProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizeConfigProvider</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;<span class="hljs-comment">//        config.antMatchers(</span><span class="hljs-comment">//                "/user/regist", // 注册请求</span><span class="hljs-comment">//                "/error",</span><span class="hljs-comment">//                "/connect/*",</span><span class="hljs-comment">//                "/auth/*",</span><span class="hljs-comment">//                "/signin",</span><span class="hljs-comment">//                "/social/signUp",  // app注册跳转服务</span><span class="hljs-comment">//                "/swagger-ui.html",</span><span class="hljs-comment">//                "/swagger-ui.html/**",</span><span class="hljs-comment">//                "/webjars/**",</span><span class="hljs-comment">//                "/swagger-resources/**",</span><span class="hljs-comment">//                "/v2/**"</span><span class="hljs-comment">//        ).permitAll();</span>          <span class="hljs-comment">/*</span><span class="hljs-comment"> 利用@Order注解实现CommonAuthorizeConfigProvider中的放行路径不需要自定义权限验证</span><span class="hljs-comment"> */</span>        config.anyRequest()                .access(<span class="hljs-string">"@rbacService.hasPermission(request,authentication)"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 六、RBAC 】 3.权限表达式</title>
    <link href="/spring-security-6.3.html"/>
    <url>/spring-security-6.3.html</url>
    
    <content type="html"><![CDATA[<h1 id="权限表达式"><a href="#权限表达式" class="headerlink" title="权限表达式"></a>权限表达式</h1><p>通过源码分析可知，最终的配置都会转成<strong>ExpressionUrlAuthorizationConfigurer.AuthorizedUrl</strong>并进行投票决定。</p><p>常见表达式如下：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568559383045.png" srcset="/img/loading.gif" alt="1568559383045"></p><p>如何写联合表达式呢？就是既满足A条件，也满足B条件</p><pre><code class="hljs java">.antMatchers(<span class="hljs-string">"xx"</span>).access(<span class="hljs-string">"hasRole('ROLE_USER') and hasRole('ROLE_SUPER')"</span>)</code></pre><p> 这个都是spring自己的权限表达式，那么我们是否可以自定义实现自己的权限规则呢？可以的！这个我们下一章再看怎么实现。</p><h1 id="权限业务配置分离"><a href="#权限业务配置分离" class="headerlink" title="权限业务配置分离"></a>权限业务配置分离</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568559938142.png" srcset="/img/loading.gif" alt="1568559938142"></p><p>这里的代码不应该是写在browser中的，这里的代码应该由demo模块也就是使用者来编写，那么如何将权限模块配置和业务模块配置想分离呢？下面就来满足这个业务场景</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568560039993.png" srcset="/img/loading.gif" alt="1568560039993"></p><p>实现思路如下：</p><p>提供AuthorizeConfigProvider接口，提供权限设置<br>权限模块的通用配置实现该接口，然后进行配置，业务模块按需也实现该接口进行配置<br>最后使用 AuthorizeConfigManager类来管理所有的AuthorizeConfigProvider实现<br>拿到所有的配置后，进行统一设置</p><hr><p>代码实现如下：</p><p>权限控制接口及实现 </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authorize; <span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义权限控制接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizeConfigProvider</span> </span>&#123; <span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> config</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回的boolean表示配置中是否有针对anyRequest的配置。在整个授权配置中，</span><span class="hljs-comment"> * 应该有且仅有一个针对anyRequest的配置，如果所有的实现都没有针对anyRequest的配置，</span><span class="hljs-comment"> * 系统会自动增加一个anyRequest().authenticated()的配置。如果有多个针对anyRequest</span><span class="hljs-comment"> * 的配置，则会抛出异常。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span></span>;&#125;</code></pre><p>通用权限设置</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authorize;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.SecurityConstants;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.SecurityProperties;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 通用权限接口配置管理</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-meta">@Order</span>(Integer.MIN_VALUE)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonAuthorizeConfigProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizeConfigProvider</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;        config.antMatchers(                SecurityConstants.DEFAULT_UNAUTHENTICATED_URL,<span class="hljs-comment">//权限认证</span>                SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE,<span class="hljs-comment">//手机</span>                SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_OPENID,<span class="hljs-comment">//openId</span>                securityProperties.getBrowser().getLoginUrl(),<span class="hljs-comment">//登录页面</span>                SecurityConstants.DEFAULT_VALIDATE_CODE_URL_PREFIX + <span class="hljs-string">"/*"</span>,                securityProperties.getBrowser().getSignUpUrl(),<span class="hljs-comment">//                securityProperties.getBrowser().getSignOutUrl(),</span>                securityProperties.getBrowser().getSession().getSessionInvalidUrl()        ).permitAll();<span class="hljs-comment">//放行</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre><p>业务模块权限设置</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.authorize.AuthorizeConfigProvider;<span class="hljs-keyword">import</span> org.springframework.core.annotation.Order;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 业务模块权限配置实现</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@Order</span>(Integer.MAX_VALUE)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAuthorizeConfigProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizeConfigProvider</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;        config.antMatchers(                <span class="hljs-string">"/user/regist"</span>, <span class="hljs-comment">// 注册请求</span>                <span class="hljs-string">"/error"</span>,                <span class="hljs-string">"/connect/*"</span>,                <span class="hljs-string">"/auth/*"</span>,                <span class="hljs-string">"/signin"</span>,                <span class="hljs-string">"/social/signUp"</span>,  <span class="hljs-comment">// app注册跳转服务</span>                <span class="hljs-string">"/swagger-ui.html"</span>,                <span class="hljs-string">"/swagger-ui.html/**"</span>,                <span class="hljs-string">"/webjars/**"</span>,                <span class="hljs-string">"/swagger-resources/**"</span>,                <span class="hljs-string">"/v2/**"</span>        ).permitAll();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>权限接口管理器及实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authorize; <span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 权限控制接口持有管理者</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorizeConfigManager</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span></span>;&#125;</code></pre><p>权限接口管理器及实现默认实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authorize;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-comment">/**</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultAuthorizeConfigManager</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthorizeConfigManager</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> List&lt;AuthorizeConfigProvider&gt; providers;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">config</span><span class="hljs-params">(ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry config)</span> </span>&#123;        <span class="hljs-keyword">boolean</span> existAnyRequestConfig = <span class="hljs-keyword">false</span>;        String existAnyRequestConfigName = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">for</span> (AuthorizeConfigProvider authorizeConfigProvider : providers) &#123;            <span class="hljs-keyword">boolean</span> currentIsAnyRequestConfig = authorizeConfigProvider.config(config);            <span class="hljs-keyword">if</span> (!existAnyRequestConfig &amp;&amp; !currentIsAnyRequestConfig) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"重复的anyRequest配置:"</span> + existAnyRequestConfigName + <span class="hljs-string">","</span>                        + authorizeConfigProvider.getClass().getSimpleName());            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentIsAnyRequestConfig) &#123;                existAnyRequestConfig = <span class="hljs-keyword">true</span>;                existAnyRequestConfigName = authorizeConfigProvider.getClass().getSimpleName();            &#125;        &#125;        <span class="hljs-keyword">if</span> (existAnyRequestConfig) &#123;            config.anyRequest().authenticated();        &#125;    &#125;&#125;</code></pre><p>浏览器模块配置进行调整（app模块同理），就是将原来的配置抽离出去。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;    <span class="hljs-keyword">private</span> AuthorizeConfigManager authorizeConfigManager;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BrowserSecurityProperties browser = security.getBrowser();        http                .rememberMe()                .tokenRepository(repository())                .tokenValiditySeconds(browser.getRememberMeSeconds())                .userDetailsService(userDetailsService)                .and()                .logout()<span class="hljs-comment">//                .logoutSuccessUrl("/mcr-logout.html")</span>                .logoutSuccessHandler(logoutSuccessHandler)                .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)                .logoutUrl(<span class="hljs-string">"/signOut"</span>)                .and()                .sessionManagement()                .invalidSessionStrategy(invalidSessionStrategy)                .maximumSessions(browser.getSession().getMaximumSessions()).maxSessionsPreventsLogin(browser.getSession().isMaxSessionsPreventsLogin())                .expiredSessionStrategy(sessionInformationExpiredStrategy)                .and()                .and()                .apply(smsCodeAuthenticationSecurityConfig)                .and()                .apply(mcrSpringSocialConfigurer)                .and()                .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"></span><span class="hljs-class">                .<span class="hljs-title">formLogin</span>()</span><span class="hljs-class">                .<span class="hljs-title">successHandler</span>(<span class="hljs-title">authenticationSuccessHandler</span>)</span><span class="hljs-class">                .<span class="hljs-title">failureHandler</span>(<span class="hljs-title">authenticationFailureHandler</span>)</span><span class="hljs-class">                .<span class="hljs-title">loginPage</span>(<span class="hljs-title">SecurityConstants</span>.<span class="hljs-title">DEFAULT_UNAUTHENTICATED_URL</span>)</span><span class="hljs-class">                .<span class="hljs-title">loginProcessingUrl</span>(<span class="hljs-title">SecurityConstants</span>.<span class="hljs-title">DEFAULT_LOGIN_PROCESSING_URL_FORM</span>)</span><span class="hljs-class">                .<span class="hljs-title">and</span>()</span><span class="hljs-class">                .<span class="hljs-title">csrf</span>()</span><span class="hljs-class">                .<span class="hljs-title">disable</span>()</span>;        authorizeConfigManager.config(http.authorizeRequests());    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 六、RBAC 】 2.Spring Security授权源码解析</title>
    <link href="/spring-security-6.2.html"/>
    <url>/spring-security-6.2.html</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Security授权源码解析"><a href="#Spring-Security授权源码解析" class="headerlink" title="Spring Security授权源码解析"></a>Spring Security授权源码解析</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568551319566.png" srcset="/img/loading.gif" alt="1568551319566"></p><blockquote><p>FilterSecurityInterceptor负责最终决定当前的请求是否能通过过滤器来访问最后的api，如果不能会根据不同的原因抛出异常，然后由ExceptionTranslationFilter来处理， </p></blockquote><p>上面的过滤器链我就不在重复说一遍了，这里要介绍的AnonymousAuthenticationFilter，这个过滤器中文意思：匿名过滤器，它在图中过滤器链，绿色过滤器中的最后一个，看来一下它的doFilter方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<span class="hljs-keyword">if</span> (SecurityContextHolder.getContext().getAuthentication() == <span class="hljs-keyword">null</span>) &#123;SecurityContextHolder.getContext().setAuthentication(createAuthentication((HttpServletRequest) req));<span class="hljs-comment">//....</span>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//...&#125;</span>chain.doFilter(req, res);&#125;</code></pre><p>这里的逻辑很简单，就是判断SecurityContext里面是否有Authentication,如果是空的，它会执行createAuthentication方法来创建一个Authentication放到SecurityContext里，来看一下这个方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Authentication <span class="hljs-title">createAuthentication</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;AnonymousAuthenticationToken auth = <span class="hljs-keyword">new</span> AnonymousAuthenticationToken(key,principal, authorities);auth.setDetails(authenticationDetailsSource.buildDetails(request));<span class="hljs-keyword">return</span> auth;&#125;</code></pre><p>在这里的AnonymousAuthenticationToken创建可以看一下代码中，看出来这里的用户信息是一个字符串:“anonymousUser”，不和之前的Token一样是UserDetails接口的实现，</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousAuthenticationFilter</span><span class="hljs-params">(String key)</span> </span>&#123;<span class="hljs-keyword">this</span>(key, <span class="hljs-string">"anonymousUser"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_ANONYMOUS"</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousAuthenticationFilter</span><span class="hljs-params">(String key, Object principal,</span></span><span class="hljs-function"><span class="hljs-params">List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;Assert.hasLength(key, <span class="hljs-string">"key cannot be null or empty"</span>);Assert.notNull(principal, <span class="hljs-string">"Anonymous authentication principal must be set"</span>);Assert.notNull(authorities, <span class="hljs-string">"Anonymous authorities must be set"</span>);<span class="hljs-keyword">this</span>.key = key;<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">this</span>.authorities = authorities;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AnonymousAuthenticationFilter</span><span class="hljs-params">(String key, Object principal,</span></span><span class="hljs-function"><span class="hljs-params">List&lt;GrantedAuthority&gt; authorities)</span> </span>&#123;Assert.hasLength(key, <span class="hljs-string">"key cannot be null or empty"</span>);Assert.notNull(principal, <span class="hljs-string">"Anonymous authentication principal must be set"</span>);Assert.notNull(authorities, <span class="hljs-string">"Anonymous authorities must be set"</span>);<span class="hljs-keyword">this</span>.key = key;<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">this</span>.authorities = authorities;&#125;</code></pre><p>也就是说不过前面的过滤器验证过没过，如果都没过，在这个过滤器中还是会创建一个Authentication，</p><p>这个Authentication会传递给FilterSecurityInterceptor由它来决定当前的Authentication所包含的信息是否可以访问当前请求的URL</p><hr><p>接下来看一下FilterSecurityInterceptor和ExceptionTranslationFilter的代码，在这之前来看一张图：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568552428831.png" srcset="/img/loading.gif" alt="1568552428831"></p><ul><li>FilterSecurityInterceptor：主入口</li><li>AccessDecisionManager：访问管理者，它是一个接口，拥有1一个抽象实现，3个具体实现，负责管理一组AccessDecisionVoter，AccessDecisionVoter：投票人，在spring Security3之前，AccessDecisionManager是一组AccessDecisionVoter接口的实现， 不同的实现处理不同的逻辑，比如判断当前Authentication里面是否里面包含某种角色，有的投票中判断当前Authentication是否经过身份认证，有各种各样的判断，每种判断逻辑都是投票者的实现，在这个管理者里面维护了一组头投票者，当它收到请求以后，每一个投票者会根据自己的逻辑去投出自己的一票，说这个请求投过还是不过</li><li>AbstractAccessDecisionManager：AccessDecisionManager接口的抽象实现，在它的这个实现里面，它会综合所有投票者的投票结果来给出最终的结果，过还是不过，判断最终的逻辑有3套不同的逻辑，分别在它3个子类里面：<ul><li>AffirmativeBased：只要Voter投过，整个请求就是通过，可以访问</li><li>ConsensusBased：只要有一个Voter投不过，整个请求就拒接吊</li><li>UnanimousBased：根据Voter投通过和不通过的个数，来比较过和不过的个数多，选择多的一方</li></ul></li></ul><p>在spring Security中默认使用的是AffirmativeBased</p><p>SecurityConfig</p><p>需要判断一个请求是否能过，需要2放数据，首先是系统的配置信息，A URL访问需要什么权限，B URL需要什么请求，也就是之前写的BrowserSecurityConfig的代码：</p><pre><code class="hljs java">.authorizeRequests()              .antMatchers(                      <span class="hljs-string">"/session/invalid"</span>,                      browser.getRegistUrl(),                      browser.getLoginUrl(),                      browser.getSignUpUrl(),                      SecurityConstants.DEFAULT_UNAUTHENTICATED_URL,                      SecurityConstants.DEFAULT_VALIDATE_CODE_URL_PREFIX + <span class="hljs-string">"/*"</span>              )              .permitAll()              .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)              .anyRequest()              .authenticated()</code></pre><p>FilterSecurityInterceptor会根据安全配置里面把上面的信息读出来封装成ConfigAttribute一组对象，这组对象每一个ConfigAttribute对应URL需要的权限，</p><p>SecurityContextHolder：</p><p>当前用户所拥有的权限信息，用户有哪些权限，这些信息就是封装在Authentication里面的</p><hr><p>FilterSecurityInterceptor通过SecurityConfig和SecurityContextHolder再加上和FilterSecurityInterceptor封装的当前请求信息传给AccessDecisionManager，AccessDecisionManager把这些信息给投票者，由投票者来投票是过还是不过，然后汇总投票结果过出一个最终结果。</p><hr><p>以上说的一组投票者是spring3以前，在3之后提供了一种新的特性，叫spring表达式，基于上面的特性，spring3新增了一个WebExpressionVoter，这个投票者包办了所有Voter工作，在spring 3以后，在web环境下，所有的投票工作由这一个投票过滤器包办了</p><hr><p>前面图介绍完了，来debug来看一下</p><p>debug位置：</p><ul><li>FilterSecurityInterceptor：90行</li><li>AbstractSecurityInterceptor：235行</li><li>ExceptionTranslationFilter：123行</li></ul><p>访问拒绝流程：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568554446330.png" srcset="/img/loading.gif" alt="1568554446330"></p><p>首先会进入doFilter方法，这里调用了invoke方法</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568554473190.png" srcset="/img/loading.gif" alt="1568554473190"></p><p>这里的invoke会做一个判断，你当前的请求之前是否经过这个过滤器，如果之前这个请求经过这个过滤器，那么这里就就直接往下走，它判断的依据：</p><pre><code class="hljs java">fi.getRequest().getAttribute(FILTER_APPLIED) != <span class="hljs-keyword">null</span></code></pre><p>判断请求的FILTER_APPLIED是不是有值，如果不为空有值，就按之前走过这个过滤器处理，这里我是第一次访问这个应用，所以走的是else</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568554732440.png" srcset="/img/loading.gif" alt="1568554732440"></p><p>首先它会给请求中的FILTER_APPLIED属性设置上，下次又经过这个过滤器就不会走else了，最关键的代码：</p><pre><code class="hljs java">InterceptorStatusToken token = <span class="hljs-keyword">super</span>.beforeInvocation(fi);</code></pre><p>如果在这里出了问题它就抛异常，整个就中断了，如果不抛异常没问题，就会再往下调用过滤器链，。</p><p>下面来看下beforeInvocation这个方法做了什么：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568554968267.png" srcset="/img/loading.gif" alt="1568554968267"></p><pre><code class="hljs java">Collection&lt;ConfigAttribute&gt; attributes = <span class="hljs-keyword">this</span>.obtainSecurityMetadataSource().getAttributes(object);</code></pre><p>这里获取了前面介绍的ConfigAttribute，这里是根据BrowserSecurityConfig配置信息封装的。</p><p>obtainSecurityMetadataSource方法是ConfigAttribute集合的封装逻辑：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568555168543.png" srcset="/img/loading.gif" alt="1568555168543"></p><p>这里对requestMap进行循环，可以看到requestMap的内容就是BrowserSecurityConfig配置的内容，这里会根据当前请求的URL去在这个requestMap中去找所需要的权限，这里我访问的是/user这样的地址，返回内容：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568555438147.png" srcset="/img/loading.gif" alt="1568555438147"></p><p>这里要求用户hasRole(‘ROLE_ADMIN’)返回为true，也就是用户需要是ROLE_ADMIN角色</p><hr><p>往下走到这里：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568555618786.png" srcset="/img/loading.gif" alt="1568555618786"></p><p>这里判断SecurityContext中的Authentication是不是空，之前介绍过，及时前面过滤器都没通过，还是有在最后一个过滤器中设置Authentication，所以不可能是空，这里不会抛出异常</p><p>在往下：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568555956517.png" srcset="/img/loading.gif" alt="1568555956517"></p><pre><code class="hljs java">Authentication authenticated = authenticateIfRequired();</code></pre><p>这里会到Authentication做一些判断然后返回，然后执行：</p><pre><code class="hljs java"><span class="hljs-keyword">this</span>.accessDecisionManager.decide(authenticated, object, attributes);</code></pre><p>这里就是前面介绍的访问管理者了，这里的object就是请求信息，这里会使用AffirmativeBased#decide，它是默认的</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568556156687.png" srcset="/img/loading.gif" alt="1568556156687"></p><p>这个只要有一个投不过，那么请求就不过，首先它会循环所有投票者</p><p>在web环境下就只剩下这一个投票者了，它是一个根据表达式的投票器</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568556239210.png" srcset="/img/loading.gif" alt="1568556239210"></p><pre><code class="hljs java"><span class="hljs-keyword">int</span> result = voter.vote(authentication, object, configAttributes);</code></pre><p>这里会将前面的信息交给投票器，让它去投票，最终结果为“-1”，就是不过意思，因为我当前访问的表达式需要权限：hasRole(‘ROLE_ADMIN’)，而我这里的权限：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568556466007.png" srcset="/img/loading.gif" alt="1568556466007"></p><p>它是一个匿名的，所以最终结果为不过，这里如果有一个不过就会对deny变量进行累加，如果有任何投票器投了不过，就会抛异常</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568556560419.png" srcset="/img/loading.gif" alt="1568556560419"></p><p>这里抛出的异常会在AccessDecisionManager中进行抛出，它会抛给调用它的FilterSecurityInterceptor，那么捕获到这个访问拒绝异常以后，会执行以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">catch</span> (AccessDeniedException accessDeniedException) &#123;publishEvent(<span class="hljs-keyword">new</span> AuthorizationFailureEvent(object, attributes, authenticated,accessDeniedException));<span class="hljs-keyword">throw</span> accessDeniedException;&#125;</code></pre><p>首先在spring容器里发一个事件，然后再继续抛出这个异常，再抛出这个异常会跑到ExceptionTranslationFilter过滤器上</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568557057727.png" srcset="/img/loading.gif" alt="1568557057727"></p><p>先来说下这2段代码：</p><pre><code class="hljs java">RuntimeException ase = (AuthenticationException) throwableAnalyzer.getFirstThrowableOfType(AuthenticationException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;<span class="hljs-keyword">if</span> (ase == <span class="hljs-keyword">null</span>) &#123;ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">causeChain</span>)</span>;&#125;</code></pre><p>首先它会去根据异常来看一下是不是AuthenticationException，前面抛出的是一个AccessDeniedException所以，会返回空，那么就会进到这个if中这里是判断是否是AccessDeniedException异常，这里就有值了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568557191088.png" srcset="/img/loading.gif" alt="1568557191088"></p><p>有值以后，执行handleSpringSecurityException方法来处理异常，</p><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> AccessDeniedException) &#123;Authentication authentication = SecurityContextHolder.getContext().getAuthentication();<span class="hljs-keyword">if</span> (authenticationTrustResolver.isAnonymous(authentication) || authenticationTrustResolver.isRememberMe(authentication)) &#123;logger.debug(<span class="hljs-string">"Access is denied (user is "</span> + (authenticationTrustResolver.isAnonymous(authentication) ? <span class="hljs-string">"anonymous"</span> : <span class="hljs-string">"not fully authenticated"</span>) + <span class="hljs-string">"); redirecting to authentication entry point"</span>,exception);sendStartAuthentication(request,response,chain,<span class="hljs-keyword">new</span> InsufficientAuthenticationException(<span class="hljs-string">"Full authentication is required to access this resource"</span>));&#125;<span class="hljs-keyword">else</span> &#123;logger.debug(<span class="hljs-string">"Access is denied (user is not anonymous); delegating to AccessDeniedHandler"</span>,exception);accessDeniedHandler.handle(request, response,(AccessDeniedException) exception);&#125;&#125;</code></pre><p>这里判断是否是匿名的身份那就是因为没有登录（身份认证）所以访问被拒接了，这里会调用sendStartAuthentication把你发送出去，让你开始i进行身份认证，如果不是以为匿名身份访问被拒绝了，会执行来处理</p><pre><code class="hljs java">accessDeniedHandler.handle(request, response,(AccessDeniedException) exception);</code></pre><p>org.springframework.security.web.access.AccessDeniedHandlerImpl#handle</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568557636405.png" srcset="/img/loading.gif" alt="1568557636405"></p><p>这个处理器会响应403，我们现在是因为被匿名这个身份被拒绝的，所以会进到这里</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendStartAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain,</span></span><span class="hljs-function"><span class="hljs-params">AuthenticationException reason)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<span class="hljs-comment">// SEC-112: Clear the SecurityContextHolder's Authentication, as the</span><span class="hljs-comment">// existing Authentication is no longer considered valid</span>SecurityContextHolder.getContext().setAuthentication(<span class="hljs-keyword">null</span>);requestCache.saveRequest(request, response);logger.debug(<span class="hljs-string">"Calling Authentication entry point."</span>);authenticationEntryPoint.commence(request, response, reason);&#125;</code></pre><p>这里就会把用户发出去进行身份认证，实际上就是调到登录页面上去</p><hr><p>访问通过流程：</p><blockquote><p>….</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 六、RBAC 】 1.Spring Security授权简介</title>
    <link href="/spring-security-6.1.html"/>
    <url>/spring-security-6.1.html</url>
    
    <content type="html"><![CDATA[<h1 id="授权概念"><a href="#授权概念" class="headerlink" title="授权概念"></a>授权概念</h1><p>权限系统通常要解决认证和授权</p><p>认证，即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。<br>前面我们分析的都是认证，即你是谁问题？</p><p>这篇我们来分析你能做什么的问题。</p><h1 id="授权分析"><a href="#授权分析" class="headerlink" title="授权分析"></a>授权分析</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/2019050520550057.png" srcset="/img/loading.gif" alt=""></p><p>权限是某个资源能否杯用户访问，而并不是能否显示的问题。</p><h1 id="权限场景"><a href="#权限场景" class="headerlink" title="权限场景"></a>权限场景</h1><p>通常公司的系统分对外系统 权限场景比较简单，而内部管理系统权限场景比较复杂（业务及需求经常变动）</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/20190505205813292.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/20190505205850305.png" srcset="/img/loading.gif" alt=""></p><h1 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h1><p>权限控制是基于用户-角色-权限这套体系，这个我在后面详细介绍。其实我们前面的浏览器项目已经有权限控制了我们再来看下</p><p>com.b4.mcr.auth.browser.BrowserSecurityConfig#configure</p><pre><code class="hljs java">.antMatchers(                       <span class="hljs-string">"/session/invalid"</span>,                       browser.getRegistUrl(),                       browser.getLoginUrl(),                       browser.getSignUpUrl(),                       SecurityConstants.DEFAULT_UNAUTHENTICATED_URL,                       SecurityConstants.DEFAULT_VALIDATE_CODE_URL_PREFIX + <span class="hljs-string">"/*"</span>               )               .permitAll()               .antMatchers(<span class="hljs-string">"/user/**"</span>).hasRole(<span class="hljs-string">"ADMIN"</span>)</code></pre><p>然后在demo模块中依赖与browser模块</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-browser<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>在登录页面进行登录之后访问：<a href="http://www.pinzhi365.com/user/me" target="_blank" rel="noopener">http://www.pinzhi365.com/user/me</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1568550118535.png" srcset="/img/loading.gif" alt="1568550118535"></p><p>页面会响应403，这里的意思是没有权限，这里是因为在之前写的McrUserDetailsService类中给用户的角色：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SocialUser <span class="hljs-title">buildUser</span><span class="hljs-params">(String username)</span> </span>&#123;        String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialUser(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin,ROLE_USER"</span>));    &#125;</code></pre><p>这里我在BrowserSecurityConfig中要求访问<code>/user/**</code>URL的角色含ADMIN，所以页面403了，在这里修改一下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SocialUser <span class="hljs-title">buildUser</span><span class="hljs-params">(String username)</span> </span>&#123;     String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialUser(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin,ROLE_USER,ROLE_ADMIN"</span>)); &#125;</code></pre><p>这里注意，前面要加上ROLE_，然后再去访问<a href="http://www.pinzhi365.com/user/me这个URL是能正常访问了" target="_blank" rel="noopener">http://www.pinzhi365.com/user/me这个URL是能正常访问了</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 9.基于JWT实现SSO单点登录</title>
    <link href="/spring-security-5.9.html"/>
    <url>/spring-security-5.9.html</url>
    
    <content type="html"><![CDATA[<p>什么是单点登录？请看下面这篇文章</p><blockquote><p><a href="http://www.cnblogs.com/ywlaker/p/6113927.html" target="_blank" rel="noopener">单点登录与简单实现</a></p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567946533501.png" srcset="/img/loading.gif" alt="1567946533501"></p><p>现在有这么一个业务场景：现在有A网站和B网站，用户在登录了A网站，然后用户再访问B网站时候就不用登录了，笔者在这里以阿里的淘宝、天猫网站为例：</p><p>现在我流浪这2个网站，都是未登录状态的</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567949712176.png" srcset="/img/loading.gif" alt="1567949712176"></p><p>在这里我先登录天猫，然后到淘宝上刷新的时候，就已经是登录状态了，你可以理解为这个就是单点登录</p><hr><p>以上面流程图为例，来介绍一下工作流程：</p><ol><li>当请求发给应用A时，如果这个请求需要登录以后才能访问，A会向认证服务器来请求授权，这时候，会将客户端浏览器引导到认证服务器上去授权，</li><li>用户授权之后</li><li>认证服务器返回授权码给应用A</li><li>应用A拿着授权码请求令牌</li><li>认证服务器返回给应用A JWT</li><li>应用A解析JWT的信息做一个登录，这时候用户就在应用A上登录了</li><li>当用户在应用A完成登录以后，他去访问了应用B</li><li>对于应用B来说，用户是一个未授权的状态，它也一样会请求认证服务器给这个用户授权，让用户能去访问应用B，这个时候用户会再一次做授权，但是他不用在登录了，请求这个授权，应用A和应用B是在同一个认证服务上完成的，而这个用户之前这个认证服务器上是一个授权状态，那么通过浏览器跳到应用B的时候，认证服务器是知道当前用户是谁的，那么它只是会要求用户去授权：你可以用在我这已登录的信息去访问应用B，</li><li>后面的流程和1-6是一样的，走一个OAuth流程</li><li>走完OAuth以后认证服务器会给应用B一个JWT，这里的JWT与应用A的JWT是不一样的，这个token字符串是不一样的，但是通过字符串解析出来的信息是一样的，应用B拿到JWT之后，它自己做它的解析，它会解析出一个与应用A解析一样的用户信息出来，接着用户信息去构建它的Authentication，放到SecurityContext里完成它在应用B的授权，最终结果是应用A、B的session里面都有一个JWT解析出来的用户信息，认证服务器给的JWT不一样，但是解析出来的内容是一样的</li><li>…</li><li>使用JWT返回资源服务器</li></ol><hr><p>笔者在这里会重写创建一个子pom模块，在这个pom模块名为mcr-auth-sso,它有3个子模块：</p><ol><li>mcr-auth-sso-server：认证服务器</li><li>mcr–auth-sso-client1：应用A</li><li>mcr–auth-sso-client2：应用B</li></ol><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567947011810.png" srcset="/img/loading.gif" alt="1567947011810"></p><p>mcr-auth-sso-server的pom.xml</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-sso<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>mcr-auth-sso-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>mcr-auth-sso-client1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>mcr-auth-sso-client2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security.oauth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.security<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-security-jwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>mcr-auth-sso-server的启动类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthSsoServerApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(McrAuthSsoServerApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>认证服务器的相关配置</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoAuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        clients.inMemory()                .withClient(<span class="hljs-string">"client1"</span>)                .secret(<span class="hljs-string">"client1"</span>)                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>, <span class="hljs-string">"refresh_token"</span>)                .scopes(<span class="hljs-string">"all"</span>)                .and()                .withClient(<span class="hljs-string">"client2"</span>)                .secret(<span class="hljs-string">"client2"</span>)                .authorizedGrantTypes(<span class="hljs-string">"authorization_code"</span>, <span class="hljs-string">"refresh_token"</span>)                .scopes(<span class="hljs-string">"all"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        endpoints.tokenStore(jwtTokenStore()).accessTokenConverter(jwtAccessTokenConverter());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        security.tokenKeyAccess(<span class="hljs-string">"isAuthenticated()"</span>);        <span class="hljs-comment">//isAuthenticated()是spring security的授权表达式，这个表达式的意思：应用访问/oauth/token的时候，</span>        <span class="hljs-comment">// 需要先经过身份认证，为什么需要访问/oauth/check_token，因为在前面介绍流程的场景中第5步认证服务器发给应用JWT，在生成JWT，在这里由于配置了秘钥去签名，那么用户拿到JWT的时候它要解析里面的东西，它要</span>        <span class="hljs-comment">//验签名，现在应用A就需要知道签名用的秘钥是什么，一会在client端会配置通过什么样的路径，client可以到认证服务器去拿解析JWT的秘钥，</span>        <span class="hljs-comment">// 现在当应用A访问/oauth/check_token的时候,这里就限制了它要经过身份认证才能访问这个地址，</span>        <span class="hljs-comment">//```java  private String tokenKeyAccess = "denyAll()";```这里默认是拒绝所有访问</span>    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">jwtTokenStore</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;        JwtAccessTokenConverter converter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();        converter.setSigningKey(<span class="hljs-string">"mcr"</span>);<span class="hljs-comment">//秘钥</span>        <span class="hljs-keyword">return</span> converter;    &#125;&#125;</code></pre><p>yml</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">9999</span>  <span class="hljs-attr">context-path:</span> <span class="hljs-string">/server</span><span class="hljs-attr">security:</span>  <span class="hljs-attr">user:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span></code></pre><p>mcr-auth-sso-clien1的启动类、rest api</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.client1;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@EnableOAuth</span>2Sso<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthClient1Application</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getUser</span><span class="hljs-params">(Authentication user)</span> </span>&#123;        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(McrAuthClient1Application<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>yml</p><pre><code class="hljs yml"><span class="hljs-attr">security:</span>  <span class="hljs-attr">oauth2:</span>    <span class="hljs-attr">client:</span>      <span class="hljs-attr">clientId:</span> <span class="hljs-string">client1</span>      <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">client1</span>      <span class="hljs-attr">user-authorization-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/authorize</span>      <span class="hljs-attr">access-token-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/token</span>    <span class="hljs-attr">resource:</span>      <span class="hljs-attr">jwt:</span>        <span class="hljs-attr">key-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/token_key</span>      <span class="hljs-attr">user-info-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/user</span>      <span class="hljs-attr">token-info-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/check_token</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <span class="hljs-attr">context-path:</span> <span class="hljs-string">/client1</span></code></pre><p>resources/resources/index.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SSO Client1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>SSO Demo Client1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8060/client2/index.html"</span>&gt;</span>访问Client2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>mcr-auth-sso-client2和mcr-auth-sso-client1的代码是差不多的，这里把不同的地方列出来</p><p>yml</p><pre><code class="hljs yml"><span class="hljs-attr">security:</span>  <span class="hljs-attr">oauth2:</span>    <span class="hljs-attr">client:</span>      <span class="hljs-attr">clientId:</span> <span class="hljs-string">client2</span>      <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">client2</span>      <span class="hljs-attr">user-authorization-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/authorize</span>      <span class="hljs-attr">access-token-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/token</span>    <span class="hljs-attr">resource:</span>      <span class="hljs-attr">jwt:</span>        <span class="hljs-attr">key-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/token_key</span>      <span class="hljs-attr">user-info-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/user</span>      <span class="hljs-attr">token-info-uri:</span> <span class="hljs-string">http://127.0.0.1:9999/server/oauth/check_token</span>      <span class="hljs-attr">preferTokenInfo:</span> <span class="hljs-literal">false</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8060</span>  <span class="hljs-attr">context-path:</span> <span class="hljs-string">/client2</span></code></pre><p>html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>SSO Client1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>SSO Demo Client1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://localhost:8080/client1/index.html"</span>&gt;</span>访问Client2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><hr><p>现在访问client1，会跳转到认证服务器上弹出一个用户密码的表单，登录完成以后会跳转到认证服务器上显示这样的页面</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567953316166.png" srcset="/img/loading.gif" alt="1567953316166"></p><p>这里选择授权按钮，之后就能访问clien1的index页面了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567953377669.png" srcset="/img/loading.gif" alt="1567953377669"></p><p>现在点击这个A链接，也就是要跳转到client2，这个时候会直接到认证服务器中显示这样的页面</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567953427420.png" srcset="/img/loading.gif" alt="1567953427420"></p><p>在这里client2并没有像之前那样要求需要用户输入用户名密码，而是直接跳转到了认证服务器，以上就实现了前面所说的业务场景</p><hr><p>前面演示的流程中，最核心的功能已经实现了：只需要登录一次，同时访问应用A、B，在这个过程中有让笔者不爽的地方：在认证服务器上登录的时候，是一个http basic的弹框让用户去输入用户名密码，这里肯定是需要展示一个漂亮的登录页面，另外就是在第一次访问应用A或B它都会让我做一个授权，我要点一下授权按钮，但是在我自己两个网站上是不需要授权的，你只要登录就是了，下面就来细化这个场景</p><hr><p>表单登录</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http.formLogin()                .and()                .authorizeRequests()                .anyRequest()                .authenticated();    &#125;&#125;</code></pre><hr><p>用数据库里的账号密码做认证</p><p>SecurityConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();&#125;</code></pre><p>UserDetailsService实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SSoUserDetailsServices</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        String password = passwordEncoder.encode(<span class="hljs-string">"123456"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username, password, AuthorityUtils                .commaSeparatedStringToAuthorityList(<span class="hljs-string">"ROLE_USER"</span>));    &#125;&#125;</code></pre><hr><p>取消授权这一步操作</p><blockquote><p>在spring oauth中这一步是不能去掉的，但是可以用一些骚操作去修改，这里需要从源码中找到那个授权页面是在哪里生成出来的，然后改一下这个页面，已进入这个页面自动给它授权提交掉</p></blockquote><p>WhitelabelApprovalEndpoint，这个类就是生成授权页面的类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.oauth2.provider.endpoint;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;<span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Controller for displaying the approval page for the authorization server.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Dave Syer</span><span class="hljs-comment"> */</span><span class="hljs-meta">@FrameworkEndpoint</span><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"authorizationRequest"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitelabelApprovalEndpoint</span> </span>&#123;<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oauth/confirm_access"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">getAccessConfirmation</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;String template = createTemplate(model, request);<span class="hljs-keyword">if</span> (request.getAttribute(<span class="hljs-string">"_csrf"</span>) != <span class="hljs-keyword">null</span>) &#123;model.put(<span class="hljs-string">"_csrf"</span>, request.getAttribute(<span class="hljs-string">"_csrf"</span>));&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> SpelView(template), model);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">createTemplate</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> </span>&#123;String template = TEMPLATE;<span class="hljs-keyword">if</span> (model.containsKey(<span class="hljs-string">"scopes"</span>) || request.getAttribute(<span class="hljs-string">"scopes"</span>) != <span class="hljs-keyword">null</span>) &#123;template = template.replace(<span class="hljs-string">"%scopes%"</span>, createScopes(model, request)).replace(<span class="hljs-string">"%denial%"</span>, <span class="hljs-string">""</span>);&#125;<span class="hljs-keyword">else</span> &#123;template = template.replace(<span class="hljs-string">"%scopes%"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"%denial%"</span>, DENIAL);&#125;<span class="hljs-keyword">if</span> (model.containsKey(<span class="hljs-string">"_csrf"</span>) || request.getAttribute(<span class="hljs-string">"_csrf"</span>) != <span class="hljs-keyword">null</span>) &#123;template = template.replace(<span class="hljs-string">"%csrf%"</span>, CSRF);&#125;<span class="hljs-keyword">else</span> &#123;template = template.replace(<span class="hljs-string">"%csrf%"</span>, <span class="hljs-string">""</span>);&#125;<span class="hljs-keyword">return</span> template;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> CharSequence <span class="hljs-title">createScopes</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> </span>&#123;StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"&lt;ul&gt;"</span>);<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)Map&lt;String, String&gt; scopes = (Map&lt;String, String&gt;) (model.containsKey(<span class="hljs-string">"scopes"</span>) ? model.get(<span class="hljs-string">"scopes"</span>) : request.getAttribute(<span class="hljs-string">"scopes"</span>));<span class="hljs-keyword">for</span> (String scope : scopes.keySet()) &#123;String approved = <span class="hljs-string">"true"</span>.equals(scopes.get(scope)) ? <span class="hljs-string">" checked"</span> : <span class="hljs-string">""</span>;String denied = !<span class="hljs-string">"true"</span>.equals(scopes.get(scope)) ? <span class="hljs-string">" checked"</span> : <span class="hljs-string">""</span>;String value = SCOPE.replace(<span class="hljs-string">"%scope%"</span>, scope).replace(<span class="hljs-string">"%key%"</span>, scope).replace(<span class="hljs-string">"%approved%"</span>, approved).replace(<span class="hljs-string">"%denied%"</span>, denied);builder.append(value);&#125;builder.append(<span class="hljs-string">"&lt;/ul&gt;"</span>);<span class="hljs-keyword">return</span> builder.toString();&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String CSRF = <span class="hljs-string">"&lt;input type='hidden' name='$&#123;_csrf.parameterName&#125;' value='$&#123;_csrf.token&#125;' /&gt;"</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String DENIAL = <span class="hljs-string">"&lt;form id='denialForm' name='denialForm' action='$&#123;path&#125;/oauth/authorize' method='post'&gt;&lt;input name='user_oauth_approval' value='false' type='hidden'/&gt;%csrf%&lt;label&gt;&lt;input name='deny' value='Deny' type='submit'/&gt;&lt;/label&gt;&lt;/form&gt;"</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String TEMPLATE = <span class="hljs-string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Approval&lt;/h1&gt;"</span>+ <span class="hljs-string">"&lt;p&gt;Do you authorize '$&#123;authorizationRequest.clientId&#125;' to access your protected resources?&lt;/p&gt;"</span>+ <span class="hljs-string">"&lt;form id='confirmationForm' name='confirmationForm' action='$&#123;path&#125;/oauth/authorize' method='post'&gt;&lt;input name='user_oauth_approval' value='true' type='hidden'/&gt;%csrf%%scopes%&lt;label&gt;&lt;input name='authorize' value='Authorize' type='submit'/&gt;&lt;/label&gt;&lt;/form&gt;"</span>+ <span class="hljs-string">"%denial%&lt;/body&gt;&lt;/html&gt;"</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String SCOPE = <span class="hljs-string">"&lt;li&gt;&lt;div class='form-group'&gt;%scope%: &lt;input type='radio' name='%key%'"</span>+ <span class="hljs-string">" value='true'%approved%&gt;Approve&lt;/input&gt; &lt;input type='radio' name='%key%' value='false'%denied%&gt;Deny&lt;/input&gt;&lt;/div&gt;&lt;/li&gt;"</span>;&#125;</code></pre><p>这个类注解了一个@FrameworkEndpoint，这个和@RestController相似，可以去在方法上写@RequestMapping，我们要做的事情就是原样写一个一模一样的类，不过会替换掉@FrameworkEndpoint改为@RestController，用@RestController注解的类，如果跟这个@RestController声明了一个一模一样的@RequestMapping，spring在处理的时候会优先使用@RestController，这样就能把这个授权页面的代码进行修改成我们预期的效果了，不过它这里的getAccessConfirmation方法使用了SpelView类，这个类是一个私有的，所以这个类也要复制在我们这里</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2013-2014 the original author or authors.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with</span><span class="hljs-comment"> * the License. You may obtain a copy of the License at</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on</span><span class="hljs-comment"> * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the</span><span class="hljs-comment"> * specific language governing permissions and limitations under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> org.springframework.context.expression.MapAccessor;<span class="hljs-keyword">import</span> org.springframework.expression.Expression;<span class="hljs-keyword">import</span> org.springframework.expression.spel.standard.SpelExpressionParser;<span class="hljs-keyword">import</span> org.springframework.expression.spel.support.StandardEvaluationContext;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.common.util.RandomValueStringGenerator;<span class="hljs-keyword">import</span> org.springframework.util.PropertyPlaceholderHelper;<span class="hljs-keyword">import</span> org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;<span class="hljs-keyword">import</span> org.springframework.web.servlet.View;<span class="hljs-keyword">import</span> org.springframework.web.servlet.support.ServletUriComponentsBuilder;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Simple String template renderer.</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoSpelView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String template;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String prefix;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SpelExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StandardEvaluationContext context = <span class="hljs-keyword">new</span> StandardEvaluationContext();<span class="hljs-keyword">private</span> PlaceholderResolver resolver;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SsoSpelView</span><span class="hljs-params">(String template)</span> </span>&#123;<span class="hljs-keyword">this</span>.template = template;<span class="hljs-keyword">this</span>.prefix = <span class="hljs-keyword">new</span> RandomValueStringGenerator().generate() + <span class="hljs-string">"&#123;"</span>;<span class="hljs-keyword">this</span>.context.addPropertyAccessor(<span class="hljs-keyword">new</span> MapAccessor());<span class="hljs-keyword">this</span>.resolver = <span class="hljs-keyword">new</span> PlaceholderResolver() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">resolvePlaceholder</span><span class="hljs-params">(String name)</span> </span>&#123;Expression expression = parser.parseExpression(name);Object value = expression.getValue(context);<span class="hljs-keyword">return</span> value == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : value.toString();&#125;&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"text/html"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;(model);String path = ServletUriComponentsBuilder.fromContextPath(request).build().getPath();map.put(<span class="hljs-string">"path"</span>, (Object) path==<span class="hljs-keyword">null</span> ? <span class="hljs-string">""</span> : path);context.setRootObject(map);String maskedTemplate = template.replace(<span class="hljs-string">"$&#123;"</span>, prefix);PropertyPlaceholderHelper helper = <span class="hljs-keyword">new</span> PropertyPlaceholderHelper(prefix, <span class="hljs-string">"&#125;"</span>);String result = helper.replacePlaceholders(maskedTemplate, resolver);result = result.replace(prefix, <span class="hljs-string">"$&#123;"</span>);response.setContentType(getContentType());response.getWriter().append(result);&#125;&#125;</code></pre><p>WhitelabelApprovalEndpoint</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.sso.server;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.SessionAttributes;<span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@SessionAttributes</span>(<span class="hljs-string">"authorizationRequest"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SsoWhitelabelApprovalEndpoint</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/oauth/confirm_access"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">getAccessConfirmation</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String template = createTemplate(model, request);        <span class="hljs-keyword">if</span> (request.getAttribute(<span class="hljs-string">"_csrf"</span>) != <span class="hljs-keyword">null</span>) &#123;            model.put(<span class="hljs-string">"_csrf"</span>, request.getAttribute(<span class="hljs-string">"_csrf"</span>));        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> SsoSpelView(template), model);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">createTemplate</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> </span>&#123;        String template = TEMPLATE;        <span class="hljs-keyword">if</span> (model.containsKey(<span class="hljs-string">"scopes"</span>) || request.getAttribute(<span class="hljs-string">"scopes"</span>) != <span class="hljs-keyword">null</span>) &#123;            template = template.replace(<span class="hljs-string">"%scopes%"</span>, createScopes(model, request)).replace(<span class="hljs-string">"%denial%"</span>, <span class="hljs-string">""</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            template = template.replace(<span class="hljs-string">"%scopes%"</span>, <span class="hljs-string">""</span>).replace(<span class="hljs-string">"%denial%"</span>, DENIAL);        &#125;        <span class="hljs-keyword">if</span> (model.containsKey(<span class="hljs-string">"_csrf"</span>) || request.getAttribute(<span class="hljs-string">"_csrf"</span>) != <span class="hljs-keyword">null</span>) &#123;            template = template.replace(<span class="hljs-string">"%csrf%"</span>, CSRF);        &#125; <span class="hljs-keyword">else</span> &#123;            template = template.replace(<span class="hljs-string">"%csrf%"</span>, <span class="hljs-string">""</span>);        &#125;        <span class="hljs-keyword">return</span> template;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> CharSequence <span class="hljs-title">createScopes</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request)</span> </span>&#123;        StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"&lt;ul&gt;"</span>);        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        Map&lt;String, String&gt; scopes = (Map&lt;String, String&gt;) (model.containsKey(<span class="hljs-string">"scopes"</span>) ? model.get(<span class="hljs-string">"scopes"</span>) : request                .getAttribute(<span class="hljs-string">"scopes"</span>));        <span class="hljs-keyword">for</span> (String scope : scopes.keySet()) &#123;            String approved = <span class="hljs-string">"true"</span>.equals(scopes.get(scope)) ? <span class="hljs-string">" checked"</span> : <span class="hljs-string">""</span>;            String denied = !<span class="hljs-string">"true"</span>.equals(scopes.get(scope)) ? <span class="hljs-string">" checked"</span> : <span class="hljs-string">""</span>;            String value = SCOPE.replace(<span class="hljs-string">"%scope%"</span>, scope).replace(<span class="hljs-string">"%key%"</span>, scope).replace(<span class="hljs-string">"%approved%"</span>, approved)                    .replace(<span class="hljs-string">"%denied%"</span>, denied);            builder.append(value);        &#125;        builder.append(<span class="hljs-string">"&lt;/ul&gt;"</span>);        <span class="hljs-keyword">return</span> builder.toString();    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String CSRF = <span class="hljs-string">"&lt;input type='hidden' name='$&#123;_csrf.parameterName&#125;' value='$&#123;_csrf.token&#125;' /&gt;"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String DENIAL = <span class="hljs-string">"&lt;form id='denialForm' name='denialForm' action='$&#123;path&#125;/oauth/authorize' method='post'&gt;&lt;input name='user_oauth_approval' value='false' type='hidden'/&gt;%csrf%&lt;label&gt;&lt;input name='deny' value='Deny' type='submit'/&gt;&lt;/label&gt;&lt;/form&gt;"</span>;      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String TEMPLATE = <span class="hljs-string">"&lt;html&gt;&lt;body&gt;&lt;div style='display:none;'&gt;&lt;h1&gt;OAuth Approval&lt;/h1&gt;"</span>            + <span class="hljs-string">"&lt;p&gt;Do you authorize '$&#123;authorizationRequest.clientId&#125;' to access your protected resources?&lt;/p&gt;"</span>            + <span class="hljs-string">"&lt;form id='confirmationForm' name='confirmationForm' action='$&#123;path&#125;/oauth/authorize' method='post'&gt;&lt;input name='user_oauth_approval' value='true' type='hidden'/&gt;%csrf%%scopes%&lt;label&gt;&lt;input name='authorize' value='Authorize' type='submit'/&gt;&lt;/label&gt;&lt;/form&gt;"</span>            + <span class="hljs-string">"%denial%&lt;/div&gt;&lt;script&gt;document.getElementById('confirmationForm').submit()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String SCOPE = <span class="hljs-string">"&lt;li&gt;&lt;div class='form-group'&gt;%scope%: &lt;input type='radio' name='%key%'"</span>            + <span class="hljs-string">" value='true'%approved%&gt;Approve&lt;/input&gt; &lt;input type='radio' name='%key%' value='false'%denied%&gt;Deny&lt;/input&gt;&lt;/div&gt;&lt;/li&gt;"</span>;&#125;</code></pre><p>现在就来实现一下业务需求：</p><p>WhitelabelApprovalEndpoint</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String TEMPLATE = <span class="hljs-string">"&lt;html&gt;&lt;body&gt;&lt;div style='display:none;'&gt;&lt;h1&gt;OAuth Approval&lt;/h1&gt;"</span>          + <span class="hljs-string">"&lt;p&gt;Do you authorize '$&#123;authorizationRequest.clientId&#125;' to access your protected resources?&lt;/p&gt;"</span>          + <span class="hljs-string">"&lt;form id='confirmationForm' name='confirmationForm' action='$&#123;path&#125;/oauth/authorize' method='post'&gt;&lt;input name='user_oauth_approval' value='true' type='hidden'/&gt;%csrf%%scopes%&lt;label&gt;&lt;input name='authorize' value='Authorize' type='submit'/&gt;&lt;/label&gt;&lt;/form&gt;"</span>          + <span class="hljs-string">"%denial%&lt;/div&gt;&lt;script&gt;document.getElementById('confirmationForm').submit()&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</code></pre><p>这里把这个页面的内容给隐藏来，然后直接用js给它自动提交就OK了</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 8.令牌配置</title>
    <link href="/spring-security-5.8.html"/>
    <url>/spring-security-5.8.html</url>
    
    <content type="html"><![CDATA[<p>前面为止，将自定义的3重认证方式都已经嫁接到认证服务器上了，通过自定义的认证方式我们可以出去发OAuth令牌，现在这个token它现在和生成和存储都是spring默认的机制来做的，但是这个默认的机制并不符合我们的需求，在这里笔者会带着大家来如何来定制token，定制它的生成和存储</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567865190288.png" srcset="/img/loading.gif" alt="1567865190288"></p><p>现在要做的事是token的处理，token的处理是在认证服务器去完成的，所以这里要做的事情</p><h1 id="基本的Token参数配置"><a href="#基本的Token参数配置" class="headerlink" title="基本的Token参数配置"></a>基本的Token参数配置</h1><p>（1）修改McrAuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthorizationServerConfig</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;    &#125;</code></pre><p>这里的AuthorizationServerConfigurerAdapter有3个configure方法，分别表示安全、第三方客户端的配置、端点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567865473251.png" srcset="/img/loading.gif" alt="1567865473251"></p><p> McrAuthorizationServerConfig：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthorizationServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizationServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationManager authenticationManager;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对TokenEndpoint的属性和增强功能。</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        endpoints.authenticationManager(authenticationManager)                .userDetailsService(userDetailsService)        ;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 跟客户端相关的配置，这里会覆盖掉在yml中的：</span><span class="hljs-comment">     * security.oauth2.client.xxx的配置</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        clients                <span class="hljs-comment">/*mcr*/</span>                .inMemory()                .withClient(<span class="hljs-string">"mcr"</span>)                .secret(<span class="hljs-string">"mcr"</span>)                .accessTokenValiditySeconds(<span class="hljs-number">7200</span>)                <span class="hljs-comment">//当前withClient指定的“mcr”这个应用所能支持的授权模式是哪些</span>                .authorizedGrantTypes(<span class="hljs-string">"refresh_token"</span>, <span class="hljs-string">"password"</span>)                <span class="hljs-comment">//如果这里写了，客户端在发请求的时候就可以不带scope参数，它不带scope参数以后，就是使用这里配置的，如果请求带了scope，一定要是在配置的scope之内，如果不在就会保存</span>                .scopes(<span class="hljs-string">"all"</span>, <span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>)        ;    &#125;&#125;</code></pre><p>测试一下，这里以密码模式为例：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567866797638.png" srcset="/img/loading.gif" alt="1567866797638"></p><p>这里不传递scope，就使用了我们自己配的scoope，过期时间也是我们自己配的，没有问题</p><p>使用简化模式登录：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567866911929.png" srcset="/img/loading.gif" alt="1567866911929"></p><p>这里由于配置中不包含这个模式，所以就会出现这样的信息</p><hr><p>支持多个client端</p><p>McrAuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       clients               <span class="hljs-comment">/*mcr*/</span>               .inMemory()               .withClient(<span class="hljs-string">"mcr"</span>)               .secret(<span class="hljs-string">"mcr"</span>)               .accessTokenValiditySeconds(<span class="hljs-number">7200</span>)               .authorizedGrantTypes(<span class="hljs-string">"refresh_token"</span>, <span class="hljs-string">"password"</span>)               .scopes(<span class="hljs-string">"all"</span>, <span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>)               .and()               <span class="hljs-comment">/*xxx*/</span>               .inMemory()               .withClient(<span class="hljs-string">"mcr"</span>)               .secret(<span class="hljs-string">"mcr"</span>)               .accessTokenValiditySeconds(<span class="hljs-number">7200</span>)               .authorizedGrantTypes(<span class="hljs-string">"refresh_token"</span>, <span class="hljs-string">"password"</span>)               .scopes(<span class="hljs-string">"all"</span>, <span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>)       ;   &#125;</code></pre><p>这里我们的目标是做一个可重用的模块，上面这样写是不能让使用者进行修改的，这里改为可以让使用者进行配置</p><p>首先定义一个OAuth2ClientProperties类，将上面这些ClientDetailsServiceConfigurer类的方法，做为这个类的参数</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-comment">/**</span><span class="hljs-comment"> * OAuth2客户端配置</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2ClientProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> String clientId;    <span class="hljs-keyword">private</span> String clientSecret;    <span class="hljs-keyword">private</span> String[] authorizedGrantTypes = &#123;&#125;;<span class="hljs-comment">//授权类型</span>    <span class="hljs-keyword">private</span> String[] redirectUris = &#123;&#125;; <span class="hljs-comment">// 信任的回调域</span>    <span class="hljs-keyword">private</span> String[] scopes = &#123;&#125;;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> accessTokenValiditySeconds; <span class="hljs-comment">// token有效期 默认单位秒</span>&#125;</code></pre><p>由于可以配置多个，这里的OAuth2Properties类中有一个OAuth2ClientProperties数组 </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-comment">/**</span><span class="hljs-comment"> * oauth2配置</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OAuth2Properties</span> </span>&#123;    <span class="hljs-keyword">private</span> OAuth2ClientProperties[] clients = &#123;&#125;;&#125;</code></pre><p>SecurityProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> OAuth2Properties oAuth2=<span class="hljs-keyword">new</span> OAuth2Properties();</code></pre><p>yml</p><pre><code class="hljs yml"><span class="hljs-comment">#security:</span><span class="hljs-comment">#  oauth2:</span><span class="hljs-comment">#    client:</span><span class="hljs-comment">#      client-id: mcr</span><span class="hljs-comment">#      client-secret: mcr</span><span class="hljs-attr">mcr:</span>  <span class="hljs-attr">b4:</span>    <span class="hljs-attr">security:</span>      <span class="hljs-attr">oAuth2:</span>        <span class="hljs-attr">clients:</span>          <span class="hljs-bullet">-</span> <span class="hljs-attr">clientId:</span> <span class="hljs-string">mcr</span>            <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">mcr</span>            <span class="hljs-attr">authorizedGrantTypes:</span> <span class="hljs-string">["refresh_token",</span> <span class="hljs-string">"password"</span><span class="hljs-string">]</span>            <span class="hljs-attr">scopes:</span> <span class="hljs-string">["all",</span> <span class="hljs-string">"read"</span><span class="hljs-string">]</span>            <span class="hljs-attr">accessTokenValiditySeconds:</span> <span class="hljs-number">7200</span>          <span class="hljs-bullet">-</span> <span class="hljs-attr">clientId:</span> <span class="hljs-string">test</span>            <span class="hljs-attr">clientSecret:</span> <span class="hljs-string">test</span>            <span class="hljs-attr">authorizedGrantTypes:</span> <span class="hljs-string">["refresh_token",</span> <span class="hljs-string">"password"</span><span class="hljs-string">]</span>            <span class="hljs-attr">scopes:</span> <span class="hljs-string">["all",</span> <span class="hljs-string">"read"</span><span class="hljs-string">]</span></code></pre><p>McrAuthorizationServerConfig#configure</p><pre><code class="hljs java">    <span class="hljs-keyword">private</span> SecurityProperties security; <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        OAuth2Properties oAuth2 = securityProperties.getOAuth2();        InMemoryClientDetailsServiceBuilder builder = clients.inMemory();        OAuth2ClientProperties[] oAuth2Clients = oAuth2.getClients();        <span class="hljs-keyword">if</span> (ArrayUtils.isNotEmpty(oAuth2.getClients())) &#123;            <span class="hljs-keyword">for</span> (OAuth2ClientProperties item : oAuth2Clients) &#123;                builder                        .withClient(item.getClientId())                        .secret(item.getClientSecret())                        .accessTokenValiditySeconds(item.getAccessTokenValiditySeconds())                        <span class="hljs-comment">//当前withClient指定的“mcr”这个应用所能支持的授权模式是哪些</span>                        .authorizedGrantTypes(item.getAuthorizedGrantTypes())                        <span class="hljs-comment">//如果这里写了，客户端在发请求的时候就可以不带scope参数，它不带scope参数以后，就是使用这里配置的，如果请求带了scope，一定要是在配置的scope之内，如果不在就会保存</span>                        .scopes(item.getScopes());                clients.setBuilder(builder);            &#125;        &#125;    &#125;</code></pre><p>使用mcr登录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567869976917.png" srcset="/img/loading.gif" alt="1567869976917"></p><p>使用test登录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567869997849.png" srcset="/img/loading.gif" alt="1567869997849"></p><p>这里由于我没给test用户配置过期时间，所以0在这里表示永不过期，在实际开发中一定要给那个过期属性配默认值</p><hr><p>控制令牌存储</p><p>现在令牌是存储在内存中的，一档服务重启，内存中就没有数据了，这里将存储改为redis，之前介绍过TokenStore是来做令牌存储的</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567870398556.png" srcset="/img/loading.gif" alt="1567870398556"></p><p>TokenStore提供了几种实现类，这里使用RedisTokenSotre</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.provider.token.TokenStore;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.provider.token.store.redis.RedisTokenStore;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-comment">/**</span><span class="hljs-comment"> * redis存储token</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenStoreConfig</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisConnectionFactory redisConnectionFactory;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">redisTokenStore</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory);    &#125;&#125;</code></pre><p>McrAuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> TokenStore tokenStore;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对TokenEndpoint的属性和增强功能。</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       endpoints.authenticationManager(authenticationManager)               .userDetailsService(userDetailsService)               .tokenStore(tokenStore)       ;   &#125;</code></pre><h1 id="使用JWT替换默认令牌"><a href="#使用JWT替换默认令牌" class="headerlink" title="使用JWT替换默认令牌"></a>使用JWT替换默认令牌</h1><p>OAuth2Properties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> String jwtSignKey = <span class="hljs-string">"mcr"</span>;</code></pre><p>TokenStoreConfig</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-comment">/**</span><span class="hljs-comment"> * redis存储token</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenStoreConfig</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisConnectionFactory redisConnectionFactory;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"mcr.b4.security.oAuth2"</span>, name = <span class="hljs-string">"storeType"</span>, havingValue = <span class="hljs-string">"redis"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">redisTokenStore</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedisTokenStore(redisConnectionFactory);    &#125;    <span class="hljs-meta">@Configuration</span>    <span class="hljs-meta">@AllArgsConstructor</span>    <span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"mcr.b4.security.oAuth2.storeType"</span>, name = <span class="hljs-string">"storeType"</span>, havingValue = <span class="hljs-string">"jwt"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JwtTokenConfig</span> </span>&#123;        <span class="hljs-keyword">private</span> SecurityProperties securityProperties;        <span class="hljs-meta">@Bean</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> TokenStore <span class="hljs-title">jwtTokenStore</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JwtTokenStore(jwtAccessTokenConverter());        &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * token生成处理</span><span class="hljs-comment">         */</span>        <span class="hljs-meta">@Bean</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> JwtAccessTokenConverter <span class="hljs-title">jwtAccessTokenConverter</span><span class="hljs-params">()</span> </span>&#123;            OAuth2Properties oAuth2 = securityProperties.getOAuth2();            JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword">new</span> JwtAccessTokenConverter();            jwtAccessTokenConverter.setSigningKey(oAuth2.getJwtSignKey());            <span class="hljs-keyword">return</span> jwtAccessTokenConverter;        &#125;    &#125;&#125;</code></pre><p>这里来介绍一下ConditionalOnProperty注解</p><pre><code class="hljs java"><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"mcr.b4.security.oAuth2.storeType"</span>, name = <span class="hljs-string">"storeType"</span>, havingValue = <span class="hljs-string">"jwt"</span>, matchIfMissing = <span class="hljs-keyword">true</span>)</code></pre><p>这里指的是yml、properties配置文件中配置了”mcr.b4.security.oAuth2.storeType的值为jwt，那么这个类的配置就会生效，这里的matchIfMissing属性为true表示如果yml没配置，也会生效</p><hr><p>McrAuthorizationServerConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)  <span class="hljs-keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 对TokenEndpoint的属性和增强功能。</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      endpoints.authenticationManager(authenticationManager)              .userDetailsService(userDetailsService)              .tokenStore(tokenStore)      ;      <span class="hljs-keyword">if</span> (jwtAccessTokenConverter != <span class="hljs-keyword">null</span>) &#123;          endpoints.accessTokenConverter(jwtAccessTokenConverter);      &#125;  &#125;</code></pre><p>登录响应的数据成这个样子：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJyb290IiwiYXV0aG9yaXRpZXMiOlsiYWRtaW4iLCJST0xFX1VTRVIiXSwianRpIjoiNTVlNDVjNDUtZWM2ZC00NmMyLWI3NzgtZjY3MmYyYTAwNjFjIiwiY2xpZW50X2lkIjoidGVzdCIsInNjb3BlIjpbImFsbCJdfQ.oD1kF5KeQSKydVgZ6kAAwF0RMpOvXn_ttRQtjaZbEk8"</span>,<span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,<span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJyb290Iiwic2NvcGUiOlsiYWxsIl0sImF0aSI6IjU1ZTQ1YzQ1LWVjNmQtNDZjMi1iNzc4LWY2NzJmMmEwMDYxYyIsImV4cCI6MTU3MDUyMjQzNywiYXV0aG9yaXRpZXMiOlsiYWRtaW4iLCJST0xFX1VTRVIiXSwianRpIjoiNmYxOWUwYTYtNTRmMi00ZDQ0LWEzMDYtODFkMWM1NDQ2MGNlIiwiY2xpZW50X2lkIjoidGVzdCJ9.MiapW2WqZGpntAraHeO2mJwt99de2xJhpLpA15MoIX0"</span>,<span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span>,<span class="hljs-attr">"jti"</span>: <span class="hljs-string">"55e45c45-ec6d-46c2-b778-f672f2a0061c"</span>&#125;</code></pre><p>读者可以拿着access_token去在线解析jwt的网站： <a href="http://jwt.calebb.net/中查看内容：" target="_blank" rel="noopener">http://jwt.calebb.net/中查看内容：</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567930569350.png" srcset="/img/loading.gif" alt="1567930569350"></p><p>访问<a href="http://localhost:80/user/me/v3响应内容是空的，原因是这里使用了@AuthenticationPrincipal注解，现在的Principal不是UserDetails，而是一个字符串，所以在这里拿不到" target="_blank" rel="noopener">http://localhost:80/user/me/v3响应内容是空的，原因是这里使用了@AuthenticationPrincipal注解，现在的Principal不是UserDetails，而是一个字符串，所以在这里拿不到</a></p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me/v3"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails authentication)</span> </span>&#123;    <span class="hljs-keyword">return</span> authentication;&#125;</code></pre><p>需要改为这样</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me/v3"</span>) <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;     <span class="hljs-keyword">return</span> authentication; &#125;</code></pre><p>响应内容：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"authorities"</span>: [        &#123;            <span class="hljs-attr">"authority"</span>: <span class="hljs-string">"admin"</span>        &#125;,        &#123;            <span class="hljs-attr">"authority"</span>: <span class="hljs-string">"ROLE_USER"</span>        &#125;    ],    <span class="hljs-attr">"details"</span>: &#123;        <span class="hljs-attr">"remoteAddress"</span>: <span class="hljs-string">"0:0:0:0:0:0:0:1"</span>,        <span class="hljs-attr">"sessionId"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"tokenValue"</span>: <span class="hljs-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJyb290IiwiYXV0aG9yaXRpZXMiOlsiYWRtaW4iLCJST0xFX1VTRVIiXSwianRpIjoiZWJhYTRkMDEtNDgwMy00ZjkyLWJhZGQtMWFjNTZhMjdmNzE0IiwiY2xpZW50X2lkIjoidGVzdCIsInNjb3BlIjpbImFsbCJdfQ.3mCvI7PYBsbRk3qirgTg-NaipfV3JyZljiiHc0fXk9w"</span>,        <span class="hljs-attr">"tokenType"</span>: <span class="hljs-string">"bearer"</span>,        <span class="hljs-attr">"decodedDetails"</span>: <span class="hljs-literal">null</span>    &#125;,    <span class="hljs-attr">"authenticated"</span>: <span class="hljs-literal">true</span>,    <span class="hljs-attr">"userAuthentication"</span>: &#123;        <span class="hljs-attr">"authorities"</span>: [            &#123;                <span class="hljs-attr">"authority"</span>: <span class="hljs-string">"admin"</span>            &#125;,            &#123;                <span class="hljs-attr">"authority"</span>: <span class="hljs-string">"ROLE_USER"</span>            &#125;        ],        <span class="hljs-attr">"details"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"authenticated"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"principal"</span>: <span class="hljs-string">"root"</span>,        <span class="hljs-attr">"credentials"</span>: <span class="hljs-string">"N/A"</span>,        <span class="hljs-attr">"name"</span>: <span class="hljs-string">"root"</span>    &#125;,    <span class="hljs-attr">"principal"</span>: <span class="hljs-string">"root"</span>,    <span class="hljs-attr">"oauth2Request"</span>: &#123;        <span class="hljs-attr">"clientId"</span>: <span class="hljs-string">"test"</span>,        <span class="hljs-attr">"scope"</span>: [            <span class="hljs-string">"all"</span>        ],        <span class="hljs-attr">"requestParameters"</span>: &#123;            <span class="hljs-attr">"client_id"</span>: <span class="hljs-string">"test"</span>        &#125;,        <span class="hljs-attr">"resourceIds"</span>: [        ],        <span class="hljs-attr">"authorities"</span>: [        ],        <span class="hljs-attr">"approved"</span>: <span class="hljs-literal">true</span>,        <span class="hljs-attr">"refresh"</span>: <span class="hljs-literal">false</span>,        <span class="hljs-attr">"redirectUri"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"responseTypes"</span>: [        ],        <span class="hljs-attr">"extensions"</span>: &#123;        &#125;,        <span class="hljs-attr">"refreshTokenRequest"</span>: <span class="hljs-literal">null</span>,        <span class="hljs-attr">"grantType"</span>: <span class="hljs-literal">null</span>    &#125;,    <span class="hljs-attr">"credentials"</span>: <span class="hljs-string">""</span>,    <span class="hljs-attr">"clientOnly"</span>: <span class="hljs-literal">false</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"root"</span>&#125;</code></pre><p>这里的信息，它不是按照jwt来生成的，而这里的信息是按照spring security的Authentication来生成，如何自定义jwt的信息？比如我想在这里的json中加一个字段该怎么加？这里来实现下这个功能</p><p>分析源码可知</p><p>DefaultTokenServices#createAccessToken</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567931505416.png" srcset="/img/loading.gif" alt="1567931505416"></p><p>这里的token是通过UUID生成的，而它这里的生成方法是私有的，所以无法通过实现、继承方式来重写生成逻辑，不过这里的最下方调用了TokenEnhancer这对象的enhance方法，这个方法用来增强的，之前有提到过，这里可以实现TokenEnhancer接口的enhance方法来对生成的token加字段进去</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.jwt;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自定义token增强器</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrJwtTokenEnhancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TokenEnhancer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2AccessToken <span class="hljs-title">enhance</span><span class="hljs-params">(OAuth2AccessToken accessToken, OAuth2Authentication authentication)</span> </span>&#123;        Map&lt;String, Object&gt; info = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-comment">// 需要增加的信息</span>        <span class="hljs-comment">// 所以如果是需要动态的话，只能在该方法中去调用业务方法添加动态参数信息</span>        info.put(<span class="hljs-string">"company"</span>, <span class="hljs-string">"mcr"</span>);        <span class="hljs-comment">// 设置附加信息</span>        ((DefaultOAuth2AccessToken) accessToken).setAdditionalInformation(info);        <span class="hljs-keyword">return</span> accessToken;    &#125;&#125;</code></pre><p>TokenStoreConfig#JwtTokenConfig</p><pre><code class="hljs java">  <span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(TokenEnhancer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">TokenEnhancer</span> <span class="hljs-title">jwtTokenEnhancer</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrJwtTokenEnhancer();    &#125;</code></pre><p>McrAuthorizationServerConfig</p><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)   <span class="hljs-keyword">private</span> JwtAccessTokenConverter jwtAccessTokenConverter;   <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)   <span class="hljs-keyword">private</span> TokenEnhancer jwtTokenEnhancer;<span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       endpoints.authenticationManager(authenticationManager)               .userDetailsService(userDetailsService)               .tokenStore(tokenStore)       ;       <span class="hljs-keyword">if</span> (jwtAccessTokenConverter != <span class="hljs-keyword">null</span> &amp;&amp; jwtTokenEnhancer != <span class="hljs-keyword">null</span>) &#123;           TokenEnhancerChain enhancerChain = <span class="hljs-keyword">new</span> TokenEnhancerChain();           List&lt;TokenEnhancer&gt; enhancers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();           enhancers.add(jwtTokenEnhancer);           enhancers.add(jwtAccessTokenConverter);           enhancerChain.setTokenEnhancers(enhancers);           endpoints                   .tokenEnhancer(enhancerChain)                   .accessTokenConverter(jwtAccessTokenConverter);       &#125;   &#125;</code></pre><p>上面代码中使用了TokenEnhancerChain这么一个类，这个类的作用是将增强器连接起来，因为前面通过jwt转换器转换，而在这里又使用了增强器，所以需要用它将2个类相连起来，形成一个链</p><p>现在重新登录，拿到token在到那个网站上去看：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567932671671.png" srcset="/img/loading.gif" alt="1567932671671"></p><p>不过在我自己的<a href="http://localhost:80/user/me/v3" target="_blank" rel="noopener">http://localhost:80/user/me/v3</a> rest api是看不到这个字段的，现在就来实现一下这个功能，首先在demo模块加入一个依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>UserController</p><pre><code class="hljs java">      <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> SecurityProperties securityProperties;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me/v4"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentAuthentication2</span><span class="hljs-params">(Authentication authentication, HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> UnsupportedEncodingException </span>&#123;        String authorization = request.getHeader(<span class="hljs-string">"Authorization"</span>);        String token = StringUtils.substringAfter(authorization, <span class="hljs-string">"bearer "</span>);        String jwtSigningKey = securityProperties.getOAuth2().getJwtSignKey();        <span class="hljs-comment">// 生成的时候使用的是 org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter</span>        <span class="hljs-comment">// 源码里面把signingkey变成utf8了</span>        <span class="hljs-comment">// JwtAccessTokenConverter类，解析出来是一个map</span>        <span class="hljs-comment">// 所以这个自带的JwtAccessTokenConverter对象也是可以直接用来解析的</span>        <span class="hljs-keyword">byte</span>[] bytes = jwtSigningKey.getBytes(StandardCharsets.UTF_8);        Claims body = Jwts.parser().setSigningKey(bytes).parseClaimsJws(token).getBody();        String company = (String) body.get(<span class="hljs-string">"company"</span>);        log.info(<span class="hljs-string">"公司名称:&#123;&#125;"</span>, company);        <span class="hljs-keyword">return</span> body;    &#125;</code></pre><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567933366085.png" srcset="/img/loading.gif" alt="1567933366085"></p><h1 id="TOKEN刷新"><a href="#TOKEN刷新" class="headerlink" title="TOKEN刷新"></a>TOKEN刷新</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567933734791.png" srcset="/img/loading.gif" alt="1567933734791"></p><p>这个过程可以在用户无感知的情况下去做，当用户访问app的时候，token过期了，客户端那边就会去请求上面这个地址，带上登录时拿到的refresh_token，对token进行刷新。这里要注意refresh_token也是有过期时间的，建议可以设置长一些，</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 7.重构注册逻辑</title>
    <link href="/spring-security-5.7.html"/>
    <url>/spring-security-5.7.html</url>
    
    <content type="html"><![CDATA[<p>通过前面章节，已经将登录逻辑跑通了，但是这里需要在数据库中有这么一条记录的情况下才能获取令牌，如果数据库中是没记录的，它是如何处理的？之前浏览器社交登录它的注册流程处理讲过这块，之前通过ProviderSignInUtils进行读写操作，但是这个工具它是基于session的，在我们现在的app模块使用是行不通的，这里就需要进行改造，这里就使用redis来进行存储，这里的改造思路和前面的“重构短信登录”章节的思路是一样的</p><hr><p>AppSignUpUtils工具类来代替ProviderSignInUtils工具，使用的是redis来存储</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.social;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 社交用户和系统用户的关系注册</span><span class="hljs-comment"> * ProviderSignInUtils 模拟其中部分的功能</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppSignUpUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> RedisTemplate&lt;Object, Object&gt; redisTemplate;    <span class="hljs-keyword">private</span> UsersConnectionRepository usersConnectionRepository;    <span class="hljs-keyword">private</span> ConnectionFactoryLocator connectionFactoryLocator;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存社交信息到redis</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">saveConnectionData</span><span class="hljs-params">(ServletWebRequest request, ConnectionData connectionData)</span> </span>&#123;        redisTemplate.opsForValue().set(buildKey(request), connectionData);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 社交用户信息入库</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPostSignUp</span><span class="hljs-params">(String userId, WebRequest request)</span> </span>&#123;        String key = buildKey(request);        <span class="hljs-keyword">if</span> (!redisTemplate.hasKey(key)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AppSecretException(<span class="hljs-string">"无法找到缓存的用户社交账号信息"</span>);        &#125;        ConnectionData connectionData = (ConnectionData) redisTemplate.opsForValue().get(key);        Connection&lt;?&gt; connection = connectionFactoryLocator.getConnectionFactory(connectionData.getProviderId())                .createConnection(connectionData);        usersConnectionRepository.createConnectionRepository(userId).addConnection(connection);        redisTemplate.delete(key);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">buildKey</span><span class="hljs-params">(WebRequest request)</span> </span>&#123;        String deviceId = request.getHeader(<span class="hljs-string">"deviceId"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(deviceId)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AppSecretException(<span class="hljs-string">"设备id参数不能为空"</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">"mcr:security:social.connect."</span> + deviceId;    &#125;&#125;</code></pre><p>光这个工具类是不够的，我们要让当用户去注册的时候，不要跳到我们之前配的注册页面上去，而是跳到指定的服务里面，而是跳到指定的服务上去，而这个服务使用这个AppSignUpUtils来保存用户信息，并且直接将用户信息用json的形式返回给app，那么现在来做一个配置的修改，在修改之前来看以下代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSocial</span><span class="hljs-meta">@Order</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialConfigurerAdapter</span> </span>&#123;<span class="hljs-comment">//..</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringSocialConfigurer <span class="hljs-title">mcrSpringSocialConfigurer</span><span class="hljs-params">()</span> </span>&#123;        McrSpringSocialConfigurer mcrSpringSocialConfigurer = <span class="hljs-keyword">new</span> McrSpringSocialConfigurer(securityProperties.getSocial().getFilterProcessesUrl());        mcrSpringSocialConfigurer.signupUrl(securityProperties.getBrowser().getSignUpUrl());        <span class="hljs-keyword">return</span> mcrSpringSocialConfigurer;    &#125;&#125;</code></pre><p>现在浏览器环境下是没问题的，在这里不要去改它，而在app环境下采用另外一种配置,这里需要记住spring中的BeanPostProcessor接口，它的作用是在IOC容器所有bean初始化之前和初始化之后都要经过这2个方法， </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.beans.factory.config;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<span class="hljs-function">Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<span class="hljs-function">Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;&#125;</code></pre><p>这里在后置处理的方法中判断bean的名字是不是mcrSpringSocialConfigurer，是的话将它的signupUrl设置成/<code>social/signUp</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 后置处理器 springBean 初始化之前和之后</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringSocialConfigurerPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">return</span> bean;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.equals(beanName, <span class="hljs-string">"mcrSpringSocialConfigurer"</span>)) &#123;            McrSpringSocialConfigurer configurer = (McrSpringSocialConfigurer) bean;            configurer.signupUrl(<span class="hljs-string">"/social/signUp"</span>);<span class="hljs-comment">//更换浏览器的默认注册</span>            <span class="hljs-keyword">return</span> configurer;        &#125;        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre><p>springbean生命周期关系如下：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/20190501135420696.png" srcset="/img/loading.gif" alt=""></p><p>注册处理：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.controller;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppSecurityController</span> </span>&#123; <span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> ProviderSignInUtils providerSignInUtils; <span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> AppSignUpUtils appSignUpUtils; <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/social/signUp"</span>)<span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)<span class="hljs-function"><span class="hljs-keyword">public</span> SocialUserInfoVO <span class="hljs-title">getSocialUserInfo</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;SocialUserInfoVO userInfo = <span class="hljs-keyword">new</span> SocialUserInfoVO();Connection&lt;?&gt; connection = providerSignInUtils.getConnectionFromSession(<span class="hljs-keyword">new</span> ServletWebRequest(request)); ConnectionData connectionData=connection.createData();userInfo.setProviderId(connection.getKey().getProviderId());userInfo.setProviderUserId(connection.getKey().getProviderUserId());userInfo.setNickname(connection.getDisplayName());userInfo.setHeadimg(connection.getImageUrl()); appSignUpUtils.saveConnectionData(<span class="hljs-keyword">new</span> ServletWebRequest(request), connectionData);<span class="hljs-keyword">return</span> userInfo;&#125;&#125;</code></pre><p>McrResourceServerConfig</p><pre><code class="hljs java">.antMatchers(                    <span class="hljs-string">"/social/signUp"</span>,</code></pre><p>UserController#方法进行修改</p><pre><code class="hljs java"> <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ProviderSignInUtils providerSignInUtils;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/regist"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">regist</span><span class="hljs-params">(UserVO userVO, HttpServletResponse response, HttpServletRequest request)</span> </span>&#123;        String userId = userVO.getUserName();        <span class="hljs-comment">//、绑定逻辑....</span><span class="hljs-comment">//        providerSignInUtils.doPostSignUp(userId, new ServletWebRequest(request, response));</span>        appSignUpUtils.doPostSignUp(userId, <span class="hljs-keyword">new</span> ServletWebRequest(request, response));    &#125;</code></pre><hr><p>笔者正在补充~</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 6.重构社交登录</title>
    <link href="/spring-security-5.6.html"/>
    <url>/spring-security-5.6.html</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>之前做browser走的是一个标准的OAuth流程，但是现在在App的环境下，架构就变成了用户访问的硬赢是一个App，这时候用户在app中去到点击QQ登录，实际上它不是访问我们业务系统中的请求路径，而是一个服务提供商的SDK，这个SDK会引导用户完成授权流程，不同的服务商对于SDK它的实现是不一样的，选的授权模式也不一样的，一般情况下会有2种模式：</p><p>（1）简化模式：SDK将用户导向认证服务器，然后用户授权以后，它返回的不是授权码，返回的是accessToken或者openid，到这一步时，app就知道用户它的openId了，这时候，app可以用openId或者accessToken直接去资源服务器获取用户信息的，但是它并不能拿这2个来访问我们自己的后端应用服务，因为这里的accessToken是服务提供商发的，而它要访问我们这里的应用服务，需要我们发的令牌，在这种场景下，我作为后端应用来说需要给app提供一个服务，让它可以用openId来换我们这的令牌，对于现在的业务场景，其实和前面的短信验证码登录差不多，只不过这里验的是openId，拿这个openId去数据库里查对应的用户信息，然后存在就生成令牌给用户，如果不存就响应错误</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567846953327.png" srcset="/img/loading.gif" alt="1567846953327"></p><p>（2）标准授权码模式：服务提供商提供的app sdk它走的是标准的授权码流程，在app上做完授权，它拿到的是授权码，这里需要把授权码给服务器，由服务器来申请令牌，服务提供商的认证服务器把令爱给第三方应用以后，第三方应用服务它去拿着令牌读用户数据，如果能读到用户数据，根据用户信息它去生成一个令牌给app，在这个流程下面，我们不需要做任何事的，因为在标准流程里面，我们是有这个 服务的，接受认证服务器返回的请求，然后提取里面的授权码再去发令牌，我们是有这么一个服务来处理这个请求的，在这个环境下的请求它发到的是手机app上去，app要做的是把请求原封不动转发到我们的服务器就可以了，或者把里面携带的授权码拿出来</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567849217792.png" srcset="/img/loading.gif" alt="1567849217792"></p><h1 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h1><p>McrResourceServerConfig：</p><pre><code class="hljs java">   <span class="hljs-keyword">private</span> SpringSocialConfigurer mcrSpringSocialConfigurer;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;http.               .apply(mcrSpringSocialConfigurer)</code></pre><p>根据上面描述中，这里需要获取请求中的openId、providerId，然后到数据库中查找，这里做了一个OpenIdAuthenticationToken</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.social.openid; <span class="hljs-keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.SpringSecurityCoreVersion; <span class="hljs-keyword">import</span> java.util.Collection; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenIdAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; <span class="hljs-comment">// ~ Instance fields</span><span class="hljs-comment">// ================================================================================================</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;<span class="hljs-comment">//openId</span><span class="hljs-keyword">private</span> String providerId;<span class="hljs-comment">//供应商ID</span> <span class="hljs-comment">// ~ Constructors</span><span class="hljs-comment">// ===================================================================================================</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenIdAuthenticationToken</span><span class="hljs-params">(Object principal, String providerId)</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">this</span>.providerId = providerId;<span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// must use super, as we override</span>&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenIdAuthenticationToken</span><span class="hljs-params">(Object principal,</span></span><span class="hljs-function"><span class="hljs-params"> Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<span class="hljs-keyword">super</span>(authorities);<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// must use super, as we override</span>&#125; <span class="hljs-comment">// ~ Methods</span><span class="hljs-comment">// ========================================================================================================</span>  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProviderId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> providerId;&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;<span class="hljs-keyword">if</span> (isAuthenticated) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);&#125; <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>.eraseCredentials();&#125; &#125;</code></pre><p>这里和之前做登录登录一样，定义一个过滤器，放到spring security的过滤器链上来拦截特定的请求，如果是特定的那个QQ登录请求的话，就获取请求中openId、providerId将它组合成上面这个OpenIdAuthenticationToken交给AuthenticationManager</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.social.openid;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 逻辑通短信登录验证</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenIdAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> String openIdParameter = SecurityConstants.DEFAULT_PARAMETER_NAME_OPENID;    <span class="hljs-comment">// 服务提供商id，qq还是微信</span>    <span class="hljs-keyword">private</span> String providerIdParameter = SecurityConstants.DEFAULT_PARAMETER_NAME_PROVIDERID;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OpenIdAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_OPENID, <span class="hljs-string">"POST"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                                                HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;        <span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(                    <span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());        &#125;        String openId = obtainOpenId(request);        String providerId = obtainProviderId(request);        <span class="hljs-keyword">if</span> (openId == <span class="hljs-keyword">null</span>) &#123;            openId = <span class="hljs-string">""</span>;        &#125;        <span class="hljs-keyword">if</span> (providerId == <span class="hljs-keyword">null</span>) &#123;            providerId = <span class="hljs-string">""</span>;        &#125;        openId = openId.trim();        OpenIdAuthenticationToken authRequest = <span class="hljs-keyword">new</span> OpenIdAuthenticationToken(openId, providerId);        <span class="hljs-comment">// Allow subclasses to set the "details" property</span>        setDetails(request, authRequest);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainOpenId</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(openIdParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">obtainProviderId</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        <span class="hljs-keyword">return</span> request.getParameter(providerIdParameter);    &#125;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">                              OpenIdAuthenticationToken authRequest)</span> </span>&#123;        authRequest.setDetails(authenticationDetailsSource.buildDetails(request));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOpenIdParameter</span><span class="hljs-params">(String openIdParameter)</span> </span>&#123;        Assert.hasText(openIdParameter, <span class="hljs-string">"Username parameter must not be empty or null"</span>);        <span class="hljs-keyword">this</span>.openIdParameter = openIdParameter;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;        <span class="hljs-keyword">this</span>.postOnly = postOnly;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getOpenIdParameter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> openIdParameter;    &#125;&#125;</code></pre><p>创建AuthenticationProvider的实现类，用于OpenIdAuthenticationToken的效验，这里通过之前在social中介绍的UsersConnectionRepository来通过app发过来的openId、providerId到数据库中进行查询</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.social.openid; <span class="hljs-keyword">import</span> org.apache.commons.collections.CollectionUtils;<span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;<span class="hljs-keyword">import</span> org.springframework.security.authentication.InternalAuthenticationServiceException;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-keyword">import</span> org.springframework.social.connect.UsersConnectionRepository;<span class="hljs-keyword">import</span> org.springframework.social.security.SocialUserDetailsService; <span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Set; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证OpenIdAuthenticationToken</span><span class="hljs-comment"> * 查询社交数据库表UserConnection</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenIdAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;  <span class="hljs-keyword">private</span> SocialUserDetailsService userDetailsService; <span class="hljs-keyword">private</span> UsersConnectionRepository usersConnectionRepository; <span class="hljs-comment">/*</span><span class="hljs-comment"> * (non-Javadoc)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @see org.springframework.security.authentication.AuthenticationProvider#</span><span class="hljs-comment"> * authenticate(org.springframework.security.core.Authentication)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123; OpenIdAuthenticationToken authenticationToken = (OpenIdAuthenticationToken) authentication; Set&lt;String&gt; providerUserIds = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();providerUserIds.add((String) authenticationToken.getPrincipal());<span class="hljs-comment">//openId</span><span class="hljs-comment">//UserConnection 这个表里查询信息</span>Set&lt;String&gt; userIds = usersConnectionRepository.findUserIdsConnectedTo(authenticationToken.getProviderId(), providerUserIds); <span class="hljs-keyword">if</span>(CollectionUtils.isEmpty(userIds) || userIds.size() != <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(<span class="hljs-string">"无法获取用户信息"</span>);&#125; String userId = userIds.iterator().next(); UserDetails user = userDetailsService.loadUserByUserId(userId); <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(<span class="hljs-string">"无法获取用户信息"</span>);&#125; OpenIdAuthenticationToken authenticationResult = <span class="hljs-keyword">new</span> OpenIdAuthenticationToken(user, user.getAuthorities()); authenticationResult.setDetails(authenticationToken.getDetails()); <span class="hljs-keyword">return</span> authenticationResult;&#125; <span class="hljs-comment">/*</span><span class="hljs-comment"> * (non-Javadoc)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * @see org.springframework.security.authentication.AuthenticationProvider#</span><span class="hljs-comment"> * supports(java.lang.Class)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;<span class="hljs-keyword">return</span> OpenIdAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> SocialUserDetailsService <span class="hljs-title">getUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> userDetailsService;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDetailsService</span><span class="hljs-params">(SocialUserDetailsService userDetailsService)</span> </span>&#123;<span class="hljs-keyword">this</span>.userDetailsService = userDetailsService;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> UsersConnectionRepository <span class="hljs-title">getUsersConnectionRepository</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> usersConnectionRepository;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsersConnectionRepository</span><span class="hljs-params">(UsersConnectionRepository usersConnectionRepository)</span> </span>&#123;<span class="hljs-keyword">this</span>.usersConnectionRepository = usersConnectionRepository;&#125; &#125;</code></pre><p>将以上的代码进行配置</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.social.openid;<span class="hljs-comment">/**</span><span class="hljs-comment"> * openId 权限配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenIdAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> SocialUserDetailsService userDetailsService;    <span class="hljs-keyword">private</span> UsersConnectionRepository usersConnectionRepository;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        OpenIdAuthenticationProvider provider = <span class="hljs-keyword">new</span> OpenIdAuthenticationProvider();        provider.setUserDetailsService(userDetailsService);        provider.setUsersConnectionRepository(usersConnectionRepository);        OpenIdAuthenticationFilter filter = <span class="hljs-keyword">new</span> OpenIdAuthenticationFilter();        filter.setAuthenticationManager(http.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;        filter.setAuthenticationFailureHandler(authenticationFailureHandler);        filter.setAuthenticationSuccessHandler(authenticationSuccessHandler);        <span class="hljs-comment">//密码登录后置过滤</span>        http.                authenticationProvider(provider)                .addFilterAfter(filter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><h1 id="标准授权码模式"><a href="#标准授权码模式" class="headerlink" title="标准授权码模式"></a>标准授权码模式</h1><p>现在先来看下什么都不做的效果，不过现在由于没法拿到授权码，在这里我把mcr-demo模块中依赖的app先改为browser，在获取授权码的地方打上断点，然后进行QQ登录的操作，拿到授权码在切换回使用app依赖，将授权码输入上去</p><p> 断点位置：</p><p>OAuth2AuthenticationService的98行</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567850144540.png" srcset="/img/loading.gif" alt="1567850144540"></p><p>然后进行QQ登录操作，这个时候在IDE中就能看到授权码的值了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567850994429.png" srcset="/img/loading.gif" alt="1567850994429"></p><p>这里不要把断点放走，将这里的授权码复制出来，然后把mcr-demo模块中的browser切换回app，进行重启</p><hr><p>笔者正在补充~</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 5.重构短信登录</title>
    <link href="/spring-security-5.5.html"/>
    <url>/spring-security-5.5.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567834291046.png" srcset="/img/loading.gif" alt="1567834291046"></p><p>app的短信验证码登录和browser的有所不同，就是现在在app模块中是不能使用session，那么就以为着生成的实际验证码无法存储起来，这里我们进行重构，将之前的session改为使用redis来进行存储，而在browser下面还是使用session存储。</p><hr><p>加入之前写好的过滤器和验证码配置， McrResourceServerConfig</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;<span class="hljs-keyword">private</span> ValidateCodeFilter validateCodeFilter;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http            .addFilterBefore(validateCodeFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">            .<span class="hljs-title">apply</span>(<span class="hljs-title">smsCodeAuthenticationSecurityConfig</span>)</span><span class="hljs-class">            .<span class="hljs-title">and</span>()</span></code></pre><p>定义一个接口，来负责管理验证码的存储</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ValidateCodeDTO;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证码存储接口</span><span class="hljs-comment"> * (适配浏览器和app)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidateCodeRepository</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeDTO code, ValidateCodeType validateCodeType)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-function">ValidateCodeDTO <span class="hljs-title">get</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移除验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span></span>;&#125;</code></pre><p>在app模块下面，通过redis进行管理</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.validate.code;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ValidateCodeDTO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeException;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeRepository;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeType;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-keyword">import</span> javax.annotation.Resource;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * redis存储验证码</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisValidateCodeRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeRepository</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;Object, Object&gt; redisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码放入redis规则模式：CODE_&#123;TYPE&#125;_&#123;DEVICEId&#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String CODE_KEY_PATTERN = <span class="hljs-string">"CODE_%s_%s"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeDTO code, ValidateCodeType validateCodeType)</span> </span>&#123;        redisTemplate.opsForValue().set(buildKey(request, validateCodeType), code, <span class="hljs-number">180</span>, TimeUnit.MINUTES);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeDTO <span class="hljs-title">get</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span> </span>&#123;        String key = buildKey(request, validateCodeType);        <span class="hljs-comment">// 拿到创建 create() 存储到session的code验证码对象</span>        <span class="hljs-keyword">return</span> (ValidateCodeDTO) redisTemplate.opsForValue().get(key);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span> </span>&#123;        String key = buildKey(request, validateCodeType);        redisTemplate.delete(key);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构建验证码放入redis时的key; 在保存的时候也使用该key</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">buildKey</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span> </span>&#123;        String deviceId = request.getHeader(<span class="hljs-string">"deviceId"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(deviceId)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"请在请求头中携带deviceId参数"</span>);        &#125;        <span class="hljs-keyword">return</span> String.format(CODE_KEY_PATTERN, validateCodeType, deviceId);    &#125;&#125;</code></pre><p>在browser中则使用sessin管理</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.validate.code;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ValidateCodeDTO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeRepository;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeType;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.HttpSessionSessionStrategy;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.SessionStrategy;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * session存储实现</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionValidateCodeRepository</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeRepository</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 操作session的工具类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码放入session的时候前缀</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String SESSION_KEY_PREFIX = <span class="hljs-string">"SESSION_KEY_FOR_CODE"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeDTO code, ValidateCodeType validateCodeType)</span> </span>&#123;        sessionStrategy.setAttribute(request, getSessionKey(validateCodeType), code);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeDTO <span class="hljs-title">get</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span> </span>&#123;        String sessionKey = getSessionKey(validateCodeType);        <span class="hljs-comment">// 拿到创建 create() 存储到session的code验证码对象</span>        <span class="hljs-keyword">return</span> (ValidateCodeDTO) sessionStrategy.getAttribute(request, sessionKey);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移除验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeType validateCodeType)</span> </span>&#123;        sessionStrategy.removeAttribute(request, getSessionKey(validateCodeType));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构建验证码放入session时的key; 在保存的时候也使用该key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSessionKey</span><span class="hljs-params">(ValidateCodeType validateCodeType)</span> </span>&#123;        <span class="hljs-keyword">return</span> SESSION_KEY_PREFIX + validateCodeType.toString().toUpperCase();    &#125;&#125;</code></pre><p>AbstractValidateCodeProcessor</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.impl;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ImageCodeDTO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ValidateCodeDTO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.*;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.HttpSessionSessionStrategy;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.SessionStrategy;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestBindingException;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestUtils;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractValidateCodeProcessor</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidateCodeDTO</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeProcessor</span> </span>&#123;       <span class="hljs-keyword">private</span> ValidateCodeRepository validateCodeRepository;     <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;      ...    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成校验码</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> C <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;      <span class="hljs-comment">//...</span>        <span class="hljs-keyword">return</span> (C) validateCodeGenerator.generate(request);    &#125;       <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存校验码</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, C validateCode)</span> </span>&#123;        ValidateCodeDTO validateCodeDTO = <span class="hljs-keyword">new</span> ValidateCodeDTO(validateCode.getCode(), validateCode.getExpireTime());        validateCodeRepository.save(request, validateCodeDTO, getValidateCodeType());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送校验码，由子类实现</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ServletWebRequest request, C validateCode)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        ValidateCodeType processorType = getValidateCodeType();        String sessionKey = getSessionKey();<span class="hljs-comment">//        C codeInSession = (C) sessionStrategy.getAttribute(request, sessionKey);</span>                   <span class="hljs-keyword">if</span> ... <span class="hljs-keyword">if</span> (codeInSession.isExpired()) &#123;            validateCodeRepository.remove(request, getValidateCodeType());            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(processorType + <span class="hljs-string">"验证码已过期"</span>);        &#125;<span class="hljs-comment">//        sessionStrategy.removeAttribute(request, sessionKey);</span>        validateCodeRepository.remove(request, getValidateCodeType());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构建验证码放入session时的key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSessionKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SESSION_KEY_PREFIX + getValidateCodeType().toString().toUpperCase();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据请求的url获取校验码的类型</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> ValidateCodeType <span class="hljs-title">getValidateCodeType</span><span class="hljs-params">()</span> </span>&#123;        String type = StringUtils.substringBefore(getClass().getSimpleName(), <span class="hljs-string">"CodeProcessor"</span>);        <span class="hljs-keyword">return</span> ValidateCodeType.valueOf(type.toUpperCase());    &#125;&#125;</code></pre><p>现在来通过工具获取短信验证码：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567838325205.png" srcset="/img/loading.gif" alt="1567838325205"></p><p>这里需要加入deviceId头信息</p><hr><p>发送短信登录请求：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567838526854.png" srcset="/img/loading.gif" alt="1567838526854"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 4.重构用户密码登录</title>
    <link href="/spring-security-5.4.html"/>
    <url>/spring-security-5.4.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1234345624623dsafasfd.png" srcset="/img/loading.gif" alt="1234345624623dsafasfd"></p><p>在我们的业务场景，自己写的登录流程，需要借助图中的代码的话，首先从TokenEndpoint到TokenGranter，这些代码是我们不能用的，这是发获取令牌的请求，而我们要发登录的请求，我们要用自己的过滤器去处理登录请求，一直到4种授权模式生成令牌这些逻辑我们都是不能用的。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/adsfasdfweroiqwyeuryqowe.png" srcset="/img/loading.gif" alt="adsfasdfweroiqwyeuryqowe"></p><p>我们要用的是什么？我们要用的是是AuthorizationServerTokenServices，它来产生令牌，在哪里用它？在我们自己写到AuthenticationSuccessHandler实现类里，不管你的登录请求是什么，不管被哪个过滤器来拦截，不管经历了什么登录逻辑的处理，最终当用户登录成功以后，它都会交到一个AuthenticationSuccessHandler接口的实现里面去做一个处理，我们要做的事情是什么？要做的就是在这个接口的实现里面去调AuthorizationServerTokenServices，然后去产生令牌响应出去。之前我们在做这个浏览器模块中写过一个McrAuthenticationSuccessHandler，返回给前端一个json数据</p><p>，这里要改成使用AuthorizationServerTokenServices来生成令牌，上一章里说过，要通过它生成令牌，需要传的参数是OAuth2Authentication，要想生成OAuth2Authentication，还需要OAuth2Request、Authentication，我们之前在spring security oauth里面它是通过不同的授权模式然后根据授权模式传的参数，来构建出Authentication来的，在我们的场景，经过前面的登录逻辑处理，最后进到AuthenticationSuccessHandler的时候，它的onAuthenticationSuccess方法参数中就有一个组装好的Authentication，所以在我们代码里面是不需要处理Authentication它的一个创建过程的，因为它在之前登录的过程已经创建好了，最终就变成需要处理OAuth2Request，如果能把这个东西构建出来，那么那这2个对象就能构建出OAuth2Authentication，有了OAuth2Authentication就能通过AuthorizationServerTokenServices构建出OAuth2AccessToken来。</p><p>OAuth2Request如何构建？</p><p>通过ClientDetails：第三方客户端的信息，还有一个TokenRequest：当前拿token请求里面一些参数的信息，通过2两个类拼成一个OAuth2Request</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567685551563.png" srcset="/img/loading.gif" alt="1567685551563"></p><p>ClientDetails从来哪来的呢？</p><p>是从ClientDetailsService读出来的，这个ClientDetailsService接受一个ClientId，然后返回一个ClientDetails，那么ClientId从哪来？——从请求参数里来，第三方发请求的时候，要把ClientId和ClientSecret做一个Base64编码放到请求头里面</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567685682407.png" srcset="/img/loading.gif" alt="1567685682407"></p><p>然后通过解析这个Base64的串来拿到ClientId，有ClientId以后就能拿到ClientDetails</p><p>TokenRequest怎么来的？</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567685847409.png" srcset="/img/loading.gif" alt="1567685847409"></p><p>它是实例化出来的，通过ClientDetails一些属性，和请求参数中的一些属性直接实例化出来的</p><hr><ol><li>写代码的位置在McrAuthenticationSuccessHandler里</li><li>最终的目标是获取一个AccessToken，那么就需要先获取到ClientDetails和TokenRequest，所以要先从ClientId入手，整个思路</li></ol><p>下面来开始写代码</p><p>首先要获取ClientId，就要从请求头的Authorization中的Base64字节码进行解析，这里的解析逻辑在BasicAuthenticationFilter中有现成的</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567686175081.png" srcset="/img/loading.gif" alt="1567686175081"></p><p>，这里获取的username就是</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567686228018.png" srcset="/img/loading.gif" alt="1567686228018"></p><hr><p>成功处理器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.authentication;<span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationSuccessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-keyword">private</span> ClientDetailsService clientDetailsService;    <span class="hljs-keyword">private</span> AuthorizationServerTokenServices authorizationServerTokenServices;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        String header = request.getHeader(<span class="hljs-string">"Authorization"</span>);        <span class="hljs-keyword">if</span> (header == <span class="hljs-keyword">null</span> || !header.startsWith(<span class="hljs-string">"Basic "</span>)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnapprovedClientAuthenticationException(<span class="hljs-string">"请求头无Client信息"</span>);        &#125;        String[] tokens = extractAndDecodeHeader(header);        <span class="hljs-keyword">assert</span> tokens.length == <span class="hljs-number">2</span>;        String clientId = tokens[<span class="hljs-number">0</span>];        String clientSecret = tokens[<span class="hljs-number">1</span>];        ClientDetails clientDetails = clientDetailsService.loadClientByClientId(clientId);        <span class="hljs-keyword">if</span> (clientDetails == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnapprovedClientAuthenticationException(<span class="hljs-string">"clientId对应的配置信息不存在"</span> + clientId);        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!StringUtils.equals(clientDetails.getClientSecret(), clientSecret)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnapprovedClientAuthenticationException(<span class="hljs-string">"clientSecret不匹配"</span> + clientId);        &#125;        TokenRequest tokenRequest = <span class="hljs-keyword">new</span> TokenRequest(MapUtils.EMPTY_MAP, clientId, clientDetails.getScope(), <span class="hljs-string">"custom"</span>);        OAuth2Request oAuth2Request = tokenRequest.createOAuth2Request(clientDetails);        OAuth2Authentication oAuth2Authentication = <span class="hljs-keyword">new</span> OAuth2Authentication(oAuth2Request, authentication);        OAuth2AccessToken accessToken = authorizationServerTokenServices.createAccessToken(oAuth2Authentication);        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);        response.getWriter().write(objectMapper.writeValueAsString(accessToken));    &#125;    <span class="hljs-keyword">private</span> String[] extractAndDecodeHeader(String header)            <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-keyword">byte</span>[] base64Token = header.substring(<span class="hljs-number">6</span>).getBytes(StandardCharsets.UTF_8);        <span class="hljs-keyword">byte</span>[] decoded;        <span class="hljs-keyword">try</span> &#123;            decoded = Base64.decode(base64Token);        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(                    <span class="hljs-string">"Failed to decode basic authentication token"</span>);        &#125;        <span class="hljs-comment">//用户名+“：”+密码组成的</span>        String token = <span class="hljs-keyword">new</span> String(decoded, StandardCharsets.UTF_8);        <span class="hljs-comment">//拿到以后它会找上面字符串“:”的位置</span>        <span class="hljs-keyword">int</span> delim = token.indexOf(<span class="hljs-string">":"</span>);        <span class="hljs-comment">//如果没找到就抛出异常</span>        <span class="hljs-keyword">if</span> (delim == -<span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"Invalid basic authentication token"</span>);        &#125;        <span class="hljs-comment">//从开始，到冒号的位置，也就是获取了用户名，从冒号往后也就是密码，把这2段放到spring数组返回</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;token.substring(<span class="hljs-number">0</span>, delim), token.substring(delim + <span class="hljs-number">1</span>)&#125;;    &#125;&#125;</code></pre><p>McrResourceServerConfig</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrResourceServerConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ResourceServerConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http                .formLogin()                .successHandler(authenticationSuccessHandler)                .failureHandler(authenticationFailureHandler)                .loginPage(SecurityConstants.DEFAULT_UNAUTHENTICATED_URL)                .loginProcessingUrl(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM)                .and()                .authorizeRequests()                .antMatchers(                        SecurityConstants.DEFAULT_UNAUTHENTICATED_URL,                        SecurityConstants.DEFAULT_VALIDATE_CODE_URL_PREFIX + <span class="hljs-string">"/*"</span>                ).permitAll()                .anyRequest()                .authenticated()                .and()                .csrf()                .disable();    &#125;&#125;</code></pre><p>现在来访问<code>/authentication/form</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567691286732.png" srcset="/img/loading.gif" alt="1567691286732"></p><p>这里和表单登录的差别在于请求头上需要带上<code>Authorization</code></p><hr><p>访问受保护的<code>rest api</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567691505306.png" srcset="/img/loading.gif" alt="1567691505306"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 3.Spring Security OAuth核心源码解析</title>
    <link href="/spring-security-5.3.html"/>
    <url>/spring-security-5.3.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567511400096.png" srcset="/img/loading.gif" alt=""></p><p>上一章通过2个注解实现了OAuth2标准的4种授权模式，之前提到过，这4种授权模式在实际业务场景是不能用的，比如说手机号码+验证码登录这种，后面笔者会带着大家去用我们之前的代码去嫁接到这写授权码模式中，在这之前，笔者会带着大家来读一度源码</p><hr><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1234345624623dsafasfd.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>这里绿色的方块代表实体类，蓝色的方块表示接口，接口中的括号表示实际上使用的实现类</p></blockquote><p>TokenEndpoint：它是整个流程的入口点，可以理解成controller，它来处理获取令牌的请求，它的postAccessToken方法是一个post请求，地址为/oauth/token，就是之前获取token的那个地址</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/oauth/token"</span>, method=RequestMethod.POST)<span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;OAuth2AccessToken&gt; <span class="hljs-title">postAccessToken</span><span class="hljs-params">(Principal principal, @RequestParam</span></span><span class="hljs-function"><span class="hljs-params">Map&lt;String, String&gt; parameters)</span> <span class="hljs-keyword">throws</span> HttpRequestMethodNotSupportedException </span>&#123;  &#125;</code></pre><p>ClientDetailsService：用来读取第三方应用的信息的，之前发请求的时候都会带一个clientId和clientSecret来告诉它是哪个应用在请求授权，这个接口会根据第三方发送的clientId去读取相应的client的一些配置信息，例如之前在yml中配的client-id、client-secret，其实还有一些信息可以配置</p><hr><p>ClientDetails：ClientDetailsService读出来的这些配置信息都会写到ClientDetails这个对象的里面去，它存储的信息是第三方应用的信息</p><hr><p>TokenRequest：TokenEndpoint会创建一个TokenRequest的对象，这个对象封装了/oauth/token请求中其他参数的信息，例如grant_type、code、client_id…这些信息，然后它会把ClientDetails也同时放到TokenRequest里面，因为第三方应用的信息也是令牌请求的一部分</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567600898713.png" srcset="/img/loading.gif" alt="1567600898713"></p><hr><p>TokenGranter：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TokenGranter</span> </span>&#123;<span class="hljs-function">OAuth2AccessToken <span class="hljs-title">grant</span><span class="hljs-params">(String grantType, TokenRequest tokenRequest)</span></span>;&#125;</code></pre><p>在TokenEndpoint132进行使用</p><pre><code class="hljs java">OAuth2AccessToken token = getTokenGranter().grant(tokenRequest.getGrantType(), tokenRequest);</code></pre><p>它是令牌授权者，在这个接口封装了4种授权模式实现和刷新令牌授权实现，在这个接口里面，它会根据第三方请求传上来的grant_type去挑一个具体实现来执行令牌生成逻辑，不管是哪个实现，在生成的过程中，都会产生2个对象：</p><ol><li>OAuth2Request：这个对象是ClientDetails和TokenRequest它们的信息整合，把这2个对象整合到一起，变为新的对象</li><li>Authentication：这个接口封装了你当前授权用户的一些信息，谁在做授权，这里就是做授权的用户的信息，它里面的信息是通过UserDetailsService读出来的</li></ol><hr><p>OAuth2Authentication：OAuth2Request对象和Authentication组合而成，它里面包含了：第三方授权的那个用户是哪一个第三方应用，然后在请求哪个用户给你授权，用的授权模式是什么，授权的参数是什么</p><hr><p>AuthorizationServerTokenServices：OAuth2Authentication会传给AuthorizationServerTokenServices接口的实现，这个接口是认证服务器的令牌服务，它拿到Authentication信息以后，它会最终给第三方生成一个OAuth2Authentication令牌。</p><hr><p>DefaultTokenServices：它是AuthorizationServerTokenServices接口的默认实现，它里面包含了：</p><ul><li>TokenStore：用来对token进行存储</li><li>TokenEnhancer：令牌增强器，当令牌生成出以后，可以去改造令牌</li></ul><hr><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>断点位置：</p><ul><li>TokenEndpoint：95行</li></ul><hr><p>这里以密码授权模式做演示，因为它的步骤就一个，不像授权码模式那样要2步，</p><p>现在使用前面介绍的工具来进行发送</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567602161087.png" srcset="/img/loading.gif" alt="1567602161087"></p><hr><p>TokenEndpoint#postAccessToken：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567602341977.png" srcset="/img/loading.gif" alt="1567602341977"></p><p>首先会从请求中获取clientId，然后通过clientId去调用ClientDetailsService#loadClientByClientId方法来获取第三方应用的详细配置，也就是ClientDetails</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567602469054.png" srcset="/img/loading.gif" alt="1567602469054"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567602693706.png" srcset="/img/loading.gif" alt="1567602693706"></p><p>在这里可以看到它有很多配置的项，然后将这个ClientDetails，以及第三方发送的其他参数传给OAuth2RequestFactory#createTokenRequest方法去返回一个TokenRequest对象，拿到TokenRequest以后，会对它这个进行一系列判断</p><pre><code class="hljs java"><span class="hljs-comment">//判断是否传递了clientId</span><span class="hljs-keyword">if</span> (clientId != <span class="hljs-keyword">null</span> &amp;&amp; !clientId.equals(<span class="hljs-string">""</span>)) &#123;<span class="hljs-comment">//clientId是不是和配置的clientId是否匹配</span><span class="hljs-keyword">if</span> (!clientId.equals(tokenRequest.getClientId())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidClientException(<span class="hljs-string">"Given client ID does not match authenticated client"</span>);&#125;&#125;<span class="hljs-keyword">if</span> (authenticatedClient != <span class="hljs-keyword">null</span>) &#123;      <span class="hljs-comment">//检查scope，所谓的scope是第三方请求的到底是什么，之前说过client可以有很多配置项，其中就有client能发出去什么样的授权，如果你配了的话，它会去做这些检查，第三方当前请求的授权只能在第三方应用可以发的授权集合里面才能通过这个校验</span>oAuth2RequestValidator.validateScope(tokenRequest, authenticatedClient);&#125;<span class="hljs-comment">//判断GrantType是否有值，</span><span class="hljs-keyword">if</span> (!StringUtils.hasText(tokenRequest.getGrantType())) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidRequestException(<span class="hljs-string">"Missing grant type"</span>);&#125;<span class="hljs-comment">//如果传了GrantType,它这里会判断这个GrantType是不是简化模式，如果是简化模式它会抛异常，因为所谓的简化模式就是授权码模式里的简化，在用户在授权的时候直接放回令牌，所以在授权码模式里面是不会有第二步请求令牌这样服务被调用的，所以你在请求令牌的时候传的是简化模式，这是不支持的</span><span class="hljs-keyword">if</span> (tokenRequest.getGrantType().equals(<span class="hljs-string">"implicit"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidGrantException(<span class="hljs-string">"Implicit grant type not supported from token endpoint"</span>);&#125;<span class="hljs-comment">//判断当前是不是一个授权码模式的请求，之前演示中，授权码模式是2步，在授权码模式中你发出去的令牌它所包含的权限scope不是在发令牌这个请求里决定的，而是在给授权码里面决定的，就是在用户确认的时候，用户确认之后，服务器会给授权码，用户确认的时候它会给第三方读的权限，然后这个信息包含在授权码里面给到第三方，第三方在换访问令牌的时候，它就只能拿到读的权限，它不能说换令牌的时候，自己带个参数说要一个写的权限，这是不认的，所以在授权码模式的请求，那么这里就直接把token里的scope，就是第三方所要求的权限给变为空的，它会在后面以你之前发过授权码里面去找你之前的发出去的授权码，然后根据授权码里面重新把scope设上，而不会用你请求令牌里带的scope</span><span class="hljs-keyword">if</span> (isAuthCodeRequest(parameters)) &#123;<span class="hljs-comment">// The scope was requested or determined during the authorization step</span><span class="hljs-keyword">if</span> (!tokenRequest.getScope().isEmpty()) &#123;logger.debug(<span class="hljs-string">"Clearing scope of incoming token request"</span>);tokenRequest.setScope(Collections.&lt;String&gt; emptySet());&#125;&#125;<span class="hljs-comment">//判断是不是刷新令牌请求，因为刷新令牌它也有自己的默认的scope，所以在这里如果是刷新令牌请求，它会把scope重新设一下 </span><span class="hljs-keyword">if</span> (isRefreshTokenRequest(parameters)) &#123;<span class="hljs-comment">// A refresh token has its own default scopes, so we should ignore any added by the factory here.</span>tokenRequest.setScope(OAuth2Utils.parseParameterList(parameters.get(OAuth2Utils.SCOPE)));&#125;</code></pre><p>通过前面一系列检查以后，最终会把tokenRequest传给TokenGranter#grant方法来产生OAuth2AccessToken对象，然后通过内部的getResponse方法响应给前端</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567603732339.png" srcset="/img/loading.gif" alt="1567603732339"></p><hr><p>TokenGranter这个接口后面封装了4种授权模式加上刷新这种模式，一共5个模式来产生AccessToken，那么来进去看一下</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567604010304.png" srcset="/img/loading.gif" alt="1567604010304">现在在AuthorizationServerEndpointsConfigurer#tokenGranter方法中，这里会调用CompositeTokenGranter也就是TokenGranter实现类的grant方法</p><hr><p>CompositeTokenGranter#grant：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567604177639.png" srcset="/img/loading.gif" alt="1567604177639"></p><p>这里它通过成员变量tokenGranters的TokenGranter泛型集合进行遍历，这里的tokenGranters的size为5，也就是说的4种授权模式+刷新授权，这里的方法中对这个集合进行遍历然后调用者5个实现类的grant方法：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567604529494.png" srcset="/img/loading.gif" alt="1567604529494"></p><p>，这些实现类的grant方法会根据参数中传递的grantType的值去判断是不是要用自己的授权方式，如果不是则直接返回null，如果是则生成继续往下走</p><hr><p>这里根据clientId拿到我在yml中配置的信息封装成ClientDetails</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567604901778.png" srcset="/img/loading.gif" alt="1567604901778"></p><p>然后将配置信息和grantType传递给validateGrantType方法进行校验</p><hr><p>最终返回值是调用了一个getAccessToken获取的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<span class="hljs-keyword">return</span> tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest));&#125;</code></pre><p>这里实际上调用了AuthorizationServerTokenServices的createAccessToken方法，createAccessToken方法中需要一个参数，这里的参数类型为OAuth2Authentication，这个OAuth2Authentication是由5种授权模式生成的，我现在这个例子中是密码模式，通过用户名密码来获取当前授权用户的信息，而在授权码模式里面，则要通过第一步发出去的授权码，发授权码的时候，它这里会记下来这个授权码对应的用户信息是什么，然后第三方拿这个授权码来换令牌的时候，这里根据授权码在把之前授权码对应的用户信息读出来，这些处理逻辑方式在不同的授权模式下是不一样的，所以这里的getOAuth2Authentication在不同的授权模式有不同的实现，那么现在例子中的是密码模式一个实现，</p><p>ResourceOwnerPasswordTokenGranter#getOAuth2Authentication</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567605829832.png" srcset="/img/loading.gif" alt="1567605829832"></p><p>在这里根据请求参数的用户名密码去实例化了一个之前反复说的UsernamePasswordAuthenticationToken，然后传递给AuthenticationManager去做认证，在这个认证的过程中，它实际会调用我们写的UserDetailsService实现，去数据库中的信息做认证，如果认证通过就代表这里的userAuth这个Authentication对象是正确的</p><pre><code class="hljs java">OAuth2Request storedOAuth2Request = getRequestFactory().createOAuth2Request(client, tokenRequest);</code></pre><p>然后将ClientDetails和TokenRequest合起来创建一个OAuth2Request，来看一下它是怎么拼出来的，实际上是调用了一个createOAuth2Request方法，把第三方应用的信息传给它就可以了，这块代码看一下，等会会把这些代码拷走，用一些代码自己来生成最后的token</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> OAuth2Request <span class="hljs-title">createOAuth2Request</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<span class="hljs-keyword">return</span> tokenRequest.createOAuth2Request(client);&#125;</code></pre><hr><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> OAuth2AccessToken <span class="hljs-title">getAccessToken</span><span class="hljs-params">(ClientDetails client, TokenRequest tokenRequest)</span> </span>&#123;<span class="hljs-keyword">return</span> tokenServices.createAccessToken(getOAuth2Authentication(client, tokenRequest));&#125;</code></pre><p>前面的getAccessToken方法执行一旦成功了返回的OAuth2Authentication对象就去创建了一个AccessToken，然后响应出去，整个流程就结束了</p><hr><p>在结束之前来看看DefaultTokenServices是如何把AccessToken生成出来的</p><p>断点：84行，createAccessToken方法中</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567606898774.png" srcset="/img/loading.gif" alt="1567606898774"></p><p>首先方法第1行，将authentication放入TokenStore的getAccessToken方法中，这里的TokenStore就是之前说的同一个用户，如果令牌没有过期，在去拿取令牌时候它会把之前发的令牌再发给你，所以一来到第1行它会去找，当前的用户是不是发过令牌，然后判断这个令牌是不是空的，如果不为空，就说明在这个请求之前发给令牌给这个用户，然后判断之前发给用户的令牌是不是过期了，如果已经过期了，那么将会从TokenStore把相应的RefreshToken和AccessToken全都删掉，如果没过期，则重新把令牌存下来，因为可能是用另一种方式来访问这个令牌的，一开始请求这个令牌可能是拿授权码模式请求的，后来又用密码模式又请求了一次，这时候存的信息是不一样的，所以这个令牌没过期，但是这里还是会重写存一下，如果存的令牌不过期的话，那么就直接把这个存在的令牌在发回去，那么如果过期了或者它本身就没发过，第三方是第一次，那么就会接着往下走：</p><pre><code class="hljs java"><span class="hljs-comment">//看refreshToken有没有，如果没有的话建立一个刷新令牌，然后拿取当前的用户</span><span class="hljs-keyword">if</span> (refreshToken == <span class="hljs-keyword">null</span>) &#123;refreshToken = createRefreshToken(authentication);&#125;<span class="hljs-comment">// But the refresh token itself might need to be re-issued if it has</span><span class="hljs-comment">// expired.</span><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (refreshToken <span class="hljs-keyword">instanceof</span> ExpiringOAuth2RefreshToken) &#123;ExpiringOAuth2RefreshToken expiring = (ExpiringOAuth2RefreshToken) refreshToken;<span class="hljs-keyword">if</span> (System.currentTimeMillis() &gt; expiring.getExpiration().getTime()) &#123;refreshToken = createRefreshToken(authentication);&#125;&#125;<span class="hljs-comment">//这里将authentication和refreshToken拼成一个accessToken</span>OAuth2AccessToken accessToken = createAccessToken(authentication, refreshToken);tokenStore.storeAccessToken(accessToken, authentication);<span class="hljs-comment">// In case it was modified</span>refreshToken = accessToken.getRefreshToken();<span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;tokenStore.storeRefreshToken(refreshToken, authentication);&#125;<span class="hljs-keyword">return</span> accessToken;</code></pre><p>accessTokens生成逻辑：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> OAuth2AccessToken <span class="hljs-title">createAccessToken</span><span class="hljs-params">(OAuth2Authentication authentication, OAuth2RefreshToken refreshToken)</span> </span>&#123;DefaultOAuth2AccessToken token = <span class="hljs-keyword">new</span> DefaultOAuth2AccessToken(UUID.randomUUID().toString());<span class="hljs-keyword">int</span> validitySeconds = getAccessTokenValiditySeconds(authentication.getOAuth2Request());<span class="hljs-keyword">if</span> (validitySeconds &gt; <span class="hljs-number">0</span>) &#123;token.setExpiration(<span class="hljs-keyword">new</span> Date(System.currentTimeMillis() + (validitySeconds * <span class="hljs-number">1000L</span>)));&#125;token.setRefreshToken(refreshToken);token.setScope(authentication.getOAuth2Request().getScope());<span class="hljs-keyword">return</span> accessTokenEnhancer != <span class="hljs-keyword">null</span> ? accessTokenEnhancer.enhance(token, authentication) : token;&#125;</code></pre><p>这里通过UUID当做构造函数的参数实例化一个DefaultOAuth2AccessToken，然后把相应的刷新令牌，过期时间、scope设上，然后调用之前介绍的TokenEnhancer#enhance增强方法，这里先判断是否配了</p><p>TokenEnhancer，如果配置了就去把生成的token传进去，这里可以往token做一些自定义的东西</p><hr><p>回到DefaultTokenServices#createAccessToken方法中</p><pre><code class="hljs java">OAuth2AccessToken accessToken = createAccessToken(authentication, refreshToken);tokenStore.storeAccessToken(accessToken, authentication);<span class="hljs-comment">// In case it was modified</span>refreshToken = accessToken.getRefreshToken();<span class="hljs-keyword">if</span> (refreshToken != <span class="hljs-keyword">null</span>) &#123;tokenStore.storeRefreshToken(refreshToken, authentication);&#125;</code></pre><p>生成完令牌以后，通过TokenStore进行持久化，然后通过返回的令牌获取refreshToken，如果refreshToken不为空再用TokenStore把refreshToken存一下，然后把这个token返回回去，这里就是生成令牌的一个逻辑，这里涉及到2个东西：TokenStore、TokenEnhancer</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 2.实现标准到OAuth服务器提供商</title>
    <link href="/spring-security-5.2.html"/>
    <url>/spring-security-5.2.html</url>
    
    <content type="html"><![CDATA[<p>因为这里是针对APP进行开发，所以代码大部分是放到App模块中的</p><p>首先将demo模块中pom.xml修改成依赖app模块</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-app<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>，然后它会默认依赖成功、失败处理器，所以先将在会去browser模块中写的处理器复制到这个模块里面，现在暂时先这样，后面再根据业务逻辑进行修改</p><p>成功处理器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.authentication;<span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationSuccessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-keyword">private</span> SecurityProperties security;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span> (security.getBrowser().getLoginType().equals(LoginType.JSON)) &#123;            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(authentication)));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.onAuthenticationSuccess(request, response, authentication);        &#125;    &#125;&#125;</code></pre><p>失败处理器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app.authentication;<span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationFailureHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExceptionMappingAuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-keyword">private</span> SecurityProperties security;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span> (security.getBrowser().getLoginType().equals(LoginType.JSON)) &#123;            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(exception.getMessage())));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.onAuthenticationFailure(request, response, exception);        &#125;    &#125;&#125;</code></pre><p>认证服务器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableAuthorizationServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthorizationServerConfig</span> </span>&#123;        &#125;</code></pre><p>在启动中，控制台上会多出/oauth/xx的地址</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567518323763.png" srcset="/img/loading.gif" alt="1567518323763"></p><p>现在来访问/oauth/authorize路径，这个方法它是需要一些参数的，这里笔者来<a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth2官方网</a>中看一下参数的介绍，在网站中的第4章。现在根据官方网来填写参数，来访问现在来访问<a href="http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=b4c44489-0061-437f-b2c6-5a156251269a&amp;redirect_uri=http://example.com&amp;scope=all，这里的client_id再控制台上打印了" target="_blank" rel="noopener">http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=b4c44489-0061-437f-b2c6-5a156251269a&amp;redirect_uri=http://example.com&amp;scope=all，这里的client_id再控制台上打印了</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567518956135.png" srcset="/img/loading.gif" alt="1567518956135"></p><p>现在浏览器中会出现这个弹框：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567519655298.png" srcset="/img/loading.gif" alt="1567519655298"></p><p>现在我这里扮演了一个服务提供商的角色，这里的client_id是提供给给第三方让它去引导用户来授权的，作为我来说我需要知道三件事：</p><ul><li>哪个应用在请求授权，这里的client_id就是来区分的，每个应用在我这来注册时，我都分一个不同的client_id给他们</li><li>你在请求我的哪个用户给你授权，这里请求上面的地址会弹出一个basic对话框，在这个框中的用户名就是来告诉我你是我系统中的哪个用户在授权</li><li>给第三方什么授权，通过地址上面的scope参数来区分，这个参数是服务商自己定义了，可以定义任意的字符串，然后第三方请求的时候，根据这个服务提供商的规则带着字符串来告诉服务提供商我需要什么样的权限</li></ul><p>在这里的对话框填写的用户名、密码最终会交给UserDetailsService，用它去校验，这里我们之前就写过了</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security.service;<span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span>, <span class="hljs-title">SocialUserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-function"><span class="hljs-keyword">private</span> SocialUser <span class="hljs-title">buildUser</span><span class="hljs-params">(String username)</span> </span>&#123;        String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialUser(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string">"表单登录用户-&gt;&#123;&#125;进行效验"</span>, username);        <span class="hljs-keyword">return</span> buildUser(username);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SocialUserDetails <span class="hljs-title">loadUserByUserId</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string">"社交登录用户id-&gt;&#123;&#125;进行效验"</span>, userId);        <span class="hljs-keyword">return</span> buildUser(userId);    &#125;&#125;</code></pre><p>上面代码中，密码一定要是123，账号是随便填的，在对话框中按照这个来填，然后浏览器想显示的内容：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567519813050.png" srcset="/img/loading.gif" alt="1567519813050"></p><p>在默认情况下，在UserDetailsService中返回的UserDetails需要有user这样的角色才行，这里在McrUserDetailsService中修改一下</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SocialUser <span class="hljs-title">buildUser</span><span class="hljs-params">(String username)</span> </span>&#123;     String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialUser(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin,ROLE_USER"</span>)); &#125;</code></pre><hr><p>然后重启一下，但是这里的client_id是在控制台出现的，而重启之后又会变，这里配置一下yum，让它变成一个固定的</p><pre><code class="hljs yml"><span class="hljs-attr">security:</span>  <span class="hljs-attr">oauth2:</span>    <span class="hljs-attr">client:</span>      <span class="hljs-attr">client-id:</span> <span class="hljs-string">mcr</span>      <span class="hljs-attr">client-secret:</span> <span class="hljs-string">mcr</span></code></pre><p>现在访问<a href="http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=mcr&amp;redirect_uri=http://example.com&amp;scope=all，浏览器显示：" target="_blank" rel="noopener">http://localhost:8080/oauth/authorize?response_type=code&amp;client_id=mcr&amp;redirect_uri=http://example.com&amp;scope=all，浏览器显示：</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567520336913.png" srcset="/img/loading.gif" alt="1567520336913"></p><p>这只是Oauth授权的页面，这相对于我们之前用QQ授权看到的那个QQ的页面，在这里可以决定同意授权和拒绝授权，在这里它问mcr请求你给它all这样的权限，这里选择第一个单选按钮同意，点击Authorize按钮确认，在这里就会跳转到redirect_uri的页面上去并且在url上带了授权码，这个页面可以理解为第三方的页面，它拿到了授权码以后，它应该去拿这个授权码来换accessToken</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567521410778.png" srcset="/img/loading.gif" alt="1567521410778"></p><p>换取认证码需要通过post请求方式访问<code>/oauth/token</code>地址并带上授权码参数，这里使用之前介绍的 工具或使用post man来访问这个地址，在这里的请求头中需要给Authorization填写以下内容：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567521606320.png" srcset="/img/loading.gif" alt="1567521606320"></p><p>然弹出这个，Username根据在yml中配置的client-id配置，密码根据client-secret的配置，我在yml中这2个都配的是mcr，所以就都填mcr</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567521634226.png" srcset="/img/loading.gif" alt="1567521634226"></p><p>然后根据之前说的OAuth2官方文章填写相关的参数</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567521749036.png" srcset="/img/loading.gif" alt="1567521749036"></p><p>在这里面填写</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567521766712.png" srcset="/img/loading.gif" alt="1567521766712"></p><p>然后点击Send提交，响应出这么一段json</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"f776ca27-ee02-4b90-b7ad-0fc2b0d9d539"</span>,<span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,<span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"df5415e9-5251-43ec-a2cc-74fd3c02d26c"</span>,<span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">43199</span>,<span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span>&#125;</code></pre><p>这样的授权码模式授权的流程就走完了，下面来介绍密码授权模式，它访问的地址后前面访问的地址是一样的，也是<code>/oauth/token</code>，这里的请求头中也要带上Authorization信息，但是它这里的参数是不一样的：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567522099570.png" srcset="/img/loading.gif" alt="1567522099570"></p><p>在密码模式中，用户是把服务提供商上的用户名和密码告诉第三方，然后第三方拿着用户名密码告诉他的用户名密码去到服务提供商那说用户给了我授权了，那么这里服务提供商是没法判断，这用户名密码是用户真正给你的还是自己偷的，在一个互联网的场景下，比如说我和QQ之间，那么使用这种模式是有问题的，因为QQ不能判断你的用户名密码到底是怎么来的，但是在我们这个场景里，这种授权方式是可用的，因为在我这个场景里，我是扮演服务提供商的角色，而扮演第三方的角色是自己公司的App，我们之间是一伙的，我是可以让用户把用户名密码告诉App，然后他们拿着用户名密码换token，所以这个授权模式在自己公司的app和自己公司的服务器之间采用这种授权模式换token是可行的，现在会到工具里，发送请求的响应：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"access_token"</span>: <span class="hljs-string">"f776ca27-ee02-4b90-b7ad-0fc2b0d9d539"</span>,<span class="hljs-attr">"token_type"</span>: <span class="hljs-string">"bearer"</span>,<span class="hljs-attr">"refresh_token"</span>: <span class="hljs-string">"df5415e9-5251-43ec-a2cc-74fd3c02d26c"</span>,<span class="hljs-attr">"expires_in"</span>: <span class="hljs-number">42570</span>,<span class="hljs-attr">"scope"</span>: <span class="hljs-string">"all"</span>&#125;</code></pre><p>这里的access_token和之前的授权码模式拿到的access_token是一样的，包括<code>df5415e9-5251-43ec-a2cc-74fd3c02d26c</code>这些，虽然用的授权模式不同，但是我用的是同一个用户，同一个用户反复去请求的时候<code>spring security oauth</code>会判断当前用户是不是发过<code>access_token</code>，这里因为在授权码模式中使用root账号发过一个<code>/oauth/token</code>，然后在密码模式中再来请求<code>/oauth/token</code>，它任然会把一样的token发给它，只要这个<code>token</code>还没过期，同一个用户来请求令牌时候，<code>spring security oauth</code>种会发同一个令牌下去</p><hr><p>现在笔者演示了2种授权码模式，剩下的2种就不演示了，这里实际上已经实现了4种授权码模式，那么我们写的代码应该还有印象，就在一个类上加了一个注解，就完成了这些功能，后面的案例会将怎么来做定制化的东西，在这里就先用<code>spring security oauth</code>的标准实现</p><hr><p>现在认证服务器已经实现了，接下来实现资源服务器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.app;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableResourceServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrResourceServerConfig</span> </span>&#123;&#125;</code></pre><blockquote><p>先来来访问之前写的rest api：<a href="http://localhost:8080/user/me，响应内容：" target="_blank" rel="noopener">http://localhost:8080/user/me，响应内容：</a></p></blockquote><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567523445358.png" srcset="/img/loading.gif" alt="1567523445358"></p><p>在这里的状态码是401，意思是没有做身份认证，那么要做身份认证的话就要把刚才的token带上就行了，但是现在不能用之前拿到的token，因为现在没有配token的存储模式，实际上默认情况下它是存在内存里的，刚刚因为加了一个类，我重启了服务器，内存中的信息都已经清掉了，所以要重新在请求一下<code>/oauth/token</code>来获取新的<code>access_token</code>，将这个信息填写到要访问的<code>rest api</code>的header中，key为:Authorization，值的话光是一个<code>access_token</code>还不行，前面还要加上获取的<code>token_type</code>的值</p><p>就像这样：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567523833496.png" srcset="/img/loading.gif" alt="1567523833496"></p><p>然后再去发送，就能正常的拿到信息了</p><hr><p>oauth的流程发token，然后用token来效验身份，访问服务，这样一个流程就已经走通了，现在虽然流程走通了，但是我们是按照oauth协议标准的规范和spring security的默认实现来走的，这里面存在很多问题，首先我的认证方式只能是oauth协议规定的这4种授权模式，比如我现在想通过手机号码+短信验证码来登录，输入这些之后，在我们服务器中进行验证，验证成功以后，发他一个access_token，这个在默认设置和实现里面我是实现不了的，其他的比如说现在access_token是存在内存里的，服务器已重启就没了，服务器发出去的token它的这个样子是随机生成的串，那么能不能去定制它，比如用现在流行的jwt来做我们这里的token，等等一系列问题，在后面的章节去 介绍给大家</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 五、OAuth 】 1.Spring Security OAuth简介</title>
    <link href="/spring-security-5.1.html"/>
    <url>/spring-security-5.1.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567510663145.png" srcset="/img/loading.gif" alt="1567510663145"></p><p>之前的登录的认证信息是存储到<code>session</code>中的，用户通过浏览器每次去访问服务时，每次都会检查浏览器的cookie里是否存在<code>JSessionID</code>，如果不存在就会在服务器上新建<code>session</code>，把这个<code>sesion id</code>写到浏览器的cookie里，这样用户每次通过浏览器去发请求的时候，我们系统会根据用户浏览器中的<code>JSessionID</code>找到相应的session拿出来，这个是之前开发中基于服务器session一种保存用户信息的一种登录方式，随着技术不断发展，一种新的前端技术渠道出现了，我们常用的手机APP，除了这种APP以外，本身的部署方式也在演进，现在比较流程的方式：前后端分离，在前后端分离的时候，html不在和服务器放在一块部署，它会单独放到一个web server上，在采用前后分离的架构的时候，用户直接访问的是web server，针对这个html一些渲染、ajax请求的一些处理，都是由web server来完成，ajax请求发给web server以后，web server再去访问application server来拿数据，不管是手机APP、还是前后端分离当架构演变成这样子的时候，一个最根本的变化出现了：用户不在是通过浏览器直接访问我们的应用，而是通过第三方的应用，例如app、web server访问我们的应用的服务器，不在是浏览器，而是一些其他的应用，这时候在使用之前的cookie session的方式就会出现一些问题，首先明确一点，当在前后分离架构下，是否能用cookie+sesison这种方式，答案是可以的，但是它在app中会有一些问题：</p><ul><li>开发繁琐：在浏览器中cookie这种功能是自带的，我们在开发的时候不需要针对cookie去写太多代码，对于app来说，app每次关闭再打开以后，你要重新在代码里面去实例化http的客户端，去发请求，每次去发http，客户端都是空的，都是初始化的状态，所以需要处理cookie之前存的数据</li><li>安全性和用户体验差：基于cookie+session这种方式，它的验证工作都是服务器自己去做的，其实也没有什么验证工作，拿过来的这个请求，cookie里有session id，那么就直接从session里拿东西，就认为你登录了，没有所谓再去验什么东西，这时候就导致，如果你的JSessionID别了知道了，他用这个JSessionID放到cookie里，就可以直接获取用户身份，这里有人会想到可以把session的失效时间设断一点，但是这回导致用户频繁重新登录。</li><li>有些前端的技术不支持cookie、如小程序</li></ul><p>由于存在这些问题，当访问者不在是浏览器，而是一些应用的时候，我们就应该使用另外一种方式来处理用户的认证信息的存储，这个方式就是令牌的方式，在spring social将的那种，也就是token，其实它的原理和session的原理差不多，它也是要给用户一个唯一标识，只不过在session的方式下，我是往浏览器的cookie里去写一个JSessionID，而令牌的方式，我是直接发给用户一个token，用户每次访问都要带着这个令牌，而我们这的应用服务器不在把用户信息存储再session中，而是根据用户每次请求带着这个令牌来判断他是谁，他有什么权限。令牌的表现形式是一个字符串，当采用令牌这种方式时候，我前面说的这些问题它都会得到一个解决：</p><ul><li>解决开发繁琐：因为令牌发给app以后，app每次发请求带着这个令牌它不是通过cookie来带的，而是http请求的参数，它就像带一个普通参数一样带上就可以了，不需要针对令牌专门去写cookie的代码</li><li>解决安全性和客户体验差：在session方式中，写JSessionID是由服务器来完成的，我们是没法去干涉的，但是用token这种方式， token怎么来生成、里面包含的信息、我们怎么来校验这些我们都是可以来控制的，所以我们可以在这个令牌加很多技术手段来增强它的安全性。基于session来解决安全问题会导致用户频繁登录，基于token的方式我们就可以设计一种token刷新的机制，在三方登录的时候也能看到，你在完OAuth流程以后它会给一个token，还会给你一个refresh token，这个refresh token就可以让用户在没有感觉的情况下去刷新令牌，不需要用户频繁登录，这样既可以保证用户的安全性还可以保证用户的体验</li><li>解决有些前端的技术不支持cookie：这里不使用cookie，这个问题就不存在了</li></ul><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567224896676.png" srcset="/img/loading.gif" alt="1567224896676"></p><p>说到这，现在做认证的方式就变成了发令牌的方式在自己的应用和其他应用之间完成授权，说到这里，相信读者脑海里第一个想到的就是之前在spring social介绍的OAuth协议，它授权的方式就是令牌，在现在的场景中，我们就变成了服务提供商，现在的app和前后端分离中的前端就变成了第三方应用，我只要给它们发令牌，它们拿到令牌来访问我，我这里来验这个令牌就可以了，之前说得spring social中封装的是第三方应用client它所要做的事情，使用它可以很快开发第三应用角色的应用，去连任意一个我想连的服务提供商，而这里说的spring oauth则是封装了服务提供商所要完成的绝大部分行为，使用它就可以快速搭建起一个服务提供商的程序来。</p><hr><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567511400096.png" srcset="/img/loading.gif" alt="1567511400096"></p><p>要实现oauth服务提供商这个角色，它的所有功能，实际上就实现2个服务器，也就是之前说的认证服务器和资源服务器，</p><ul><li>在认证服务器中有两大范式<ul><li>实现我们之前介绍的oauth协议中的授权模式（授权码模式、密码模式、客户端模式、简化模式），通过这4种授权模式让我们的应用来确认用户的身份以后用户拥有的权限，在spring security oauth把这4种授权模式都替我们实现了，这4种授权模式实现了以后，通过这4种模式知道用户的身份后权限以后，根据这些信息来生成和存储这些令牌，这里的生成和存储没有明确的规定，token要按照什么规则来生成，但在spring security oauth中默认定制了一套生成规则，按照它的想法做的实现 </li></ul></li><li>资源服务器就是来保护资源，在我们的场景下，我们要保护的资源是什么，就是值我们写的rest服务，怎么来保护这些服务呢？按目前用的spring security，它是在资源之前加个过滤器链，spring security oauth是如何来实现资源服务器的功能呢？它是在spring security过滤器链上加了一个新的过滤器：OAuth2AuthenticationProcessingFilter，这个过滤器会在请求中拿出你发出去的token，因为你发出去的token，第三方应用它在调你到rest服务的时候，一定会带着token过来，这个过滤器作用从那个请求中把带着的token拿出来，根据你配的存储策略去存储里找到token对应的用户信息，然后判断用户信息是否存在、是否有权限等等一系列判断来决定它最终是否能访问你的rest服务，这样就实现了资源服务器的功能</li></ul><p>在这个场景下面还要一个最终问题：我们不希望让用户去走这4种标准的授权模式的，比如说我的手机号和短信验证码登录方式，它跟这标准的4种授权模式是搭不上的，标准的授权模式是没有让你输入手机号、输入短信就发一个token给你，我们要做的额外事情就是让我们自定义这种认证方式，它也可以嫁接到认证服务器上去，让用户名+密码、手机号+短信验证码、第三方认证通过这些认证以后它也可以去调这个token生成的机制来生成token来，发给三方应用，一旦实现这个事情，我们整个流程就跑同了，我的第三方应用就可以引导用户走我们自定义到认证，成功了以后发一个token给第三方，第三方拿到这个token，每次去访问服务的时候，带着这个token，通过过滤器链上的过滤器来认证，来获取授权等…，这样前面描述的场景通过这种方式就实现了，在上面图中，绿色部分都是spring security实现好的，红色的部分是我们自己写的代码，我们自己写的代码里面，资源这一块是不用改的，它是标准的rest服务，要改的地方就是之前说的3种认证方式，把它做一个修改</p><hr><p>内容简介</p><ul><li>实现一个标准的oauth2协议中provider角色的主要功能</li><li>重构之前三种认证方式的代码，使其支持token</li><li>高级特性</li></ul>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 四、Session 】 1.Session管理</title>
    <link href="/spring-security-4.1.html"/>
    <url>/spring-security-4.1.html</url>
    
    <content type="html"><![CDATA[<h1 id="单机Session管理"><a href="#单机Session管理" class="headerlink" title="单机Session管理"></a>单机Session管理</h1><p>之前了解很多种登录方式，虽然它们的方式不同，但是它们有一个共同点，最终登录成功以后用户信息是放到服务器的session中的，在这里来介绍Session管理</p><hr><h2 id="Session超时处理"><a href="#Session超时处理" class="headerlink" title="Session超时处理"></a>Session超时处理</h2><p>session是有超时时间的，不同的应用session超时时间不一样，可能1小时、2小时，那么session干掉以后，用户在进行操作会怎么样？怎么来处理？</p><hr><p>yml：</p><p>这里将超时时间设置为10秒，当用户10秒不进行操作，session就会失效</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">session:</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">10</span></code></pre><p>下面来看一下实际情况，现在进行登录，然后10秒不操作，访问请求，任然可以访问，这就说明session没有失效，身份信息还在session中，那么为什么会出现这种情况，来看一下spring boot的代码，TomcatEmbeddedServletContainerFactory#configureSession：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureSession</span><span class="hljs-params">(Context context)</span> </span>&#123;<span class="hljs-keyword">long</span> sessionTimeout = getSessionTimeoutInMinutes(); <span class="hljs-comment">//获取yml中配置的超时时间</span>context.setSessionTimeout((<span class="hljs-keyword">int</span>) sessionTimeout);<span class="hljs-keyword">if</span> (isPersistSession()) &#123;Manager manager = context.getManager();<span class="hljs-keyword">if</span> (manager == <span class="hljs-keyword">null</span>) &#123;manager = <span class="hljs-keyword">new</span> StandardManager();context.setManager(manager);&#125;configurePersistSession(manager);&#125;<span class="hljs-keyword">else</span> &#123;context.addLifecycleListener(<span class="hljs-keyword">new</span> DisablePersistSessionListener());&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getSessionTimeoutInMinutes</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">long</span> sessionTimeout = getSessionTimeout();<span class="hljs-keyword">if</span> (sessionTimeout &gt; <span class="hljs-number">0</span>) &#123;      <span class="hljs-comment">//将秒转换成了分钟数，然后它拿秒数转换的分钟数和1做比较，然后去取它的最大值，也就是你设置的过期时间最少要是1分钟，</span>sessionTimeout = Math.max(TimeUnit.SECONDS.toMinutes(sessionTimeout), <span class="hljs-number">1L</span>); &#125;    <span class="hljs-comment">//它返回去的sessionTimeout是以分钟为单位的数值</span><span class="hljs-keyword">return</span> sessionTimeout;&#125;</code></pre><p>在spring boot里session的超时时间最少为1分钟，你设置的比1分钟少，它也会给你设置一分钟，这里我说了这么久，就是在拖这1分钟（嘻嘻），现在1分钟过期了后头在来访问，就会响应出：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"content"</span>: <span class="hljs-string">"请引导用户跳转到登录页面"</span>&#125;</code></pre><p>这就代表放到session里的用户信息没有了，说明session失效了</p><hr><p>在某些情况下，我们可能需要给用户一个特殊的提示，告诉用户你的session失效了所以你要重新登录，而上面的响应式不友好的，它这里没说明你是没有登录、还是登录了session过期了需要重新登录，这个它是区分不出来了，所以在这里做一个更细化的处理</p><hr><p>session过期之后，再次访问，会跳转到/session/invalid地址</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    http.sessionManagement()            .invalidSessionUrl(<span class="hljs-string">"/session/invalid"</span>)              .antMatchers(                    <span class="hljs-string">"/session/invalid"</span>,</code></pre><p>BrowserSecurityController：</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/session/invalid"</span>)    <span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)    <span class="hljs-function"><span class="hljs-keyword">public</span> McrSecurityVO <span class="hljs-title">sessionInvalid</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrSecurityVO(<span class="hljs-string">"sessions失效"</span>);    &#125;</code></pre><p>这里直接重启服务器，session就全部失效了，响应内容：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"content"</span>: <span class="hljs-string">"sessions失效"</span>&#125;</code></pre><h2 id="Session并发控制"><a href="#Session并发控制" class="headerlink" title="Session并发控制"></a>Session并发控制</h2><p>在有些网站可能会有这样的需求：用户在A机器上登录了以后，过了一段时间，他在B机器上也登录了，在B机器上登录了时候，如果A机器报退出，要把A机器的登录，session给是失效掉，也就是后面的session踢处前面的sesion</p><hr><p>为了方便测试，将过期时间改一下</p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>  <span class="hljs-attr">session:</span>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">600</span></code></pre><hr><pre><code class="hljs java">http.sessionManagement()              .invalidSessionUrl(<span class="hljs-string">"/session/invalid"</span>)              .maximumSessions(<span class="hljs-number">1</span>)</code></pre><p>maximumSessions：最大的session数量，同一个用户，它后面的登录所产生的session，就会把之前登录所产生的session给失效掉，然后前面的用户再去访问会响应：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"content"</span>: <span class="hljs-string">"sessions失效"</span>&#125;</code></pre><p>这里应该提示用户被其他地方登录，这里有是提供了相应的处理的</p><p>这里可以在服务器端做一个记录，可以去实现<code>SessionInformationExpiredStrategy</code>接口，</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent eventØ)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException</span>;&#125;</code></pre><p>SessionInformationExpiredStrategy接口实现类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.session;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> org.springframework.security.web.session.SessionInformationExpiredEvent;<span class="hljs-keyword">import</span> org.springframework.security.web.session.SessionInformationExpiredStrategy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrExpiredSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent eventØ)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;         eventØ.getResponse().setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);        eventØ.getResponse().getWriter().write(<span class="hljs-string">"并发登录！"</span>);    &#125;&#125;</code></pre><hr><p>BrowserSecurityConfig：</p><pre><code class="hljs java">http.sessionManagement()         .invalidSessionUrl(<span class="hljs-string">"/session/invalid"</span>)         .maximumSessions(<span class="hljs-number">1</span>)         .expiredSessionStrategy(<span class="hljs-keyword">new</span> McrExpiredSessionStrategy())</code></pre><hr><p>现在拿2个浏览器登录同一个账号，前面一个相应：</p><pre><code class="hljs plain">并发登录！</code></pre><hr><p>现在需求变了：不是把前面的T掉，而是不让第二个用户登录</p><p>BrowserSecurityConfig：</p><pre><code class="hljs java"><span class="hljs-comment">//当session达到最大的以后，阻止掉后来的登录行为  </span>.maximumSessions(<span class="hljs-number">1</span>).maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>)</code></pre><p>第2个用户登录时浏览器响应：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"content"</span>:<span class="hljs-string">"Maximum sessions of 1 for this principal exceeded"</span>&#125;</code></pre><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>现在的代码：</p><pre><code class="hljs java">http.sessionManagement()             .invalidSessionUrl(<span class="hljs-string">"/session/invalid"</span>)             .maximumSessions(<span class="hljs-number">1</span>).maxSessionsPreventsLogin(<span class="hljs-keyword">true</span>)             .expiredSessionStrategy(<span class="hljs-keyword">new</span> McrExpiredSessionStrategy())  <span class="hljs-comment">//..</span>    .antMatchers(                     <span class="hljs-string">"/session/invalid"</span>,</code></pre><p>现在这样是不行的，因为这个代码是一个公共的模块，在使用者将这些代码导入它的工程中，是无法进行修改的，比如这里的<code>/session/invalid</code>,它返回的是json，那么使用者的项目可能没有使用前后分离，就没必要使用json，他跟希望这里的处理能跳转到一个页面上去，</p><p>McrExpiredSessionStrategy响应的内容，他也无法去修改，这些都是不合理的，这里将这些进行重构</p><hr><p>首先将这些配置使用户通过yml进行控制：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SessionProperties</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同一个用户在系统中的最大session数，默认1</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maximumSessions = <span class="hljs-number">1</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 达到最大session时是否阻止新的登录请求，默认为false，不阻止，新的登录会将老的登录失效掉</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> maxSessionsPreventsLogin;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * session失效时跳转的地址</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String sessionInvalidUrl = SecurityConstants.DEFAULT_SESSION_INVALID_URL;&#125;</code></pre><p>BrowserSecurityProperties：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * session相关配置</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> SessionProperties session = <span class="hljs-keyword">new</span> SessionProperties();</code></pre><p>session失效、session并发：判断当前访问url的地址是不是.html结尾的，如果是，就跳转到指定的URL去，如果不是则响应json，它们2个分别配置invalidSessionStrategy和expiredSessionStrategy，它们两个的逻辑，因为在我们这里非常相识，所以我们这里先创建一个抽象类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.session;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.vo.McrSecurityVO;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<span class="hljs-keyword">import</span> org.springframework.security.web.DefaultRedirectStrategy;<span class="hljs-keyword">import</span> org.springframework.security.web.RedirectStrategy;<span class="hljs-keyword">import</span> org.springframework.security.web.util.UrlUtils;<span class="hljs-keyword">import</span> org.springframework.util.Assert;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractSessionStrategy</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 跳转的url</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String destinationUrl;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 重定向策略</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> RedirectStrategy redirectStrategy = <span class="hljs-keyword">new</span> DefaultRedirectStrategy();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 跳转前是否创建新的session</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> createNewSession = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invalidSessionUrl 跳转地址</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractSessionStrategy</span><span class="hljs-params">(String invalidSessionUrl)</span> </span>&#123;        Assert.isTrue(UrlUtils.isValidRedirectUrl(invalidSessionUrl), <span class="hljs-string">"url must start with '/' or with 'http(s)'"</span>);        <span class="hljs-keyword">this</span>.destinationUrl = invalidSessionUrl;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * (non-Javadoc)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @see org.springframework.security.web.session.InvalidSessionStrategy#</span><span class="hljs-comment">     * onInvalidSessionDetected(javax.servlet.http.HttpServletRequest,</span><span class="hljs-comment">     * javax.servlet.http.HttpServletResponse)</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSessionInvalid</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-keyword">if</span> (createNewSession) &#123;            request.getSession();        &#125;        String sourceUrl = request.getRequestURI();        String targetUrl;        <span class="hljs-keyword">if</span> (StringUtils.endsWithIgnoreCase(sourceUrl, <span class="hljs-string">".html"</span>)) &#123;            targetUrl = destinationUrl + <span class="hljs-string">".html"</span>;            logger.info(<span class="hljs-string">"session失效,跳转到"</span> + targetUrl);            redirectStrategy.sendRedirect(request, response, targetUrl);        &#125; <span class="hljs-keyword">else</span> &#123;            String message = <span class="hljs-string">"session已失效"</span>;            <span class="hljs-keyword">if</span> (isConcurrency()) &#123;                message = message + <span class="hljs-string">"，有可能是并发登录导致的"</span>;            &#125;            response.setStatus(HttpStatus.UNAUTHORIZED.value());            response.setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(message)));        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * session失效是否是并发导致的</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConcurrency</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Determines whether a new session should be created before redirecting (to</span><span class="hljs-comment">     * avoid possible looping issues where the same session ID is sent with the</span><span class="hljs-comment">     * redirected request). Alternatively, ensure that the configured URL does</span><span class="hljs-comment">     * not pass through the &#123;<span class="hljs-doctag">@code</span> SessionManagementFilter&#125;.</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> createNewSession defaults to &#123;<span class="hljs-doctag">@code</span> true&#125;.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCreateNewSession</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> createNewSession)</span> </span>&#123;        <span class="hljs-keyword">this</span>.createNewSession = createNewSession;    &#125;&#125;</code></pre><p>session过期策略：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.session;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> org.springframework.security.web.session.InvalidSessionStrategy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrInvalidSessionStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvalidSessionStrategy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrInvalidSessionStrategy</span><span class="hljs-params">(String invalidSessionUrl)</span> </span>&#123;        <span class="hljs-keyword">super</span>(invalidSessionUrl);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onInvalidSessionDetected</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        onSessionInvalid(request, response);    &#125;&#125;</code></pre><p>session并发策略：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.session;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> org.springframework.security.web.session.SessionInformationExpiredEvent;<span class="hljs-keyword">import</span> org.springframework.security.web.session.SessionInformationExpiredStrategy;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrExpiredSessionStrategy</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSessionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrExpiredSessionStrategy</span><span class="hljs-params">(String invalidSessionUrl)</span> </span>&#123;        <span class="hljs-keyword">super</span>(invalidSessionUrl);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onExpiredSessionDetected</span><span class="hljs-params">(SessionInformationExpiredEvent event)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        onSessionInvalid(event.getRequest(), event.getResponse());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConcurrency</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>这里的2个策略，不能直接配置在BrowserSecurityConfig中，因为可能我们提供的这2个策略不满足使用者的需求，这里通过ConditionalOnMissingBean注解去判断使用者是否有实现InvalidSessionStrategy类注入到IOC容器中，如果有就用使用者自己的，如果没有就用我们默认的</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-keyword">import</span> com.b4.mcr.auth.browser.session.McrExpiredSessionStrategy;<span class="hljs-keyword">import</span> com.b4.mcr.auth.browser.session.McrInvalidSessionStrategy;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.SecurityProperties;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.web.session.InvalidSessionStrategy;<span class="hljs-keyword">import</span> org.springframework.security.web.session.SessionInformationExpiredStrategy;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityBeanConfig</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(InvalidSessionStrategy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">InvalidSessionStrategy</span> <span class="hljs-title">invalidSessionStrategy</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrInvalidSessionStrategy(securityProperties.getBrowser().getSession().getSessionInvalidUrl());    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(SessionInformationExpiredStrategy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">SessionInformationExpiredStrategy</span> <span class="hljs-title">sessionInformationExpiredStrategy</span>() </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrExpiredSessionStrategy(securityProperties.getBrowser().getSession().getSessionInvalidUrl());    &#125;&#125;</code></pre><p>BrowserSecurityConfig：</p><pre><code class="hljs java"> <span class="hljs-keyword">private</span> InvalidSessionStrategy invalidSessionStrategy;    <span class="hljs-keyword">private</span> SessionInformationExpiredStrategy sessionInformationExpiredStrategy;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">//...</span>           http.sessionManagement()                .invalidSessionStrategy(invalidSessionStrategy)                .maximumSessions(browser.getSession().getMaximumSessions()).maxSessionsPreventsLogin(browser.getSession().isMaxSessionsPreventsLogin())                .expiredSessionStrategy(sessionInformationExpiredStrategy)<span class="hljs-comment">//...</span>&#125;</code></pre><h1 id="集群Session管理"><a href="#集群Session管理" class="headerlink" title="集群Session管理"></a>集群Session管理</h1><p>在默认的情况下，我们的session是放在中间件服务器里面的，比如tomcat、websocket之类的服务器，那么当我们的系统部署成集群的时候就会有一些问题：比如前面负载均衡的时候，你的登录请求可能发到你集群的A机器上，然后他登录以后，把登录信息放到A机器的session上，后续的请求数据的服务它可能会发到B机器上，而B机器的session并没有你A机器里面的session登录信息，所以B机器会要求用户再登录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567351628532.png" srcset="/img/loading.gif" alt="1567351628532"></p><p>如何一个当用的软件，放在互联网上给用户用的时候，它都会至少部署2台机器，因为如果只部一台那么这太机器出问题了，你的服务就中断了，这对于大多数公司来说是一个很严重的生产事故，是不能接收的，所以会部一个集群，至少2台机器，前面有一个负载均衡，前面有一台机器down了，还有另一个还可以为用户提供服务，在这个环境下，基于session的身份认证就会有一个问题：用户的登录请求是发到Server1上的，那么session也是跟着服务器走的，所以当用户登录成功以后，它的经过认证的SecurityContext、Authentication都是放到Server1的session里面的，那么在后续的用户发送请求中，如果你前面的负载均衡没有做一些特殊处理，它可能会发到Server2上，那么当后面的请求发到Server2上的时候，你Server2上的session并没有你之前在Server1上放的那些经过认证的信息，那么Server2就会拒绝掉你的服务请求，让你再去登录一遍，这个就是我们就是要解决的一个问题：在集群环境下处理session，解决方案很简单：不把session放到服务器上，而把它抽取出来，就象图2那样，Server1、Server2依然是集群对外提供环境，但是我不在每一个服务器上单独去管理自己的session，而把session这些信息抽取出来放在独立测存储中，这样用户发了一个登录请求，发往Server1的时候，Server1经过认证以后它是把信息所对应的session放到了一个独立的存储里面，这事情后续的请求如果发到Server2上，Server2在校验用户请求的时候，它从session拿信息的时候，它也是从存储里面去找session信息，这时候就解决了图1的问题。</p><hr><p>在spring中专门有一个项目替我们来完成这个事情，在browser的pom.xml中的这个依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>它的作用就是来完成上面说的工作，我们只需要告诉它你后面采用的存储是什么以及存储所在的地址和端口就可以了，spring session它支持哪些存储呢？</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012-2016 the original author or authors.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span><span class="hljs-comment"> * you may not use this file except in compliance with the License.</span><span class="hljs-comment"> * You may obtain a copy of the License at</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span><span class="hljs-comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="hljs-comment"> * See the License for the specific language governing permissions and</span><span class="hljs-comment"> * limitations under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> org.springframework.boot.autoconfigure.session;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Supported Spring Session data store types.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Tommy Ludwig</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Eddú Meléndez</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.4.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> StoreType &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Redis backed sessions.</span><span class="hljs-comment"> */</span>REDIS,<span class="hljs-comment">/**</span><span class="hljs-comment"> * Mongo backed sessions.</span><span class="hljs-comment"> */</span>MONGO,<span class="hljs-comment">/**</span><span class="hljs-comment"> * JDBC backed sessions.</span><span class="hljs-comment"> */</span>JDBC,<span class="hljs-comment">/**</span><span class="hljs-comment"> * Hazelcast backed sessions.</span><span class="hljs-comment"> */</span>HAZELCAST,<span class="hljs-comment">/**</span><span class="hljs-comment"> * Simple in-memory map of sessions.</span><span class="hljs-comment"> */</span>HASH_MAP,<span class="hljs-comment">/**</span><span class="hljs-comment"> * No session data-store.</span><span class="hljs-comment"> */</span>NONE;&#125;</code></pre><p>上面是spring session所支持的存储类型，这里我们使用redis来进行演示</p><p>安装redis：</p><pre><code class="hljs bash">docker run --name redis -p 6379:6379 -d redis:3.2</code></pre><p>为什么要使用redis呢？因为session它是一个非常频繁访问的东西，因为spring security它的原理是在你请求之前加一个过滤器链，所有的请求都会过这个过滤器链，然后每个请求过这个过滤器链的时候都会从session里去读SecurityContext,那么如果这里使用JDBC，也就是数据里，那么这个读取的压力就非常大，因为每个请求都会去读数据，session它本身是有一个失效性的，如果你把session存到数据库里面，还要自己清理它，去维护里面的数据，而redis它本身带有一个超时的特性，你把数据带进去就可以设置超时时间，到了这个时间，数据就清了。虽然使用JDBC，spring session也会清，但是redis性能更好一些</p><hr><p> yml：</p><pre><code class="hljs yml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">session:</span>    <span class="hljs-attr">store-type:</span> <span class="hljs-string">redis</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-string">mcr.com</span></code></pre><p>来到登录页的时候，会引发一个问题，图形验证码没出来。现在控制台上报了一个异常：</p><pre><code class="hljs css"><span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.serializer</span><span class="hljs-selector-class">.SerializationException</span>: <span class="hljs-selector-tag">Cannot</span> <span class="hljs-selector-tag">serialize</span>; <span class="hljs-selector-tag">nested</span> <span class="hljs-selector-tag">exception</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.serializer</span><span class="hljs-selector-class">.support</span><span class="hljs-selector-class">.SerializationFailedException</span>: <span class="hljs-selector-tag">Failed</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">serialize</span> <span class="hljs-selector-tag">object</span> <span class="hljs-selector-tag">using</span> <span class="hljs-selector-tag">DefaultSerializer</span>; <span class="hljs-selector-tag">nested</span> <span class="hljs-selector-tag">exception</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalArgumentException</span>: <span class="hljs-selector-tag">DefaultSerializer</span> <span class="hljs-selector-tag">requires</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">Serializable</span> <span class="hljs-selector-tag">payload</span> <span class="hljs-selector-tag">but</span> <span class="hljs-selector-tag">received</span> <span class="hljs-selector-tag">an</span> <span class="hljs-selector-tag">object</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-attr">[com.b4.mcr.auth.core.model.dto.ImageCodeDTO]</span></code></pre><p>这里说ImageCodeDTO序列化出了问题，它需要一个可序列化的类型，原因是ImageCodeDTO没有实现Serializable接口，为什么会报这个错，原因是session现在已经放到redis里面去管理了，生成图形验证码有一步是把生成的图形验证码放到session里面去，然后后面再发请求的时候再从session里拿出来验，这时候放到session实际上就是放到redis里</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567423581144.png" srcset="/img/loading.gif" alt="1567423581144"></p><p>放到redis里的东西都需要是可序列化的，这里把ValidateCodeDTO、ImageCodeDTO实现Serializable接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCodeDTO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidateCodeDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">ValidateCodeDTO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span></span></code></pre><p>实现Serializable接口以为，这里的属性也要实现Serializable接口，但是这里的ImageCodeDTO中用了一个BufferedImage的对象，这个对象是JDK提供的一个类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferedImage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">java</span>.<span class="hljs-title">awt</span>.<span class="hljs-title">Image</span></span><span class="hljs-class">                           <span class="hljs-keyword">implements</span> <span class="hljs-title">WritableRenderedImage</span>, <span class="hljs-title">Transparency</span></span></code></pre><p>它本身没有实现Serializable接口，这个类在往redis里面放到的时候是放不进去的，怎么解决这个问题呢？这里想一下，我们放到redis（session）里面的数据是可以不需要放图片进去的，只要把生成的验证码字符串放进去就行，因为验的时候只要验字符串，那个图片只是生成的时候，给用户看的。</p><p>这里改一下AbstractValidateCodeProcessor#save，</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 保存校验码</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, C validateCode)</span> </span>&#123;       ValidateCodeDTO validateCodeDTO = <span class="hljs-keyword">new</span> ValidateCodeDTO(validateCode.getCode(), validateCode.getExpireTime());       sessionStrategy.setAttribute(request, getSessionKey(), validateCodeDTO);   &#125;</code></pre><p>这里如果validateCode参数是一个图片对象，session中保存的是一个validateCodeDTO对象，它里面并没有BufferedImage类型的属性，这样问题就解决了。</p><hr><p>现在同时启动2个这样的工厂，第一个工厂登录之后，第二个工厂就不用登录，可以直接访问我们写的rest api了，这就说明session是共享的，这样就实现了描述的集群场景</p><h1 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h1><h2 id="点击退出"><a href="#点击退出" class="headerlink" title="点击退出"></a>点击退出</h2><p>index.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>index <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/logout"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><hr><p>以上代码就完成了退出功能，这里的/logout处理的事情：</p><ul><li>使当前session失效</li><li>清除与当前用户相关的remember-me记录</li><li>清空当前的SecurityContext</li><li>重定向到登录页</li></ul><p>这里退出跳转到登录页面的时候</p><pre><code class="hljs http"><span class="hljs-attribute">http://www.pinzhi365.com/authentication/require?logout</span></code></pre><p>后面会带上?logout</p><hr><p>以上就是spring security默认退出的处理，如果这里的默认处理不符合我们的需求，我们要如何来个性化呢？现在就来给读者们介绍一下相关的配置。</p><p>不想使用<code>/logout</code>，使用<code>/signOut</code></p><p>BrowserSecurityConfig:</p><pre><code class="hljs java">http.logout()               .logoutUrl(<span class="hljs-string">"/signOut"</span>)</code></pre><p>index.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>index<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>index <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/signOut"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>退出成功以后，默认的情况下是跳到登录页链接上的，在我们这跳到其他页面</p><p>BrowserSecurityConfig:</p><pre><code class="hljs java">http.logout()              .logoutSuccessUrl(<span class="hljs-string">"/mcr-logout.html"</span>)</code></pre><p>mcr-logout.html：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>退出成功<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><h2 id="退出成功处理器"><a href="#退出成功处理器" class="headerlink" title="退出成功处理器"></a>退出成功处理器</h2><p>BrowserSecurityProperties:</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">   * 退出之后调用的请求</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> String signOutUrl;</code></pre><blockquote><p>这里完成一个功能，使用者配了signOutUrl，那么就跳到signOutUrl上去，如果没配，那么这里就它需要一个json格式的返回</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.session.logout;<span class="hljs-keyword">import</span> com.b4.demo.core.model.vo.McrSecurityVO;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<span class="hljs-keyword">import</span> org.springframework.security.web.DefaultRedirectStrategy;<span class="hljs-keyword">import</span> org.springframework.security.web.RedirectStrategy;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.logout.LogoutSuccessHandler;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrLogoutSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LogoutSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> RedirectStrategy redirectStrategy = <span class="hljs-keyword">new</span> DefaultRedirectStrategy();    <span class="hljs-keyword">private</span> ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-keyword">private</span> String signOutUrl;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrLogoutSuccessHandler</span><span class="hljs-params">(String signOutUrl)</span> </span>&#123;        <span class="hljs-keyword">this</span>.signOutUrl = signOutUrl;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLogoutSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        log.info(<span class="hljs-string">"用户-&gt;&#123;&#125;退出成功"</span>, authentication.getName());        <span class="hljs-keyword">if</span> (signOutUrl == <span class="hljs-keyword">null</span>) &#123;            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(<span class="hljs-string">"退出成功"</span>)));        &#125; <span class="hljs-keyword">else</span> &#123;            redirectStrategy.sendRedirect(request, response, signOutUrl);        &#125;    &#125;&#125;</code></pre><p>BrowserSecurityBeanConfig:</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>   <span class="hljs-meta">@ConditionalOnMissingBean</span>(LogoutSuccessHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">   <span class="hljs-title">public</span> <span class="hljs-title">LogoutSuccessHandler</span> <span class="hljs-title">logoutSuccessHandler</span>() </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrLogoutSuccessHandler(securityProperties.getBrowser().getSignOutUrl());   &#125;</code></pre><p>BrowserSecurityConfig</p><pre><code class="hljs java">    <span class="hljs-keyword">private</span> LogoutSuccessHandler logoutSuccessHandler; <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//..  </span>http                .logout()<span class="hljs-comment">//                .logoutSuccessUrl("/mcr-logout.html")</span>                .logoutSuccessHandler(logoutSuccessHandler)</code></pre><p>这一：这里如果写了退出跳转的页面，这里的处理器就不生效了，这里只能有一个</p><hr><p>退出的时候清除cookie</p><pre><code class="hljs JAVA">http              .logout()              .deleteCookies(<span class="hljs-string">"JSESSIONID"</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 三、Social 】 3.QQ登录</title>
    <link href="/spring-security-3.3.html"/>
    <url>/spring-security-3.3.html</url>
    
    <content type="html"><![CDATA[<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>以下内容中获取QQ用户信息以及QQ中的一些参数，请参考<a href="https://connect.qq.com/" target="_blank" rel="noopener">QQ互联文档</a>。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567224896676.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567227175116.png" srcset="/img/loading.gif" alt=""></p><p>要实现类似QQ登录这种第三方登录，前面说了，需要走一个<code>OAuth</code>流程拿到服务提供商的的用户信息，那么之前将SpringSocial基本概念的时候，服务提供商的信息是封装在Connection里的，所有现在要解决的第一个问题就是需要拿到一个Connection，那么我要拿到一个Connection，我就需要有一个<code>ConnectionFactory</code>工厂，那么我要构建<code>ConnectionFactory</code>我需要2个东西：<code>ServiceProvider</code>、<code>ApiAdapter</code>；</p><p>那么这个<code>ServiceProvider</code>服务提供商的实现，它也需要2个东西：</p><ol><li><code>OAuth2Operations</code>接口的实现</li><li><code>Api</code>接口的实现，它是用来读取用户的信息的，这个东西是和服务提供商紧密相关的，每个服务商都不一样，等会就先从这里入手</li></ol><p>整个开发的流程：先从<code>Api</code>开始 ，获取用户信息的实现，然后有了<code>Api</code>我用它默认的<code>OAuth2Template</code>做为<code>OAuth2Operations</code>的实现，用这2个东西构建出<code>ServiceProvider</code>来，然后实现这个<code>ApiAdapter</code>,<code>ServiceProvider</code>和<code>ApiAdapter</code>有了，就可以构建出一个<code>ConnectionFactory</code>，有了这个东西我就可以通过，有了<code>ConnectionFactory</code>就可以拿到我的用户信息了，有了用户信息以后，我们会在数据库里建一张<code>UserConnection</code>表，然后这个<code>JdbcUsersConnectionRepository</code>，这个东西<code>SpringSocial</code>已经提供了，只需要配置一下告诉它数据库在哪就可以了，那么这些有了之后，就可以通过<code>ConnectionFactory</code>拿到我们的服务提供商用户信息，那么整个流程就可以转起来了，转起来以后根据问题一步步逐渐去细化</p><h1 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h1><p>首先来到文档<a href="https://wiki.connect.qq.com/get_user_info" target="_blank" rel="noopener">https://wiki.connect.qq.com/get_user_info</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567246322516.png" srcset="/img/loading.gif" alt="1567246322516"></p><p>根据文章上的josn封装成一个类，这里主要需要多加一个<code>openId</code>字段</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.api;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQUserInfo</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> ret;    <span class="hljs-keyword">private</span> String msg;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> is_lost;    <span class="hljs-keyword">private</span> String nickname;    <span class="hljs-keyword">private</span> String gender;    <span class="hljs-keyword">private</span> String province;    <span class="hljs-keyword">private</span> String city;    <span class="hljs-keyword">private</span> String year;    <span class="hljs-keyword">private</span> String constellation;    <span class="hljs-keyword">private</span> String figureurl;    <span class="hljs-keyword">private</span> String figureurl_1;    <span class="hljs-keyword">private</span> String figureurl_2;    <span class="hljs-keyword">private</span> String figureurl_qq_1;    <span class="hljs-keyword">private</span> String figureurl_qq_2;    <span class="hljs-keyword">private</span> String figureurl_qq;    <span class="hljs-keyword">private</span> String figureurl_type;    <span class="hljs-keyword">private</span> String is_yellow_vip;    <span class="hljs-keyword">private</span> String vip;    <span class="hljs-keyword">private</span> String yellow_vip_level;    <span class="hljs-keyword">private</span> String level;    <span class="hljs-keyword">private</span> String is_yellow_year_vip;    <span class="hljs-keyword">private</span> String openId;&#125;</code></pre><p>定义一个获取QQ信息的接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.api;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">QQ</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取QQ信息</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   QQ信息</span><span class="hljs-comment">     */</span>    <span class="hljs-function">QQUserInfo <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>之前说所有的<code>Api</code>都要继承<code>AbstractOAuth2ApiBinding</code>，先来看下它长什么样子</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractOAuth2ApiBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApiBinding</span>, <span class="hljs-title">InitializingBean</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String accessToken;<span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-comment">//...</span>&#125;</code></pre><p>在这个抽象类里面它提供了2个属性：</p><ol><li><code>accessToken</code>：我们现在的<code>api</code>在整个流程里是执行第6步获取用户信息的，执行第6步需要第5步最后最后收到的令牌，拿这个令牌才能获取用户信息，这里注意：每一个人走这个流程它获取到的令牌都是不一样的，这个数据它是类的成员变量，那么意外着，这个类的实现类它不是一个单例对象，针对每一个用户它走完自己的这个<code>OAuth</code>流程，都会对用户单独创建一个实现，在里面存这个用户他自己特有的<code>accessToken</code>，这是一个多实现的对象；</li><li><code>restTemplate</code>：因为第6步获取用户信息需要往服务提供商发送http请求，这个<code>restTemplate</code>就是http请求工具。</li></ol><p>来创建一个类继承<code>AbstractOAuth2ApiBinding</code>，实现QQ接口</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.api;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.AbstractOAuth2ApiBinding;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOAuth2ApiBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QQ</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QQUserInfo <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p>下面来看一下QQ文档，要发一个什么请求，传递什么参数,文档地址：<a href="https://wiki.connect.qq.com/openapi调用说明_oauth2-0" target="_blank" rel="noopener">https://wiki.connect.qq.com/openapi%E8%B0%83%E7%94%A8%E8%AF%B4%E6%98%8E_oauth2-0</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567248607175.png" srcset="/img/loading.gif" alt=""></p><p>想调用这个请求，有3个参数：</p><ol><li>access_token：走完图1 前5步拿到的令牌，这里的<code>access_token</code>就在<code>AbstractOAuth2ApiBinding</code>里面</li><li>oauth_consumer_key：你要用QQ、微信登录首先要到QQ互联、微信开放平台上去注册，注册完了 以后，它会分配给你一个<code>appId</code></li><li>openid：用户的ID，与QQ号码一一对应。 “可通过调用<a href="https://graph.qq.com/oauth2.0/me?access_token=YOUR_ACCESS_TOKEN" target="_blank" rel="noopener">https://graph.qq.com/oauth2.0/me?access_token=YOUR_ACCESS_TOKEN</a> 来获取。”</li></ol><p>首先将说这3个参数，其中的<code>access_token</code>已经处理了，这里要把另外2个写一下</p><pre><code class="hljs java"><span class="hljs-comment">//注册qq互联分配的appid</span><span class="hljs-keyword">private</span> String appId;<span class="hljs-comment">//qq用户的Id</span><span class="hljs-keyword">private</span> String openId;</code></pre><p>然后还有2个http路径：</p><ol><li>通过<code>access_token</code>去拿<code>openId</code>发的请求地址</li><li>获取用户信息的请求地址</li></ol><p>这里将2个请求路径声明成常量</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_GET_OPENID = <span class="hljs-string">"https://graph.qq.com/oauth2.0/me?access_token=%s"</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_GET_USERINFO = <span class="hljs-string">"https://graph.qq.com/user/get_user_info?oauth_consumer_key=%s&amp;openid=%s"</span>;</code></pre><blockquote><p>从QQ互联文档里，可以看到获取用户信息是需要<code>access_token</code>参数的，但在我们这里不需要写，因为这一步交给我们父类来处理了，它会自动得将<code>access_token</code>替我们挂上去</p></blockquote><p>构造器：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQImpl</span><span class="hljs-params">(String accessToken, String appId)</span> </span>&#123;     <span class="hljs-keyword">super</span>(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER);     <span class="hljs-keyword">this</span>.appId = appId; &#125;</code></pre><p>上面代码调用了父类的2个参数的构造器，第2个参数使用了<code>TokenStrategy.ACCESS_TOKEN_PARAMETER</code>策略，来看一下父类的一个参数的构造器，它会调用自己2个参数的构造器，同时用一个默认的<code>token</code>策略去调，</p><p><code>TokenStrategy.AUTHORIZATION_HEADER</code>：在发请求的时候，默认把<code>accessToken</code>放到请求头里面，但是在QQ文档上要求<code>accessToken</code>应该要放到查询参数里面去：<a href="https://graph.qq.com/user/get_user_info?access_token=YOUR_ACCESS_TOKEN&oauth_consumer_key=YOUR_APP_ID&openid=YOUR_OPENID" target="_blank" rel="noopener">https://graph.qq.com/user/get_user_info?access_token=YOUR_ACCESS_TOKEN&amp;oauth_consumer_key=YOUR_APP_ID&amp;openid=YOUR_OPENID</a>，<code>AbstractOAuth2ApiBinding</code>的一个参数的构造器会将参数放到<code>Authorization请求头</code>里面，所以默认的代码行为不符合做QQ登录的要求，所以这里应该调用2个参数的构造器，使用<code>AUTHORIZATION_HEADER</code>策略</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">AbstractOAuth2ApiBinding</span><span class="hljs-params">(String accessToken)</span> </span>&#123;<span class="hljs-keyword">this</span>(accessToken, TokenStrategy.AUTHORIZATION_HEADER);&#125;</code></pre><p>通过上面这个构造器，你在使用它里面的<code>restTemplate</code>发请求的时候，它会自动把<code>accessToken</code>作为查询参数，把它挂上去</p><hr><p>QQ互联文档上，要求先要获取<code>openId</code>，获取<code>openId</code>代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQImpl</span><span class="hljs-params">(String accessToken, String appId)</span> </span>&#123;      <span class="hljs-comment">//...</span>       String url = String.format(URL_GET_OPENID, accessToken);       String result = getRestTemplate().getForObject(url, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;       log.info(result);       <span class="hljs-keyword">this</span>.openId = StringUtils.substringBetween(result, <span class="hljs-string">"\"openid\":\""</span>, <span class="hljs-string">"\"&#125;"</span>);       log.info(<span class="hljs-string">"openId-&gt;&#123;&#125;"</span>, <span class="hljs-keyword">this</span>.openId);   &#125;</code></pre><p>这里要通过截取来获取<code>openId</code>，文档说它是长这个样子的：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567250832980.png" srcset="/img/loading.gif" alt="1567250832980"></p><p>实现QQ接口方法：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ObjectMapper objectMapper=<span class="hljs-keyword">new</span> ObjectMapper(); <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> QQUserInfo <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span> </span>&#123;     String url = String.format(URL_GET_USERINFO, appId, openId);     String result = getRestTemplate().getForObject(url, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;     log.info(result);     <span class="hljs-keyword">try</span> &#123;         QQUserInfo qqUserInfo = objectMapper.readValue(result, QQUserInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;         qqUserInfo.setOpenId(openId);         <span class="hljs-keyword">return</span> qqUserInfo;     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;         e.printStackTrace();         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"获取用户失败"</span>, e);     &#125; &#125;</code></pre><p>完整代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.api;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.AbstractOAuth2ApiBinding;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.TokenStrategy;<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOAuth2ApiBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QQ</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_GET_OPENID = <span class="hljs-string">"https://graph.qq.com/oauth2.0/me?access_token=%s"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_GET_USERINFO = <span class="hljs-string">"https://graph.qq.com/user/get_user_info?oauth_consumer_key=%s&amp;openid=%s"</span>;    <span class="hljs-comment">//注册qq互联分配的appid</span>    <span class="hljs-keyword">private</span> String appId;    <span class="hljs-comment">//qq用户的Id</span>    <span class="hljs-keyword">private</span> String openId;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQImpl</span><span class="hljs-params">(String accessToken, String appId)</span> </span>&#123;        <span class="hljs-keyword">super</span>(accessToken, TokenStrategy.ACCESS_TOKEN_PARAMETER);        <span class="hljs-keyword">this</span>.appId = appId;        String url = String.format(URL_GET_OPENID, accessToken);        String result = getRestTemplate().getForObject(url, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        log.info(result);        <span class="hljs-keyword">this</span>.openId = StringUtils.substringBetween(result, <span class="hljs-string">"\"openid\":\""</span>, <span class="hljs-string">"\"&#125;"</span>);        log.info(<span class="hljs-string">"openId-&gt;&#123;&#125;"</span>, <span class="hljs-keyword">this</span>.openId);    &#125;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper=<span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QQUserInfo <span class="hljs-title">getUserInfo</span><span class="hljs-params">()</span> </span>&#123;        String url = String.format(URL_GET_USERINFO, appId, openId);        String result = getRestTemplate().getForObject(url, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        log.info(result);        <span class="hljs-keyword">try</span> &#123;            QQUserInfo qqUserInfo = objectMapper.readValue(result, QQUserInfo<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            qqUserInfo.setOpenId(openId);            <span class="hljs-keyword">return</span> qqUserInfo;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"获取用户失败"</span>, e);        &#125;    &#125;&#125;</code></pre><h1 id="ServiceProvider"><a href="#ServiceProvider" class="headerlink" title="ServiceProvider"></a>ServiceProvider</h1><p>现在<code>api</code>有了，这里看图2它还需要一个<code>OAuth2Operations</code>实现类，这里就先暂时使用它默认提供的<code>OAuth2Template</code>，现在就可以来写<code>ServiceProvider</code>了</p><p>完整代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.connect;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.social.qq.api.QQ;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.social.qq.api.QQImpl;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.AbstractOAuth2ServiceProvider;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.OAuth2Operations;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.OAuth2ServiceProvider;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.OAuth2Template;<span class="hljs-comment">/**</span><span class="hljs-comment"> * QQServiceProvider</span><span class="hljs-comment"> * appId：注册qq互联分配的id</span><span class="hljs-comment"> * appSecret：注册qq互联的分配密码</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQServiceProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOAuth2ServiceProvider</span>&lt;<span class="hljs-title">QQ</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> String appId;    <span class="hljs-comment">//将用户导向的认证服务器的地址</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_AUTHORIZE = <span class="hljs-string">"https://graph.qq.com/oauth2.0/authorize"</span>;    <span class="hljs-comment">//第三方拿着授权码获取Token的地址</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String URL_ACCESS_TOKEN = <span class="hljs-string">"https://graph.qq.com/oauth2.0/token"</span>;    <span class="hljs-comment">//提供OAuth2Operations</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQServiceProvider</span><span class="hljs-params">(String appId, String appSecret)</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> OAuth2Template(appId, appSecret, URL_AUTHORIZE, URL_ACCESS_TOKEN));        <span class="hljs-keyword">this</span>.appId = appId;    &#125;    <span class="hljs-comment">//提供Api</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> QQ <span class="hljs-title">getApi</span><span class="hljs-params">(String accessToken)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QQImpl(accessToken, appId);    &#125;&#125;</code></pre><p>编写<code>QQServiceProvider</code>，继承<code>AbstractOAuth2ServiceProvider</code>，它这里有一个抽象方法：<code>getApi</code>，需要我们来实现，它会将前5步流程中得到的令牌交给之前写的<code>QQImpl</code>，所以这里的<code>getApi</code>实例化的时候通过构造器传给<code>QQImpl</code>，这里的<code>appId</code>是固定唯一的，它不会变。</p><pre><code class="hljs java"><span class="hljs-comment">//提供Api</span>  <span class="hljs-meta">@Override</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> QQ <span class="hljs-title">getApi</span><span class="hljs-params">(String accessToken)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QQImpl(accessToken, appId);  &#125;</code></pre><p>然后说下构造器</p><pre><code class="hljs java"><span class="hljs-comment">//提供OAuth2Operations</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQServiceProvider</span><span class="hljs-params">(String appId, String appSecret)</span> </span>&#123;       <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> OAuth2Template(appId, appSecret, URL_AUTHORIZE, URL_ACCESS_TOKEN));       <span class="hljs-comment">//...</span>   &#125;</code></pre><p>这里调用了父类的构造方器，这里需要传递一个<code>OAuth2Operations</code>接口的实现类，之前说过暂时使用它默认提供的<code>OAuth2Template</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractOAuth2ServiceProvider</span><span class="hljs-params">(OAuth2Operations oauth2Operations)</span> </span>&#123;<span class="hljs-keyword">this</span>.oauth2Operations = oauth2Operations;&#125;</code></pre><p>这里使用了<code>OAuth2Template</code>4个参数的构造器</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Constructs an OAuth2Template for a given set of client credentials. </span><span class="hljs-comment"> * Assumes that the authorization URL is the same as the authentication URL.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clientId the client ID</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> clientSecret the client secret</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> authorizeUrl the base URL to redirect to when doing authorization code or implicit grant authorization</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> accessTokenUrl the URL at which an authorization code, refresh token, or user credentials may be exchanged for an access token.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OAuth2Template</span><span class="hljs-params">(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl)</span> </span>&#123;<span class="hljs-keyword">this</span>(clientId, clientSecret, authorizeUrl, <span class="hljs-keyword">null</span>, accessTokenUrl);&#125;</code></pre><ol><li>clientId：它就是<code>appId</code>,QQ上注册的时候会分配给你一个<code>appId</code></li><li>clientSecret：QQ互联网上注册时候，它会分配给你一个App Secret</li><li>authorizeUrl：图1的第1步，将用户导向认证服务器的时候，导向的URL地址</li><li>accessTokenUrl：图1的第4步，用户同意授权的时候，用户服务器返回一个授权码，拿着授权码去申请令牌的地址</li></ol><p>这里我们写的<code>QQServiceProvider</code>为什么会有<code>appId</code>、<code>appSecret</code>2个参数，因为使用者A，在使用我们的代码的时候，它的<code>appId</code>、<code>appSecret2</code>与使用者B是不一样的，每个人申请拿到的<code>appId</code>、<code>appSecret</code>都不一样</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQServiceProvider</span><span class="hljs-params">(String appId, String appSecret)</span> </span>&#123;          <span class="hljs-comment">//...</span>&#125;</code></pre><h1 id="ApiAdapter"><a href="#ApiAdapter" class="headerlink" title="ApiAdapter"></a>ApiAdapter</h1><p>之前将图2右边部分的代码完成了，现在来实现左边的代码，图中表示<code>ConnectionFactory</code>中需要<code>ServiceProvider</code>，已经实现了，现在还需要<code>ApiAdapter</code>，<code>ApiAdapter</code>的作用：将之前写的<code>Api</code>所获取到的个性化服务提供商用户数据和<code>SpringSocial</code>标准的数据结构之间做一个适配</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.connect;<span class="hljs-comment">/**</span><span class="hljs-comment"> * QQAdapter</span><span class="hljs-comment"> * 将服务提供商用户信息进行统一的适配</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApiAdapter</span>&lt;<span class="hljs-title">QQ</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-comment">//用来测试当前API是否可用</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(QQ api)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">//设置创建Connection的时候需要的一些配置项ConnectionValues</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConnectionValues</span><span class="hljs-params">(QQ api, ConnectionValues values)</span> </span>&#123;        QQUserInfo userInfo = api.getUserInfo();        values.setDisplayName(userInfo.getNickname());        values.setImageUrl(userInfo.getFigureurl_qq_1());        values.setProfileUrl(<span class="hljs-keyword">null</span>);<span class="hljs-comment">//主页</span>        values.setProviderUserId(userInfo.getOpenId());<span class="hljs-comment">//用户在服务提供商的唯一标示，openID</span>    &#125;    <span class="hljs-comment">//绑定解绑的时候</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserProfile <span class="hljs-title">fetchUserProfile</span><span class="hljs-params">(QQ api)</span> </span>&#123;        <span class="hljs-comment">// TODO Auto-generated method stub</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateStatus</span><span class="hljs-params">(QQ api, String message)</span> </span>&#123;        <span class="hljs-comment">//do noting</span>    &#125;&#125;</code></pre><h1 id="ConnectionFactory"><a href="#ConnectionFactory" class="headerlink" title="ConnectionFactory"></a>ConnectionFactory</h1><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xdc.mcr.core.social.qq.connect;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 将之前写的</span><span class="hljs-comment"> * QQServiceProvider和QQAdapter传递进来创建</span><span class="hljs-comment"> * QQConnectionFactory</span><span class="hljs-comment"> * providerId：用户在服务商的唯一标示openId</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQConnectionFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OAuth2ConnectionFactory</span>&lt;<span class="hljs-title">QQ</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQConnectionFactory</span><span class="hljs-params">(String providerId, String appId, String appSecret)</span> </span>&#123;      <span class="hljs-keyword">super</span>(providerId, <span class="hljs-keyword">new</span> QQServiceProvider(appId, appSecret), <span class="hljs-keyword">new</span> QQAdapter());   &#125;&#125;</code></pre><p>来看一下它 父类<code>OAuth2ConnectionFactory</code>的构造器</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Create a &#123;<span class="hljs-doctag">@link</span> OAuth2ConnectionFactory&#125;.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> providerId the provider id e.g. "facebook"</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> serviceProvider the ServiceProvider model for conducting the authorization flow and obtaining a native service API instance.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> apiAdapter the ApiAdapter for mapping the provider-specific service API model to the uniform &#123;<span class="hljs-doctag">@link</span> Connection&#125; interface.</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OAuth2ConnectionFactory</span><span class="hljs-params">(String providerId, OAuth2ServiceProvider&lt;S&gt; serviceProvider, ApiAdapter&lt;S&gt; apiAdapter)</span> </span>&#123;<span class="hljs-keyword">super</span>(providerId, serviceProvider, apiAdapter);&#125;</code></pre><p>这里有3个参数：</p><ol><li><code>ProviderId</code>提供商的唯一标识，这个因为每个使用者的都不一样，等会通过配置文件配进来</li><li>ServiceProvider：它类型是<code>OAuth2ServiceProvider</code>，之前我们写的<code>QQServiceProvider</code>就是这个类型的子类，这里把<code>QQServiceProvider</code>的实例传递进去</li><li>ApiAdapter：这里要求是实现<code>ApiAdapter</code>接口的，也就是前面写的<code>QQAdapter</code>，传递进去</li></ol><h1 id="SpringSocial配置"><a href="#SpringSocial配置" class="headerlink" title="SpringSocial配置"></a>SpringSocial配置</h1><p>图2中的Connection不需要实现，现在只差<code>UsersConnectionRepository</code>了，这个实际上<code>SpringSocial</code>已经为我们提供好了，只需要配一下</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableSocial</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> DataSource dataSource;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UsersConnectionRepository <span class="hljs-title">getUsersConnectionRepository</span><span class="hljs-params">(ConnectionFactoryLocator connectionFactoryLocator)</span> </span>&#123;        <span class="hljs-comment">//Encryptors.noOpText()不做加解密</span>        JdbcUsersConnectionRepository repository = <span class="hljs-keyword">new</span> JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText());        <span class="hljs-comment">//建表的前缀</span>        <span class="hljs-comment">//repository.setTablePrefix("t_");</span>        <span class="hljs-keyword">return</span> repository;    &#125;    <span class="hljs-comment">//将SpringSocialFilter添加到安全配置的Bean</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringSocialConfigurer <span class="hljs-title">socialSecurityConfig</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringSocialConfigurer();    &#125;&#125;</code></pre><p>说下这行代码</p><pre><code class="hljs java">JdbcUsersConnectionRepository repository = <span class="hljs-keyword">new</span> JdbcUsersConnectionRepository(dataSource, connectionFactoryLocator, Encryptors.noOpText());</code></pre><p>这里<code>JdbcUsersConnectionRepository</code>的构造器有3个参数：</p><ol><li><p><code>dataSource</code>：告诉它数据源的位置</p></li><li><p><code>connectionFactoryLocator</code>：负责去查找<code>ConnectionFactory</code>，因为在系统里，可能会有很多个<code>ConnectionFactory</code>，比如我刚刚写了一个QQ的<code>ConnectionFactory</code>，后面写微信的时候还要再写一个微信的<code>ConnectionFactory</code>，这个东西它会根据条件去查找你当前应该用哪个<code>ConnectionFactory</code>来构建<code>Connection</code>数据</p></li><li><p><code>textEncryptor</code>：帮你把插到数据库里的数据做一个加解密，因为插入到数据库里的是一些比较敏感的数据，用户的<code>accessToken</code>这些东西，那么为了保证它的安全，就需要通过这个工具</p><p><code>Encryptors</code>类中提供了一些默认的工具，这里我就选择使用里面的<code>noOpText</code>，不做任何操作，读者在实际开发中，可别这么干</p></li></ol><p>这里需要在数据库中建立一个<code>UserConnection</code>的表，这个建表的脚本和<code>JdbcUsersConnectionRepository</code>在一个包下，将这个脚本在你的数据库中执行一下</p><pre><code class="hljs mysql">create table UserConnection (userId varchar(255) not null,providerId varchar(255) not null,providerUserId varchar(255),rank int not null,displayName varchar(255),profileUrl varchar(512),imageUrl varchar(512),accessToken varchar(512) not null,secret varchar(512),refreshToken varchar(512),expireTime bigint,primary key (userId, providerId, providerUserId));create unique index UserConnectionRank on UserConnection(userId, providerId, rank);</code></pre><p>介绍一下这里的字段：</p><ul><li>userId：这个是业务系统中的用户id</li><li>providerId：服务提供商的id，是QQ、微信还是其他的服务提供商</li><li>providerUserId：之前提到的<code>openId</code></li><li>rank：等级</li><li>displayName：昵称</li><li>profileUrl： 主页地址</li><li>imageUrl：头像地址</li><li>accessToken、<code>secret</code>、<code>refreshToken</code>、<code>expireTime</code>：这些是跟<code>OAuth协议</code>相关的</li></ul><p>这里最重要的是前3个字段，这里的<code>userId</code>是我们业务系统的<code>userId</code>，<code>providerId</code>是服务提供商的用户id，和我们业务系统之间的一个对应关系，在我们社交登录的过程中，我们实际上是拿到了社交用户的信息，也就是<code>providerId</code>和<code>providerUserId</code>可以拿到<code>userId</code>，那么拿到<code>userId</code>以后我最终登录成功以后放到<code>session</code>里面应该是一个完整的用户信息，而不是一个<code>userId</code>，那么如何从这个<code>userId</code>转换成一个完整的用户信息呢？我们下面接着来说：</p><p>之前说的<code>UserDetailsService</code>它的作用就是根据用户登录表单上填的这个用户名去读取用户的信息，跟用户信息会封装到一个<code>UserDetails</code>接口中，然后拿这个用户信息去校验，如果校验成功了这个信息就会被放到<code>session</code>里，与这个机制类似，<code>SpringSocial</code>提供了一个叫做<code>SocialUserDetailsService</code>的接口：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.social.security;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * similar to &#123;<span class="hljs-doctag">@link</span> UserDetailsService&#125; but loads details by user id, not username</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stefan Fussennegger</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SocialUserDetailsService</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> UserDetailsService#loadUserByUsername(String)</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> userId the user ID used to lookup the user details</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the SocialUserDetails requested</span><span class="hljs-comment"> */</span><span class="hljs-function">SocialUserDetails <span class="hljs-title">loadUserByUserId</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre><p>这个方法是在社交登录的时候用的，这里传进来的是<code>SpringSocial</code>根据根据社交网站的openId查出来的用户的<code>userId</code>，你要做的就是根据这个<code>userId</code>去构建一个<code>SocialUserDetails</code>实例，来看一下<code>SocialUserDetails</code></p><pre><code class="hljs java">tations under the License. */<span class="hljs-keyword">package</span> org.springframework.social.security;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stefan Fussennegger</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SocialUserDetails</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserDetails</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * The user's identity at the provider.</span><span class="hljs-comment"> * Might be same as &#123;<span class="hljs-doctag">@link</span> #getUsername()&#125; if users are identified by username</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> user's id used to assign connections</span><span class="hljs-comment"> */</span><span class="hljs-function">String <span class="hljs-title">getUserId</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>这里的<code>SocialUserDetails</code>继承了<code>UserDetails</code>接口，它这里多了一个<code>userId</code>字段</p><hr><p>McrUserDetailsService：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security.service;<span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span>, <span class="hljs-title">SocialUserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-function"><span class="hljs-keyword">private</span> SocialUser <span class="hljs-title">buildUser</span><span class="hljs-params">(String username)</span> </span>&#123;        String password = passwordEncoder.encode(<span class="hljs-string">"123"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialUser(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string">"表单登录用户-&gt;&#123;&#125;进行效验"</span>, username);        <span class="hljs-keyword">return</span> buildUser(username);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SocialUserDetails <span class="hljs-title">loadUserByUserId</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string">"社交登录用户id-&gt;&#123;&#125;进行效验"</span>, userId);        <span class="hljs-keyword">return</span> buildUser(userId);    &#125;&#125;</code></pre><h1 id="配置QQ登录"><a href="#配置QQ登录" class="headerlink" title="配置QQ登录"></a>配置QQ登录</h1><p>现在离完成还差2件事</p><ol><li>一些配置：QQ登录需要的<code>appId</code>、<code>appSecret</code>，这些还没配，把这些配置加上</li><li>在页面上加一个QQ登录的入口</li></ol><p>QQProperties：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.social.SocialProperties;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialProperties</span> </span>&#123;<span class="hljs-keyword">private</span> String providerId = <span class="hljs-string">"qq"</span>;<span class="hljs-comment">//默认的providerId</span> &#125;</code></pre><p>这里继承了<code>SpringSocial</code>提供的<code>SocialProperties</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.boot.autoconfigure.social;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Base &#123;<span class="hljs-doctag">@link</span> ConfigurationProperties properties&#125; for spring social.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Stephane Nicoll</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.4.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialProperties</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Application id.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String appId;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Application secret.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String appSecret;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.appId;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppId</span><span class="hljs-params">(String appId)</span> </span>&#123;<span class="hljs-keyword">this</span>.appId = appId;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAppSecret</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.appSecret;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAppSecret</span><span class="hljs-params">(String appSecret)</span> </span>&#123;<span class="hljs-keyword">this</span>.appSecret = appSecret;&#125;&#125;</code></pre><p>这里提供了我们需要的<code>appId</code>和<code>appSecret</code></p><hr><p>现在需要把这个配置加到<code>SecurityProperties</code>里面，但是不能直接加，需要加一层<code>SocialProperties</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> QQProperties qq = <span class="hljs-keyword">new</span> QQProperties();&#125;</code></pre><p>SecurityProperties：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SocialProperties social = <span class="hljs-keyword">new</span> SocialProperties();</code></pre><p>QQAutoConfig：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.config;<span class="hljs-comment">/**</span><span class="hljs-comment"> * QQAutoConfig配置类</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//当配置了mcr.security.social.qq.app-id时才生效</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"mcr.b4.security.social.qq"</span>, name = <span class="hljs-string">"app-id"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQAutoConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialAutoConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-comment">//将配置文件中的ProviderId，AppId，AppSecret读取出来，给QQConnectionFactory</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> ConnectionFactory&lt;?&gt; createConnectionFactory() &#123;        QQProperties qqConfig = securityProperties.getSocial().getQq();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QQConnectionFactory(qqConfig.getProviderId(), qqConfig.getAppId(), qqConfig.getAppSecret());    &#125;&#125;</code></pre><p>yml：</p><pre><code class="hljs java">mcr:  b4:    security:      social:        qq:          app-id: xxxx           app-secret: xxxx</code></pre><p>BrowserSecurityConfig:</p><pre><code class="hljs java">  <span class="hljs-keyword">private</span> SpringSocialConfigurer socialSecurityConfig;  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;http.                .apply(socialSecurityConfig)<span class="hljs-comment">//...</span>&#125;</code></pre><p>mcr-login.html：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>社交登录<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/auth/qq"</span>&gt;</span>QQ登录<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre><p>解释一下这个路径，这个路径由两段组成，</p><p>auth：之前<code>SpringSocial</code>基本原理说的过滤器<code>SocialAuthenticationFilter</code>拦截，在363行</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_FILTER_PROCESSES_URL = <span class="hljs-string">"/auth"</span>;</code></pre><p>qq：这个qq是我们之前写的QQAutoConfig#createConnectionFactory传递的getProviderId，也就是qq</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <span class="hljs-keyword">protected</span> ConnectionFactory&lt;?&gt; createConnectionFactory() &#123;      QQProperties qqConfig = securityProperties.getSocial().getQq();      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QQConnectionFactory(qqConfig.getProviderId(), qqConfig.getAppId(), qqConfig.getAppSecret());  &#125;</code></pre><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>现在点击QQ登录的A链接，会出现以下情况：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567265942100.png" srcset="/img/loading.gif" alt="1567265942100"></p><p>它说重定向的URL是非法的，在之前将流程的时候，第3步用户同意授权以后服务提供商会携带授权码，跳回到第三方应用上，在调回去的时候跳的地址就是现在浏览器上url的query参数<code>redirect_uri</code>，这个地址是如何来确定的呢？我们在QQ互联上去注册我们应用的时候，我们要填写一个网站的回调域，我这的回调域是：<a href="http://www.pinzhi365.com/qqLogin/callback.do，而现在的是：http://localhost:8080/auth/qq&amp;state=831e84cf-c5a3-4e24-ada5-aaae4d425613，所以会出现这个问题" target="_blank" rel="noopener">http://www.pinzhi365.com/qqLogin/callback.do，而现在的是：http://localhost:8080/auth/qq&amp;state=831e84cf-c5a3-4e24-ada5-aaae4d425613，所以会出现这个问题</a></p><pre><code class="hljs http">https://graph.qq.com/oauth2.0/show?which=error&amp;display=pc&amp;error=100010&amp;client_id=101547043&amp;response_type=code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8080%2Fauth%2Fqq&amp;state=831e84cf-c5a3-4e24-ada5-aaae4d425613</code></pre><p>这里要注意：在<code>SpringSocial</code>里面，第1步将用户导向认证服务器，要触发这个，我们所访问的地址<code>/auth/qq</code>跟最终用户同意授权跳转回来的地址是同一个地址，都是页面上写的<code>/auth/qq</code></p><hr><p>将<code>redirect_uri</code>参数的值与QQ互联上配置的回调域保持一致</p><p>这里使用<code>SwitchHosts</code>工具改一下host文件，这样当访问 <a href="http://www.pinzhi365.com时就会访问自己的机器" target="_blank" rel="noopener">www.pinzhi365.com时就会访问自己的机器</a></p><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> www.pinzhi365.com</code></pre><p>它现在访问的是80，所以还需要改一下<code>yml</code></p><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span></code></pre><p>现在<code>SocialAuthenticationFilter</code>它会处理<code>/auth</code>开头的请求，要怎么改变它呢？来看之前写的<code>SocialConfig#socialSecurityConfig</code>的配置，来看一下<code>SpringSocialConfigurer</code>的<code>configure</code>方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;ApplicationContext applicationContext = http.getSharedObject(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;UsersConnectionRepository usersConnectionRepository = getDependency(applicationContext, UsersConnectionRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;SocialAuthenticationServiceLocator authServiceLocator = getDependency(applicationContext, SocialAuthenticationServiceLocator<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;SocialUserDetailsService socialUsersDetailsService = getDependency(applicationContext, SocialUserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;SocialAuthenticationFilter filter = <span class="hljs-keyword">new</span> SocialAuthenticationFilter(http.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>), </span><span class="hljs-class"><span class="hljs-title">userIdSource</span> !</span>= <span class="hljs-keyword">null</span> ? userIdSource : <span class="hljs-keyword">new</span> AuthenticationNameUserIdSource(), usersConnectionRepository, authServiceLocator);RememberMeServices rememberMe = http.getSharedObject(RememberMeServices<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">if</span> (rememberMe != <span class="hljs-keyword">null</span>) &#123;filter.setRememberMeServices(rememberMe);&#125;<span class="hljs-keyword">if</span> (postLoginUrl != <span class="hljs-keyword">null</span>) &#123;filter.setPostLoginUrl(postLoginUrl);filter.setAlwaysUsePostLoginUrl(alwaysUsePostLoginUrl);&#125;<span class="hljs-keyword">if</span> (postFailureUrl != <span class="hljs-keyword">null</span>) &#123;filter.setPostFailureUrl(postFailureUrl);&#125;<span class="hljs-keyword">if</span> (signupUrl != <span class="hljs-keyword">null</span>) &#123;filter.setSignupUrl(signupUrl);&#125;<span class="hljs-keyword">if</span> (connectionAddedRedirectUrl != <span class="hljs-keyword">null</span>) &#123;filter.setConnectionAddedRedirectUrl(connectionAddedRedirectUrl);&#125;<span class="hljs-keyword">if</span> (defaultFailureUrl != <span class="hljs-keyword">null</span>) &#123;filter.setDefaultFailureUrl(defaultFailureUrl);&#125;http.authenticationProvider(<span class="hljs-keyword">new</span> SocialAuthenticationProvider(usersConnectionRepository, socialUsersDetailsService)).addFilterBefore(postProcess(filter), AbstractPreAuthenticatedProcessingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;</code></pre><p>它在这里实例化了一个<code>SocialAuthenticationFilter</code>，然后实例化这个过滤器以后，它在下面做了一些处理，最终它把这个过滤器加到了<code>SpringSecurity</code>的过滤器链上，它在加入之前调用了一个<code>postProcess</code>方法</p><pre><code class="hljs java">.addFilterBefore(postProcess(filter), AbstractPreAuthenticatedProcessingFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><p>我们现在要做的是自己写一个类去继承<code>SpringSocialConfigurer</code>，然后把它的<code>postProcess</code>方法覆盖掉，实现我们需要的逻辑</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-keyword">import</span> org.springframework.social.security.SocialAuthenticationFilter;<span class="hljs-keyword">import</span> org.springframework.social.security.SpringSocialConfigurer;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 自己创建McrSpringSocialConfigurer继承SpringSocialConfigurer，重写</span><span class="hljs-comment"> * postProcess，将自己配置的filterProcessesUrl设置进去。</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrSpringSocialConfigurer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringSocialConfigurer</span> </span>&#123;<span class="hljs-keyword">private</span> String filterProcessesUrl;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">McrSpringSocialConfigurer</span><span class="hljs-params">(String filterProcessesUrl)</span> </span>&#123;<span class="hljs-keyword">this</span>.filterProcessesUrl = filterProcessesUrl;&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">postProcess</span><span class="hljs-params">(T object)</span> </span>&#123;SocialAuthenticationFilter filter = (SocialAuthenticationFilter) <span class="hljs-keyword">super</span>.postProcess(object);filter.setFilterProcessesUrl(filterProcessesUrl);<span class="hljs-keyword">return</span> (T) filter;&#125;&#125;</code></pre><p>上面代码中的<code>postProcess</code>方法中的参数object实际上就是要放到过滤器链上的<code>SocialAuthenticationFilter</code>，在这里使用它的<code>setFilterProcessesUrl</code>方法改变默认的<code>/auth</code>，这里不直接写死在这里，要做成可配置的，所以这里使用构造器来给<code>filterProcessesUrl</code>赋值</p><p>SocialProperties：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> String filterProcessesUrl=<span class="hljs-string">"/auth"</span>;</code></pre><p>SocialConfig：</p><pre><code class="hljs java"> <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;  <span class="hljs-comment">//将SpringSocialFilter添加到安全配置的Bean  </span><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringSocialConfigurer <span class="hljs-title">socialSecurityConfig</span><span class="hljs-params">()</span> </span>&#123;        McrSpringSocialConfigurer mcrSpringSocialConfigurer = <span class="hljs-keyword">new</span> McrSpringSocialConfigurer(securityProperties.getSocial().getFilterProcessesUrl());        <span class="hljs-keyword">return</span> mcrSpringSocialConfigurer;    &#125;</code></pre><p>yml：</p><pre><code class="hljs yml"><span class="hljs-attr">mcr:</span>  <span class="hljs-attr">b4:</span>    <span class="hljs-attr">security:</span>      <span class="hljs-attr">social:</span>        <span class="hljs-attr">filterProcessesUrl:</span> <span class="hljs-string">/qqLogin</span>        <span class="hljs-attr">qq:</span>          <span class="hljs-attr">providerId:</span> <span class="hljs-string">callback.do</span></code></pre><p><code>mcr-login.html</code>，修改a标签跳转的地址</p><pre><code class="hljs java">&lt;a href="/qqLogin/callback.do"&gt;QQ登录&lt;/a&gt;</code></pre><p>现在访问：<a href="http://www.pinzhi365.com/mcr-login.html，扫码登录，页面响应内容：" target="_blank" rel="noopener">http://www.pinzhi365.com/mcr-login.html，扫码登录，页面响应内容：</a></p><pre><code class="hljs json">&#123;<span class="hljs-attr">"content"</span>: <span class="hljs-string">"请引导用户跳转到登录页面"</span>&#125;</code></pre><p>控制台内容：</p><pre><code class="hljs angelscript"><span class="hljs-number">2019</span><span class="hljs-number">-09</span><span class="hljs-number">-01</span> <span class="hljs-number">00</span>:<span class="hljs-number">48</span>:<span class="hljs-number">27.204</span>  INFO <span class="hljs-number">51488</span> --- [p-nio<span class="hljs-number">-80</span>-exec<span class="hljs-number">-7</span>] c.b.m.a.b.BrowserSecurityController      : 引发跳转的请求-&gt;http:<span class="hljs-comment">//www.pinzhi365.com/signin</span></code></pre><p>由于<code>/signin</code>这个请求没做授权，所以页面上就会响应这个内容，为什么会跳转到<code>/signin</code>地址呢？这里要跟到<code>SpringSocial</code>中的代码里面去看一下到底发生了什么，在根之前，先介绍一下<code>SpringSocial</code>对整个流程的处理</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567270429093.png" srcset="/img/loading.gif" alt="1567270429093"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567227175116-1567271294474.png" srcset="/img/loading.gif" alt=""></p><p>这张图就是<code>SpringSocial</code>三方登录的时候涉及到的一个接口和实现类以及它们之间的调用顺序，和之前的用户名密码登录和手机验证码登录的流程它的核心是一致的，通过过滤器去拦截某一个特定的请求，拿到这个请求以后，把它里面的身份认证所需要的信息包装到一个<code>Authentication</code>实现里面，然后把把<code>Authentication</code>交给<code>AuthenticationManager</code>，根据传递进来的<code>Authentication</code>类型不同从它所管理的<code>AuthenticationProvider</code>接口实现里面挑一个<code>Provider</code>来处理传进去的校验信息，在处理的过程中它会去调我们自己写的<code>UserDetailsService</code>接口的实现，来获取业务系统中用户的信息，然后把业务系统的信息封装在一个<code>UserDetails</code>接口的实现里面，然后进一系列的检查和校验，如果都通过了，它会把用户信息放到我们之前封装的<code>Authentication</code>里，然后把<code>Authentication</code>标记成经过认证的然后放到<code>SecurityContext</code>里面完成登录，这个核心流程是永远不变的，读者一定要深刻的理解它，然后把它记住，这个是Spring Security最关键的知识，你把它理解了，其实所有登录方式都是一样的，只不过在<code>SpringSocial</code>提供的第三方登录里面涉及到了一些特殊的东西，比如它在这个过滤器在封装<code>Authentication</code>给这个<code>AuthenticationManager</code>的时候用到了一个接口叫做<code>SocialAuthenticationService</code>，图上蓝色的部分是<code>SpringSocial</code>内部封装好的不需要去动的，橘色的是我们自己写的，蓝色的这些在执行的过程中它会调用一些我们自己写的代码，例如这里的<code>OAuth2AuthenticationService</code>,它的作用是执行整个OAuth流程，在执行的过程中，它会去掉我们自己写的<code>ConnectionFactory</code> ，通过<code>ConnectionFactory</code> 会拿到<code>ServiceProvider</code>，<code>ServiceProvider</code>里有一个<code>OAuth2Operations</code>，这个<code>OAuth2Operations</code>会帮助<code>SpringSocial</code>完成整个流程，完成流程以后它会拿到服务提供商的用户信息，服务提供商的用户信息会被封装到<code>Connection</code>里面，然后<code>Connection</code>会被 封装成一个<code>SocialAuthenticationToken</code>，它包含了<code>Connection</code>信息，整个<code>Authentication</code>会交给<code>AuthenticationManager</code>，然后它拿到这个<code>token</code>里面，它会挑<code>SocialAuthenticationProvider</code>出处理这个<code>token</code>，<code>SocialAuthenticationProvider</code>在处理的时候，它会根据传入的<code>Connection</code>也就是服务提供商的用户信息使用<code>JdbcUsersConnectionRepository</code>这个类到数据库里去查一个<code>userId</code>出来，查出来的用户id以后拿这个id去调用我们自己写的<code>SocialUserDetailsService</code>实现，这个服务它去业务系统里把真正你要放到<code>session</code>里的用户信息查询出来，也就是<code>SocialUserDetails</code>，把这个信息放到<code>SocialAuthenticationToken</code>里面，然后标记成已经过认证，放入<code>SecurityContext</code>里，最终放到<code>session</code>中</p><hr><p>回到刚刚之前出错的地方，回想一下，是已经调到了QQ上，手机扫完二维码，进行了授权这个确认，授权确认以后它实际上是跳回我们的demo项目上，在调回我们的<code>demo项目</code>上的时候并没有想象的那样，而是调到了<code>/signin</code> URL上去，实际上我们出问题的点任然是在走我们的<code>OAuth流程</code>中出现的问题，也就说最终我还没有获取一个正确的<code>SocialAuthentication</code>交给<code>AuthenticationManager</code>去验证，而是在这<code>OAuth2AuthenticationService</code>在它去走<code>OAuth</code>流程的中间出了问题，现在来跟踪一下：</p><hr><p><code>OAuth2AuthenticationService</code>里面最重要的方法<code>getAuthToken</code>，它是来拿取认证令牌的，这就是在走<code>OAuth流程</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SocialAuthenticationToken <span class="hljs-title">getAuthToken</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> SocialAuthenticationRedirectException </span>&#123;String code = request.getParameter(<span class="hljs-string">"code"</span>);<span class="hljs-keyword">if</span> (!StringUtils.hasText(code)) &#123;OAuth2Parameters params =  <span class="hljs-keyword">new</span> OAuth2Parameters();params.setRedirectUri(buildReturnToUrl(request));setScope(request, params);params.add(<span class="hljs-string">"state"</span>, generateState(connectionFactory, request));addCustomParameters(params);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocialAuthenticationRedirectException(getConnectionFactory().getOAuthOperations().buildAuthenticateUrl(params));&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (StringUtils.hasText(code)) &#123;<span class="hljs-keyword">try</span> &#123;String returnToUrl = buildReturnToUrl(request);AccessGrant accessGrant = getConnectionFactory().getOAuthOperations().exchangeForAccess(code, returnToUrl, <span class="hljs-keyword">null</span>);<span class="hljs-comment">// TODO avoid API call if possible (auth using token would be fine)</span>Connection&lt;S&gt; connection = getConnectionFactory().createConnection(accessGrant);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SocialAuthenticationToken(connection, <span class="hljs-keyword">null</span>);&#125; <span class="hljs-keyword">catch</span> (RestClientException e) &#123;logger.debug(<span class="hljs-string">"failed to exchange for access"</span>, e);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre><p>首先它从请求中获取<code>code</code>的参数，拿他做判断 这个<code>code</code>是不是有值，为什么会有这么一个判断，因为之前说过在<code>SpringSocial</code>里面第一步就是用户点QQ登录的时候，将用户导向认证服务器，用户点的这个请求和认证服务器，用户同意完授权以后认证服务器调回以后带着授权码这2个地址是一样的，都是代码中写的<code>/qqLogin/callback.do</code>,那么也就意味着，这个<code>SocialAuthenticationFilter</code>它要处理2个请求，</p><p>用户点QQ登录的时候，它要来处理，把页面导向QQ登录的网站上去，然后用户在QQ网站授权完，扫完码同意以后，从QQ跳回来也是由<code>SocialAuthenticationFilter</code>来处理，所以第一行判断请求中有没有code（授权码），如果有，就认为是第3步从服务器上跳回来的，如果没有授权码，就认为是第1步，它会抛出一个<code>SocialAuthenticationRedirectException</code>的异常，<code>SpringSocial</code>捕获到这个异常以后就会把用户重定向到QQ的网站上去</p><p>如果传进来的请求有<code>code参数</code>那么说明是服务器跳转回来的，那么它要做的事情就是拿到连接工厂的<code>OAuthOperations</code>然后调研它的<code>exchangeForAccess</code>，这里就是拿返回的授权码去换令牌，也就是流程图中的第4步和第5步，我们现在遇到的问题就是在网站授权之后，跳回来行为并不是我们期望的</p><hr><p>现在在<code>OAuth2AuthenticationService</code>的98行和103行、267行，</p><p><code>AbstractAuthenticationProcessingFilter</code>的230行打一个断点</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567272856158.png" srcset="/img/loading.gif" alt="1567272856158"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273669776.png" srcset="/img/loading.gif" alt="1567273669776"></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273839249.png" srcset="/img/loading.gif" alt="1567273839249"></p><p>然后再来扫码进行登录：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567272963991.png" srcset="/img/loading.gif" alt="1567272963991"></p><p>当它执行了98行之后，会出现异常，它的异常信息：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273032467.png" srcset="/img/loading.gif" alt="1567273032467"></p><pre><code class="hljs routeros">Could <span class="hljs-keyword">not</span> extract response: <span class="hljs-literal">no</span> suitable HttpMessageConverter found <span class="hljs-keyword">for</span> response<span class="hljs-built_in"> type </span>[interface java.util.Map] <span class="hljs-keyword">and</span> content<span class="hljs-built_in"> type </span>[text/html]</code></pre><p>不能抽取<code>response</code>的信息，没有合适的<code>HttpMessageConverter</code> 为我们的响应类型，<code>Map</code>和<code>content type text/html</code>这是QQ响应回来的<code>content type</code>，那么报这个异常就是因为在<code>exchangeForAccess</code>是有问题的</p><pre><code class="hljs java">AccessGrant accessGrant = getConnectionFactory().getOAuthOperations().exchangeForAccess(code, returnToUrl, <span class="hljs-keyword">null</span>);</code></pre><hr><p>来看一下<code>OAuth2Template#exchangeForAccess</code>，它去交换<code>accessToken</code>做了什么</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AccessGrant <span class="hljs-title">exchangeForAccess</span><span class="hljs-params">(String authorizationCode, String redirectUri, MultiValueMap&lt;String, String&gt; additionalParameters)</span> </span>&#123;MultiValueMap&lt;String, String&gt; params = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();<span class="hljs-keyword">if</span> (useParametersForClientAuthentication) &#123;params.set(<span class="hljs-string">"client_id"</span>, clientId);params.set(<span class="hljs-string">"client_secret"</span>, clientSecret);&#125;params.set(<span class="hljs-string">"code"</span>, authorizationCode);params.set(<span class="hljs-string">"redirect_uri"</span>, redirectUri);params.set(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);<span class="hljs-keyword">if</span> (additionalParameters != <span class="hljs-keyword">null</span>) &#123;params.putAll(additionalParameters);&#125;<span class="hljs-keyword">return</span> postForAccessGrant(accessTokenUrl, params);&#125;</code></pre><p>这个方法就是OAuth2中通过<code>accessToken</code>换取令牌的方法，那么它上面设了一些参数，到<code>postForAccessGrant</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AccessGrant <span class="hljs-title">postForAccessGrant</span><span class="hljs-params">(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;<span class="hljs-keyword">return</span> extractAccessGrant(getRestTemplate().postForObject(accessTokenUrl, parameters, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;</code></pre><p>用它自己的<code>restTemplate</code>发了一个post请求，发出去的<code>post</code>请求在回来的时候要把响应的数据转换成一个<code>map</code>，它用<code>restTemplate</code>，就意味着它期望返回来的是一个<code>json</code>格式的数据，然后返回<code>content type</code>也是一个<code>application/json</code>，而刚才看到的错误信息里返回来的是一个<code>text/html</code>，所以报了这么一个错误，报了这个错误以后它就会被捕获到它就会返回<code>null</code>，然后往下走的：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273714849.png" srcset="/img/loading.gif" alt="1567273714849"></p><p>如果<code>token</code>返回<code>null</code>那么它这里也就返回<code>null</code>，到这返回<code>null</code>，<code>Social</code>又抛出了一个异常</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273869452.png" srcset="/img/loading.gif" alt="1567273869452"></p><p>然后它就会被<code>AbstractAuthenticationProcessingFilter</code>捕获到</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567273908737.png" srcset="/img/loading.gif" alt="1567273908737"></p><p>最后会调用失败处理器上去</p><p><code>SocialAuthenticationFilter</code>的失败处理器：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SimpleUrlAuthenticationFailureHandler delegateAuthenticationFailureHandler;<span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();<span class="hljs-keyword">private</span> String filterProcessesUrl = DEFAULT_FILTER_PROCESSES_URL;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SocialAuthenticationFilter</span><span class="hljs-params">(AuthenticationManager authManager, UserIdSource userIdSource, UsersConnectionRepository usersConnectionRepository, SocialAuthenticationServiceLocator authServiceLocator)</span> </span>&#123;<span class="hljs-keyword">this</span>.delegateAuthenticationFailureHandler = <span class="hljs-keyword">new</span> SimpleUrlAuthenticationFailureHandler(DEFAULT_FAILURE_URL);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_FAILURE_URL = <span class="hljs-string">"/signin"</span>;</code></pre><p>它会将我们当前应用重定向到<code>DEFAULT_FAILURE_URL</code>路径上去，也就是<code>/signin</code>，往这去跳，因为在<code>browser配置</code>中没做这个请求的授权，所以就在浏览器中响应请先授权的信息</p><hr><p>现在问题的根源找到了，它的<code>OAuth2RestTemplate</code>是不能处理<code>html</code>这种<code>content type</code>的响应的，为什么不能处理：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RestTemplate <span class="hljs-title">createRestTemplate</span><span class="hljs-params">()</span> </span>&#123;ClientHttpRequestFactory requestFactory = ClientHttpRequestFactorySelector.getRequestFactory();RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate(requestFactory);List&lt;HttpMessageConverter&lt;?&gt;&gt; converters = <span class="hljs-keyword">new</span> ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(<span class="hljs-number">2</span>);converters.add(<span class="hljs-keyword">new</span> FormHttpMessageConverter());converters.add(<span class="hljs-keyword">new</span> FormMapHttpMessageConverter());converters.add(<span class="hljs-keyword">new</span> MappingJackson2HttpMessageConverter());restTemplate.setMessageConverters(converters);restTemplate.setErrorHandler(<span class="hljs-keyword">new</span> LoggingErrorHandler());<span class="hljs-keyword">if</span> (!useParametersForClientAuthentication) &#123;List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();<span class="hljs-keyword">if</span> (interceptors == <span class="hljs-keyword">null</span>) &#123;   <span class="hljs-comment">// defensively initialize list if it is null. (See SOCIAL-430)</span>interceptors = <span class="hljs-keyword">new</span> ArrayList&lt;ClientHttpRequestInterceptor&gt;();restTemplate.setInterceptors(interceptors);&#125;interceptors.add(<span class="hljs-keyword">new</span> PreemptiveBasicAuthClientHttpRequestInterceptor(clientId, clientSecret));&#125;<span class="hljs-keyword">return</span> restTemplate;&#125;</code></pre><p>它在加创建<code>RestTemplate</code>往里面加<code>HttpMessageConverter</code>的时候，它没有加处理<code>text/html contont type</code>这种<code>HttpMessageConverter</code>，所以现在要做的事情就是替换掉这个<code>OAuth2</code>默认的的<code>createRestTemplate</code>，写一个自己的实现，然后在自己的实现里多加一个<code>HttpMessageConverter</code>，让它可以处理<code>text/html</code>的<code>contont type</code>；</p><p>首选创建一个类实现<code>OAuth2Template</code>，这里首先加上<code>MessageConverter</code>的支持</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.connect;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.AccessGrant;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.OAuth2Template;<span class="hljs-keyword">import</span> org.springframework.util.MultiValueMap;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQOAuth2Template</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OAuth2Template</span> </span>&#123;      <span class="hljs-comment">//...</span>      <span class="hljs-comment">//重写createRestTemplate，解决不能处理text/html</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> RestTemplate <span class="hljs-title">createRestTemplate</span><span class="hljs-params">()</span> </span>&#123;      RestTemplate restTemplate = <span class="hljs-keyword">super</span>.createRestTemplate();      restTemplate.getMessageConverters().add(<span class="hljs-keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="hljs-string">"UTF-8"</span>)));      <span class="hljs-keyword">return</span> restTemplate;   &#125; &#125;</code></pre><p>这里还有一个问题，按照 <code>OAuth2</code>默认的想法来说，它发出的请求发响应的结果是一个<code>json</code></p><p><code>org.springframework.social.oauth2.OAuth2Template#postForAccessGrant：</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> AccessGrant <span class="hljs-title">postForAccessGrant</span><span class="hljs-params">(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;<span class="hljs-keyword">return</span> extractAccessGrant(getRestTemplate().postForObject(accessTokenUrl, parameters, Map<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;&#125;</code></pre><p>它把json解析成一个<code>map</code>传给<code>extractAccessGrant</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> AccessGrant <span class="hljs-title">extractAccessGrant</span><span class="hljs-params">(Map&lt;String, Object&gt; result)</span> </span>&#123;<span class="hljs-keyword">return</span> createAccessGrant((String) result.get(<span class="hljs-string">"access_token"</span>), (String) result.get(<span class="hljs-string">"scope"</span>), (String) result.get(<span class="hljs-string">"refresh_token"</span>), getIntegerValue(result, <span class="hljs-string">"expires_in"</span>), result);&#125;</code></pre><p>在这个方法里面它从这个<code>map</code>中去获取<code>access_token</code>、<code>refresh_token</code>、<code>scope</code>、<code>expires_in</code>，这4个字段，然后拿这4个字段去实例化一个<code>AccessGrant</code>，这个<code>AccessGrant</code>类是对<code>OAuth协议</code>中访问令牌<code>access_token</code>的封装，这是它默认的一个想法，但是在实际上呢？来看看QQ互联上的</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567275464175.png" srcset="/img/loading.gif" alt="1567275464175"></p><p>这里的说明，它最终返回是并不是一个json</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567275497959.png" srcset="/img/loading.gif" alt="1567275497959"></p><p>而是这样的字符串，用<strong>&amp;</strong>隔开的3个字段,下面针对这种特殊的响应格式来进行一个处理，这里通过&amp;进行分割，然后一个个获取=后面的值来获取<code>accessToken</code>、<code>expiresIn</code>、<code>refreshToken</code>来实例化<code>AccessGrant</code></p><pre><code class="hljs java"><span class="hljs-comment">//qq互联获取accessToke的响应返回的是&amp;拼接的字符串</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> AccessGrant <span class="hljs-title">postForAccessGrant</span><span class="hljs-params">(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;      String responseStr = getRestTemplate().postForObject(accessTokenUrl, parameters, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"获取accessToke的响应："</span>+responseStr);            String[] items = StringUtils.splitByWholeSeparatorPreserveAllTokens(responseStr, <span class="hljs-string">"&amp;"</span>);            String accessToken = StringUtils.substringAfterLast(items[<span class="hljs-number">0</span>], <span class="hljs-string">"="</span>);      Long expiresIn = <span class="hljs-keyword">new</span> Long(StringUtils.substringAfterLast(items[<span class="hljs-number">1</span>], <span class="hljs-string">"="</span>));      String refreshToken = StringUtils.substringAfterLast(items[<span class="hljs-number">2</span>], <span class="hljs-string">"="</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessGrant(accessToken, <span class="hljs-keyword">null</span>, refreshToken, expiresIn);   &#125;</code></pre><p>最后一个问题：我们来看一下调用这个<code>postForAccessGrant</code>之前拼装的一些参数的时候的逻辑；org.springframework.social.oauth2.OAuth2Template#exchangeForAccess：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AccessGrant <span class="hljs-title">exchangeForAccess</span><span class="hljs-params">(String authorizationCode, String redirectUri, MultiValueMap&lt;String, String&gt; additionalParameters)</span> </span>&#123;MultiValueMap&lt;String, String&gt; params = <span class="hljs-keyword">new</span> LinkedMultiValueMap&lt;String, String&gt;();<span class="hljs-keyword">if</span> (useParametersForClientAuthentication) &#123;params.set(<span class="hljs-string">"client_id"</span>, clientId);params.set(<span class="hljs-string">"client_secret"</span>, clientSecret);&#125;params.set(<span class="hljs-string">"code"</span>, authorizationCode);params.set(<span class="hljs-string">"redirect_uri"</span>, redirectUri);params.set(<span class="hljs-string">"grant_type"</span>, <span class="hljs-string">"authorization_code"</span>);<span class="hljs-keyword">if</span> (additionalParameters != <span class="hljs-keyword">null</span>) &#123;params.putAll(additionalParameters);&#125;<span class="hljs-keyword">return</span> postForAccessGrant(accessTokenUrl, params);&#125;</code></pre><p>这里有5个参数，在QQ互联上也要求5个参数</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567275898849.png" srcset="/img/loading.gif" alt="1567275898849"></p><p>这里是<code>OAuth协议</code>要求的，所以使用这个方法就可以了，但是这有一个，它有一个属性叫做<code>useParametersForClientAuthentication</code>，只有这个属性是<code>true</code>才会带入<code>client_id</code>、<code>client_secret</code>，在默认情况下它为<code>false</code>，所以在我们写的代码中的构造函数这，调用<code>useParametersForClientAuthentication</code>的set方法，给它改为<code>true</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQOAuth2Template</span><span class="hljs-params">(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl)</span> </span>&#123;     <span class="hljs-keyword">super</span>(clientId, clientSecret, authorizeUrl, accessTokenUrl);     <span class="hljs-comment">//useParametersForClientAuthentication为true时exchangeForAccess方法。才会setclientId</span>     setUseParametersForClientAuthentication(<span class="hljs-keyword">true</span>);  &#125;</code></pre><p>完整代码：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social.qq.connect;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.http.converter.StringHttpMessageConverter;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.AccessGrant;<span class="hljs-keyword">import</span> org.springframework.social.oauth2.OAuth2Template;<span class="hljs-keyword">import</span> org.springframework.util.MultiValueMap;<span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<span class="hljs-keyword">import</span> java.nio.charset.Charset;<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QQOAuth2Template</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OAuth2Template</span> </span>&#123;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQOAuth2Template</span><span class="hljs-params">(String clientId, String clientSecret, String authorizeUrl, String accessTokenUrl)</span> </span>&#123;      <span class="hljs-keyword">super</span>(clientId, clientSecret, authorizeUrl, accessTokenUrl);      <span class="hljs-comment">//useParametersForClientAuthentication为true时exchangeForAccess方法。才会setclientId</span>      setUseParametersForClientAuthentication(<span class="hljs-keyword">true</span>);   &#125;      <span class="hljs-comment">//qq互联获取accessToke的响应返回的是&amp;拼接的字符串</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> AccessGrant <span class="hljs-title">postForAccessGrant</span><span class="hljs-params">(String accessTokenUrl, MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;      String responseStr = getRestTemplate().postForObject(accessTokenUrl, parameters, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;            log.info(<span class="hljs-string">"获取accessToke的响应："</span>+responseStr);            String[] items = StringUtils.splitByWholeSeparatorPreserveAllTokens(responseStr, <span class="hljs-string">"&amp;"</span>);            String accessToken = StringUtils.substringAfterLast(items[<span class="hljs-number">0</span>], <span class="hljs-string">"="</span>);      Long expiresIn = <span class="hljs-keyword">new</span> Long(StringUtils.substringAfterLast(items[<span class="hljs-number">1</span>], <span class="hljs-string">"="</span>));      String refreshToken = StringUtils.substringAfterLast(items[<span class="hljs-number">2</span>], <span class="hljs-string">"="</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AccessGrant(accessToken, <span class="hljs-keyword">null</span>, refreshToken, expiresIn);   &#125;      <span class="hljs-comment">//重写createRestTemplate，解决不能处理text/html</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> RestTemplate <span class="hljs-title">createRestTemplate</span><span class="hljs-params">()</span> </span>&#123;      RestTemplate restTemplate = <span class="hljs-keyword">super</span>.createRestTemplate();      restTemplate.getMessageConverters().add(<span class="hljs-keyword">new</span> StringHttpMessageConverter(Charset.forName(<span class="hljs-string">"UTF-8"</span>)));      <span class="hljs-keyword">return</span> restTemplate;   &#125; &#125;</code></pre><p> 修改com.b4.mcr.auth.core.social.qq.connect.QQServiceProvider#QQServiceProvider</p><pre><code class="hljs java"><span class="hljs-comment">//提供OAuth2Operations</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QQServiceProvider</span><span class="hljs-params">(String appId, String appSecret)</span> </span>&#123;      <span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> QQOAuth2Template(appId, appSecret, URL_AUTHORIZE, URL_ACCESS_TOKEN));      <span class="hljs-keyword">this</span>.appId = appId;  &#125;</code></pre><h1 id="处理注册逻辑"><a href="#处理注册逻辑" class="headerlink" title="处理注册逻辑"></a>处理注册逻辑</h1><p>现在扫完码，浏览器的响应：</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"content"</span>: <span class="hljs-string">"请引导用户跳转到登录页面"</span>&#125;</code></pre><p>控制台上：</p><pre><code class="hljs angelscript"><span class="hljs-number">2019</span><span class="hljs-number">-09</span><span class="hljs-number">-01</span> <span class="hljs-number">09</span>:<span class="hljs-number">55</span>:<span class="hljs-number">49.188</span>  INFO <span class="hljs-number">22124</span> --- [p-nio<span class="hljs-number">-80</span>-exec<span class="hljs-number">-2</span>] c.b.m.a.b.BrowserSecurityController      : 引发跳转的请求-&gt;http:<span class="hljs-comment">//www.pinzhi365.com/signup</span></code></pre><p>现在与刚才不同，这里跳转到了<code>/signup</code>地址</p><hr><p>现在debug，来跟一下源码，在<code>SocialAuthenticationProvider</code>64行</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303470227.png" srcset="/img/loading.gif" alt="1567303470227"></p><p><code>SocialAuthenticationFilter</code>333行打端点</p><hr><p>然后来扫码进行登录，</p><p>在<code>authenticate</code>，中的<code>connection</code>，就是服务提供商给的用户信息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303654006.png" srcset="/img/loading.gif" alt="1567303654006"></p><p>，这里调用了一个<code>toUserId</code>方法，将<code>connection</code>对象传递进去，这里的<code>toUserId</code>是在我们数据库的<code>UsersConnection</code>表里面根据<code>openId</code>去查询<code>userId</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303706754.png" srcset="/img/loading.gif" alt="1567303706754"></p><p>因为<code>UsersConnection</code>表里面没有数据，所以是<code>null</code>的，那么就会抛出一个异常</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303811677.png" srcset="/img/loading.gif" alt="1567303811677"></p><p><code>SocialAuthenticationFilter#doAuthentication</code>捕获到了抛出的异常，它会判断<code>signupUrl</code>属性是不是空的，如果是空的，它会认为你设置了一个注册的页面，那么它就会抛出<code>SocialAuthenticationRedirectException</code>异常，<code>SpringSocial</code>拿到这个异常就会跳转到你指定的注册页的URL上，默认的注册页面就是<code>/signup</code>，因为在配置中没有做授权，所以会被拦下来，响应需要授权的提示信息</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303877749.png" srcset="/img/loading.gif" alt="1567303877749"></p><hr><p>以上就是产生最终结果的原因，如何解决这个问题呢？其实很简单，我们去写一个注册页，然后把这个<code>signupUrl</code>配置成自己写的注册页，在到<code>BrowserSecurityConfig</code>配置一下URL，不经过身份认证就可以访问，首先在<code>mcr-auth-browser</code>中写默认的注册页：</p><p>mcr-signUp.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标准注册页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标准注册页<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>这是系统注册页面，请配置mcr.b4.security.browser.signUpUrl属性来设置自己的注册页<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>BrowserSecurityProperties：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> String signUpUrl = <span class="hljs-string">"/mcr-signUp.html"</span>;</code></pre><p>在<code>demo模块</code>中，使用自己的注册页：</p><blockquote><p>这里表单中的action，不用管他，因为每个注册的逻辑都不一样，因为这里有2种可能，这个用户在使用者的系统中是一个全新的用户，它以前没有用用户名密码登录过，这个时候他可能是注册一个全新的用户，另外一种可能是这个用户以前他有自己的用户名密码，这个时候他要做的事情可能就不是一个注册了，是一个绑定，他要把当前的QQ用户绑定到系统的账户上去</p></blockquote><p>demo-signUp.html</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Demo注册页<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/user/regist"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"userName"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"type"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"regist"</span>&gt;</span>注册<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"type"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"binding"</span>&gt;</span>绑定<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>然后使用者需要自己写注册逻辑；</p><p>UserController</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/regist"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">regist</span><span class="hljs-params">(UserVO userVO)</span> </span>&#123;      <span class="hljs-comment">//注册用户...</span>  &#125;</code></pre><p>yml</p><pre><code class="hljs yml"><span class="hljs-attr">mcr:</span>  <span class="hljs-attr">b4:</span>    <span class="hljs-attr">security:</span>      <span class="hljs-attr">browser:</span>        <span class="hljs-attr">signUpUrl:</span> <span class="hljs-string">/demo-signUp.html</span></code></pre><p>BrowserSecurityConfig</p><pre><code class="hljs java">.antMatchers(                      browser.getSignUpUrl(),</code></pre><p>在<code>Social配置</code>中告诉<code>SocialAuthenticationFilter</code>跳转的注册页面路径在哪里</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialConfigurerAdapter</span> </span>&#123;<span class="hljs-comment">//...</span> <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> SpringSocialConfigurer <span class="hljs-title">mcrSpringSocialConfigurer</span><span class="hljs-params">()</span> </span>&#123;        McrSpringSocialConfigurer mcrSpringSocialConfigurer = <span class="hljs-keyword">new</span> McrSpringSocialConfigurer(securityProperties.getSocial().getFilterProcessesUrl());        mcrSpringSocialConfigurer.signupUrl(securityProperties.getBrowser().getSignUpUrl());        <span class="hljs-keyword">return</span> mcrSpringSocialConfigurer;    &#125;&#125;</code></pre><hr><p>现在进行登录就能跳转到指定的注册页面上去了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567307154192.png" srcset="/img/loading.gif" alt="1567307154192"></p><hr><p>现在它能跳到自己写demo注册页面上去了，现在有2个问题：</p><ol><li>在demo页面上，我不想干巴巴就显示登录页，我可能要显示一些跟当前用户信息相关的一些消息，比如你当前在用QQ的哪个账号登录，然后把头像显示给用户，告诉用户你是在用这个账号在登录，你 是要注册一个新用户还是要把这个QQ绑定已有的用户上，这样让用户的感觉更友好，在注册页上如何拿到我在之前OAuth流程里拿到的社交用户的信息？</li><li>我在点注册或者绑定以后，我这个请求提交到我demo项目的绑定、注册请求进行处理，不管是注册还是绑定最终我能确定用户的唯一标识，那么也就是我们说的<code>userId</code>，如何把这个<code>userId</code>在传给<code>SpringSocial</code>，让<code>SpringSocial</code>把用户id跟我之前拿到的那些社交用户的信息一起存到数据库<code>UserConnection</code>表里面去？</li></ol><p>为了处理这2个问题，<code>Spring</code>提供了一个工具类：<code>ProviderSignInUtils</code></p><p>SocialConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> ProviderSignInUtils <span class="hljs-title">providerSignInUtils</span><span class="hljs-params">(ConnectionFactoryLocator connectionFactoryLocator)</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProviderSignInUtils(connectionFactoryLocator,              getUsersConnectionRepository(connectionFactoryLocator));  &#125;</code></pre><p>先定义一个相应数据的类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.model.vo;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialUserInfoVO</span> </span>&#123;    <span class="hljs-keyword">private</span> String providerId;    <span class="hljs-keyword">private</span> String providerUserId;    <span class="hljs-keyword">private</span> String nickname;    <span class="hljs-keyword">private</span> String headimg;&#125;</code></pre><p>BrowserSecurityController：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@Slf</span>4j-<span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/authentication"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityController</span> </span>&#123;   <span class="hljs-comment">//properties....</span>      <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ProviderSignInUtils providerSignInUtils;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/social/user"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> SocialUserInfoVO <span class="hljs-title">getSocialUserInfo</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;        SocialUserInfoVO socialUserInfoVO = <span class="hljs-keyword">new</span> SocialUserInfoVO();        Connection&lt;?&gt; connection = providerSignInUtils.getConnectionFromSession(<span class="hljs-keyword">new</span> ServletWebRequest(request, response));        socialUserInfoVO.setProviderId(connection.getKey().getProviderId());        socialUserInfoVO.setProviderUserId(connection.getKey().getProviderUserId());        socialUserInfoVO.setNickname(connection.getDisplayName());        socialUserInfoVO.setHeadimg(connection.getImageUrl());        <span class="hljs-keyword">return</span> socialUserInfoVO;    &#125;    +    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/authentication/require"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> McrSecurityVO <span class="hljs-title">requireAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;      <span class="hljs-comment">//...</span>    &#125;&#125;</code></pre><p><code>ProviderSignInUtils</code>是从<code>session</code>里面拿<code>Connection</code>信息的，<code>Connection</code>是什么时候放到<code>session</code>里面的呢？</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567303877749.png" srcset="/img/loading.gif" alt="1567303877749"></p><p>还记得之前介绍的这个代码吧？</p><p>后面它执行了一段，它是在跳转页面之前，把<code>Connection</code>从<code>token</code>里拿出来，放到<code>session</code>中，然后把跳放入<code>session</code>以后跳到了我们的注册页上去</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (signupUrl != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// store ConnectionData in session and redirect to register page</span>sessionStrategy.setAttribute(<span class="hljs-keyword">new</span> ServletWebRequest(request), ProviderSignInAttempt.SESSION_ATTRIBUTE, <span class="hljs-keyword">new</span> ProviderSignInAttempt(token.getConnection()));<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocialAuthenticationRedirectException(buildSignupUrl(request));&#125;</code></pre><p>，然后我现在去发写好的<code>/social/user</code>，请求，从<code>session</code>中拿出来，拼成用户信息给前端。</p><p>现在用户完成注册过程以后，不管是注册还是绑定，它都会拿到用户的唯一标识，如何把这个唯一标识给我们的<code>SpringSocial</code>？</p><p>UserController</p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ProviderSignInUtils providerSignInUtils;    <span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/regist"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">regist</span><span class="hljs-params">(UserVO userVO, HttpServletResponse response, HttpServletRequest request)</span> </span>&#123;        <span class="hljs-comment">//不管是注册用户还是绑定用户，都会拿到一个用户唯一标识</span>        String userId = userVO.getUserName();        <span class="hljs-comment">//以下省略注册、绑定逻辑....</span>        providerSignInUtils.doPostSignUp(userId, <span class="hljs-keyword">new</span> ServletWebRequest(request, response));    &#125;</code></pre><p>这里通过<code>ProviderSignInUtils</code>的<code>doPostSignUp</code>就能把数据插入到数据库中的<code>UsersConnection</code>表里面去了，现在把这个注册请求配置一下，让它不用授权就能访问</p><p>BrowserSecurityProperties：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * 注册请求</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> String registUrl = <span class="hljs-string">"/user/regist"</span>;</code></pre><p>BrowserSecurityConfig：</p><pre><code class="hljs java">.antMatchers(        browser.getRegistUrl(), <span class="hljs-comment">//...</span></code></pre><p>现在还有一个问题：QQ扫码登录，整个流程跑通了，可是每次都会跳转到注册页面上去，这什么怎么回事？在SocialAuthenticationProvider#authenticate中：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567318854639.png" srcset="/img/loading.gif" alt="1567318854639"></p><p>这里依然拿不到<code>userId</code>，所以抛出异常，然后捕获到了，<code>SpringSocial</code>就认为在表里没有进行注册，那么就跳转注册页面上了，但是我们数据库的<code>UsersConnection</code>表里面有数据啊？为什么会查不到数据？</p><p>现在就来跟一下这个<code>toUserId</code>方法。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567319073110.png" srcset="/img/loading.gif" alt="1567319073110"></p><p>这里看到，它这使用的<code>UsersConnectionRepository</code>实现类是<code>InMemoryUsersConnectionRepository</code>，没有用我们配置的<code>JdbcUsersConnectionRepository</code>，所以需要在我们的配置类中加上<code>@Order</code>注解</p><pre><code class="hljs java"><span class="hljs-meta">@Order</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocialConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SocialConfigurerAdapter</span></span></code></pre><p>因为什么要这么做？因为<code>SpringSocial</code>中的配置，比这个<code>SocialConfig</code>配置先执行了，而它那边的默认的</p><p><code>UsersConnectionRepository</code>是<code>InMemoryUsersConnectionRepository</code>，所以这里就必须比它先执行。</p><hr><p>这个注册是需要用户手动输入的，有些时候不想这么做，微信、QQ登录以后，虽然这个用户在系统里没有这个用户，但是我不要求你去注册，我直接偷偷的给你注册一个用户，你就可以不用跳到刚刚那个注册页面去，直接让用户进系统</p><hr><p>在开始代码之前，先来看一下源码；</p><p>SocialAuthenticationProvider：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567321588180.png" srcset="/img/loading.gif" alt="1567321588180"></p><p>这里通过<code>UsersConnectionRepository</code>，也就是<code>JdbcUsersConnectionRepository</code>，通过它的<code>findUserIdsWithConnection</code>方法来拿取<code>userId</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findUserIdsWithConnection</span><span class="hljs-params">(Connection&lt;?&gt; connection)</span> </span>&#123;ConnectionKey key = connection.getKey();List&lt;String&gt; localUserIds = jdbcTemplate.queryForList(<span class="hljs-string">"select userId from "</span> + tablePrefix + <span class="hljs-string">"UserConnection where providerId = ? and providerUserId = ?"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">key</span>.<span class="hljs-title">getProviderId</span>(), <span class="hljs-title">key</span>.<span class="hljs-title">getProviderUserId</span>())</span>;<span class="hljs-keyword">if</span> (localUserIds.size() == <span class="hljs-number">0</span> &amp;&amp; connectionSignUp != <span class="hljs-keyword">null</span>) &#123;String newUserId = connectionSignUp.execute(connection);<span class="hljs-keyword">if</span> (newUserId != <span class="hljs-keyword">null</span>)&#123;createConnectionRepository(newUserId).addConnection(connection);<span class="hljs-keyword">return</span> Arrays.asList(newUserId);&#125;&#125;<span class="hljs-keyword">return</span> localUserIds;&#125;</code></pre><p>这里通过<code>jdbcTemplate</code>执行<code>sql语句</code>，然后判断这个<code>sql语句</code>获取到数据是不是空的，如果不是空的，它就会执行：</p><pre><code class="hljs java">String newUserId = connectionSignUp.execute(connection);</code></pre><p>​    这里的<code>connectionSignUp</code>是<code>ConnectionSignUp</code>接口，它这没有实现类，所以它这里对象是空的，就不会走里面的代码，我们这这里定义一个类实现这个接口，在execute调用自己的注册方法，然后返回我们业务系统里面的<code>userId</code>出去，也就是上面代码的<code>newUserId</code>，如果不为<code>null</code>，它会执行</p><pre><code class="hljs java">createConnectionRepository(newUserId).addConnection(connection);</code></pre><p>这里它将<code>newUserId</code>和<code>Connection</code>信息一起插到数据库里，建一条记录，也就是它根据你社交账号信息，默认的帮你注册然后登录上，就是这么一个逻辑</p><hr><p>现在我们要做的就是给<code>JdbcUsersConnectionRepository</code>添加一个<code>ConnectionSignUp</code>实现类，给它里面的<code>connectionSignUp</code>赋值</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security;<span class="hljs-keyword">import</span> org.springframework.social.connect.Connection;<span class="hljs-keyword">import</span> org.springframework.social.connect.ConnectionSignUp;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoConnectionSignUp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConnectionSignUp</span> </span>&#123;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see org.springframework.social.connect.ConnectionSignUp#execute(org.springframework.social.connect.Connection)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">execute</span><span class="hljs-params">(Connection&lt;?&gt; connection)</span> </span>&#123;<span class="hljs-comment">//根据社交用户信息默认创建用户并返回用户唯一标识</span><span class="hljs-keyword">return</span> connection.getDisplayName();&#125;&#125;</code></pre><p>SocialConfig:</p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)    <span class="hljs-keyword">private</span> ConnectionSignUp connectionSignUp;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UsersConnectionRepository <span class="hljs-title">getUsersConnectionRepository</span><span class="hljs-params">(ConnectionFactoryLocator connectionFactoryLocator)</span> </span>&#123;     <span class="hljs-comment">//...</span>        <span class="hljs-keyword">if</span> (connectionSignUp != <span class="hljs-keyword">null</span>) &#123;            repository.setConnectionSignUp(connectionSignUp);        &#125;        <span class="hljs-keyword">return</span> repository;    &#125;</code></pre><h1 id="绑定和解绑处理"><a href="#绑定和解绑处理" class="headerlink" title="绑定和解绑处理"></a>绑定和解绑处理</h1><p>绑定的流程和QQ登录流程是一样的，不一样的地方：我在QQ登录，开始走流程的时候，我是不知道当前系统的登录账号是谁的，因为要在走完流程以后用拿到的社交账号去登录系统，而绑定账号是已经知道当前用户是谁了，然后再去走那个流程，结束以后把系统账号和社交账号进行一个关联，<code>SpringSocial</code>对这样的场景提供了默认支持，下面来看一下，如何在<code>SpringSocial</code>提供的默认支持自己写代码，实现这个场景</p><hr><h2 id="查询绑定状态"><a href="#查询绑定状态" class="headerlink" title="查询绑定状态"></a>查询绑定状态</h2><p>现在需要3个服务：</p><ol><li>获取所有的社交网站的绑定信息，假设我们系统中要求有QQ、微信、微博3种，那么首先就要先查询当前用户的绑定信息</li><li>绑定信息</li><li>解除绑定信息</li></ol><p>这3个服务<code>SpringSocial</code>都为我们提供了，我们要做的就是去调它的服务</p><p>获取当前登录账号绑定信息的服务：</p><pre><code class="hljs http"><span class="hljs-attribute">http://www.pinzhi365.com/connect</span></code></pre><p>这个服务页面响应内容：</p><pre><code class="hljs routeros">Whitelabel <span class="hljs-builtin-name">Error</span> PageThis application has <span class="hljs-literal">no</span> explicit mapping <span class="hljs-keyword">for</span> /error, so you are seeing this as a fallback.Sun Sep 01 19:46:33 CST 2019There was an unexpected <span class="hljs-builtin-name">error</span> (<span class="hljs-attribute">type</span>=Method <span class="hljs-keyword">Not</span> Allowed, <span class="hljs-attribute">status</span>=405).Request method <span class="hljs-string">'GET'</span> <span class="hljs-keyword">not</span> supported</code></pre><p>控制台：</p><pre><code class="hljs oxygene"><span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">01</span> <span class="hljs-number">19</span>:<span class="hljs-number">46</span>:<span class="hljs-number">33.658</span>  WARN <span class="hljs-number">52916</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">8</span>] o.s.web.servlet.PageNotFound             : Request <span class="hljs-function"><span class="hljs-keyword">method</span> '<span class="hljs-title">GET</span>' <span class="hljs-title">not</span> <span class="hljs-title">supported</span></span></code></pre><p>为什么会出现这个错误？来看一下<code>ConnectController</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567338754296.png" srcset="/img/loading.gif" alt="1567338754296"></p><p>这个类就是刚才访问<code>/connect</code>请求的处理器，当请求这个URL的时候会调用以下方法：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(method=RequestMethod.GET)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">connectionStatus</span><span class="hljs-params">(NativeWebRequest request, Model model)</span> </span>&#123;setNoCache(request);processFlash(request, model);Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt; connections = connectionRepository.findAllConnections();model.addAttribute(<span class="hljs-string">"providerIds"</span>, connectionFactoryLocator.registeredProviderIds());model.addAttribute(<span class="hljs-string">"connectionMap"</span>, connections);<span class="hljs-keyword">return</span> connectView();&#125;</code></pre><p>在这里通过<code>Model</code>来存储了一些数据，而这里的数据，就是我们要的绑定信息</p><p>，这里它没用使用<code>@ResponseBody</code>注解，那么就意味着，它会跳转到一个页面上去，它这里返回的是一个方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">connectView</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> getViewPath() + <span class="hljs-string">"status"</span>;&#125;</code></pre><p>在这里设置一个端点，继续访问：<a href="http://www.pinzhi365.com/connect，" target="_blank" rel="noopener">http://www.pinzhi365.com/connect，</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567341713955.png" srcset="/img/loading.gif" alt="1567341713955"></p><p>这里的providerIds就是绑定信息了，然后看一下返回结果：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567341566840.png" srcset="/img/loading.gif" alt="1567341566840"></p><p>这里返回<code>connect/status</code>，这是一个视图的名字，因为在我们这里没有写这个视图，所以就出去</p><pre><code class="hljs oxygene"><span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">01</span> <span class="hljs-number">19</span>:<span class="hljs-number">46</span>:<span class="hljs-number">33.658</span>  WARN <span class="hljs-number">52916</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">8</span>] o.s.web.servlet.PageNotFound             : Request <span class="hljs-function"><span class="hljs-keyword">method</span> '<span class="hljs-title">GET</span>' <span class="hljs-title">not</span> <span class="hljs-title">supported</span></span></code></pre><p>提示信息</p><hr><p>现在就来写一下这个视图</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"connect/status"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrConnectionStatusView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractView</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt; connections = (Map&lt;String, List&lt;Connection&lt;?&gt;&gt;&gt;) model.get(<span class="hljs-string">"connectionMap"</span>);        Map&lt;String, Boolean&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (String key : connections.keySet()) &#123;            result.put(key, CollectionUtils.isNotEmpty(connections.get(key)));        &#125;        response.setContentType(<span class="hljs-string">"application/json;charset=UTF-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(result));    &#125;&#125;</code></pre><p>这里说一下：它的<code>model</code>参数存储了之前说的<code>org.springframework.social.connect.web.ConnectController#connectionStatus(org.springframework.web.context.request.NativeWebRequest, org.springframework.ui.Model)</code>中通过<code>model</code>存储的数据，这通过<code>model</code>那出来，做一些处理，响应出去就完成查询绑定信息功能了，现在访问<a href="http://www.pinzhi365.com/connect的响应结果：" target="_blank" rel="noopener">http://www.pinzhi365.com/connect的响应结果：</a></p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"callback.do"</span>: <span class="hljs-literal">true</span>&#125;</code></pre><p>这里做查询绑定信息要注意：你认证成功，放到<code>session</code>里的<code>UserDetails</code>一定要是一个<code>SocialUserDetails</code>，也就是说我们自己写的<code>McrUserDetailsService</code>这里的返回值要是SocialUserDetails的实现，因为只有在这个接口才有<code>getUserId</code>方法，它才能拿到你的用户id，在表里面去查，如果你返回的是一个<code>UserDetails</code>接口的实现就没有这个方法的，所以这个功能就没法实现了</p><h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>browser：mcr-banding.html </p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>标准绑定页面<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/connect/callback.do"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>绑定QQ<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>这里的<code>/connect/callback.do</code>，<code>/connect</code>是固定的，后面的<code>callback.do</code>是<code>providerId</code>，就是之前<code>QQProperties</code>中的<code>providerId</code>属性，绑定功能完成！访问：<a href="http://www.pinzhi365.com/mcr-banding.html测试吧，这里会出现100010异常，原因是我这里的`callback.do`在org.springframework.social.connect.web.ConnectController#connect这里被`@PathVariable`注解过滤成`callback`，`.do`被忽略了，所以在QQ互联上需要将`.do`去掉，然后因为它绑定的回调地址是不一样的，它会变成http://www.pinzhi365.com/connect/callback&amp;state=eab45238-f697-49bc-b5ad-6bd6b6397a3d，所以在QQ互联上要写2个回调请求，这里使用分号隔开" target="_blank" rel="noopener">http://www.pinzhi365.com/mcr-banding.html测试吧，这里会出现100010异常，原因是我这里的`callback.do`在org.springframework.social.connect.web.ConnectController#connect这里被`@PathVariable`注解过滤成`callback`，`.do`被忽略了，所以在QQ互联上需要将`.do`去掉，然后因为它绑定的回调地址是不一样的，它会变成http://www.pinzhi365.com/connect/callback&amp;state=eab45238-f697-49bc-b5ad-6bd6b6397a3d，所以在QQ互联上要写2个回调请求，这里使用分号隔开</a></p><blockquote><p>这里yml、页面上的请求笔者就不去写哪里要改了</p></blockquote><pre><code class="hljs http"><span class="hljs-attribute">http://www.pinzhi365.com/qqLogin/callback;http://www.pinzhi365.com/connect/callback</span></code></pre><hr><p>绑定完之后的处理</p><p>当绑定成功之后，控制台：</p><pre><code class="hljs oxygene"><span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">02</span> <span class="hljs-number">22</span>:<span class="hljs-number">10</span>:<span class="hljs-number">47.422</span>  WARN <span class="hljs-number">61344</span> --- [p-nio-<span class="hljs-number">80</span>-exec-<span class="hljs-number">6</span>] o.s.web.servlet.PageNotFound             : Request <span class="hljs-function"><span class="hljs-keyword">method</span> '<span class="hljs-title">GET</span>' <span class="hljs-title">not</span> <span class="hljs-title">supported</span></span></code></pre><p>又引发了这样的异常，这是为什么？</p><p>因为绑定完之后，<code>spring social</code>会到<code>org.springframework.social.connect.web.ConnectController#connectionStatus(java.lang.String, org.springframework.web.context.request.NativeWebRequest, org.springframework.ui.Model)</code>这个方法里面，在这里它也返回了一个视图：</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(value=<span class="hljs-string">"/&#123;providerId&#125;"</span>, method=RequestMethod.GET)<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">connectionStatus</span><span class="hljs-params">(@PathVariable String providerId, NativeWebRequest request, Model model)</span> </span>&#123;<span class="hljs-comment">//...</span><span class="hljs-keyword">if</span> (connections.isEmpty()) &#123;<span class="hljs-keyword">return</span> connectView(providerId); &#125; <span class="hljs-keyword">else</span> &#123;model.addAttribute(<span class="hljs-string">"connections"</span>, connections);<span class="hljs-keyword">return</span> connectedView(providerId);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">connectView</span><span class="hljs-params">(String providerId)</span> </span>&#123;<span class="hljs-keyword">return</span> getViewPath() + providerId + <span class="hljs-string">"Connect"</span>;&#125;</code></pre><p>通过debug，看到这里返回的是<code>connect/callbackConnected</code>，前面的connect和之前一样是固定的，而后面的则是通过<code>QQProperties</code>中的<code>providerId</code>属性+“Connected”</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567433331902.png" srcset="/img/loading.gif" alt="1567433331902"></p><p>这里就来写一个这个视图，这里因为QQ会写成<code>connect/callbackConnected</code>，那么如果我这里还有个微信、新浪的，那就又要在写一遍，但是里面的内容都是一样的。我们可以在这不用<code>@Component</code>注入到IOC中，把这个当做一个公共的，通过配置类，分别注入进去，因为每个三方登录，在我们系统中都会有一个配置类，所以可以这么来</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-keyword">import</span> org.springframework.web.servlet.view.AbstractView;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrConnectionView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractView</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(<span class="hljs-string">"&lt;h3&gt;绑定成功&lt;/h3&gt;"</span>);    &#125;&#125;</code></pre><p>QQAutoConfig：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(<span class="hljs-string">"connect/callbackConnected"</span>)   <span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"connect/callbackConnected"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">qqConnectedView</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrConnectionView();   &#125;</code></pre><h2 id="解绑"><a href="#解绑" class="headerlink" title="解绑"></a>解绑</h2><p>这里的解绑和绑定的请求是一样的，区别在于解绑的请求方式是<code>delete</code>，这里页面上无法弄delete请求，有人第一时间想到使用<code>post man</code>来访问，但是使用<code>post man</code>就不是一个会话的了，又要重新登录，不太方便，这里可以使用<code>restlet client</code>工具来访问，因为它是浏览器上面的，所以还在一个会话上</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567434697756.png" srcset="/img/loading.gif" alt="1567434697756"></p><p>这里响应了一个302，它的解绑最终也会返回到视图上去，它这里返回的视图和绑定返回的视图名字非常像，不过它在末尾少了一个ed</p><p>QQAutoConfig：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>(&#123;<span class="hljs-string">"connect/callbackConnected"</span>, <span class="hljs-string">"connect/callbackConnect"</span>&#125;)<span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"connect/callbackConnected"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">qqConnectedView</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrConnectionView();&#125;</code></pre><p>现在绑定和解绑使用了一个视图，要如何区分呢？绑定的<code>model</code>中有<code>connection</code>，而解绑中没有，可以拿来做判断，响应不同的内容</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.social;<span class="hljs-keyword">import</span> org.springframework.web.servlet.view.AbstractView;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrConnectionView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractView</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">renderMergedOutputModel</span><span class="hljs-params">(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        <span class="hljs-keyword">if</span> (model.get(<span class="hljs-string">"connection"</span>) != <span class="hljs-keyword">null</span>) &#123;            response.getWriter().write(<span class="hljs-string">"&lt;h3&gt;绑定成功&lt;/h3&gt;"</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            response.getWriter().write(<span class="hljs-string">"&lt;h3&gt;解定成功&lt;/h3&gt;"</span>);        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 三、Social 】 2.SpringSocial基本原理</title>
    <link href="/spring-security-3.2.html"/>
    <url>/spring-security-3.2.html</url>
    
    <content type="html"><![CDATA[<p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567224896676.png" srcset="/img/loading.gif" alt="1567224896676"></p><p>上一章了解到<code>OAuth</code>协议实际上就是授权协议，它的目的是让用户在不交服务提供商的用户名和密码交给第三方应用的情况下，让第三方应用可以有权限去访问用户存在的服务提供商上的一些资源，这个是<code>OAuth</code>协议存在的目的，那么这个授权协议和我们要实现的第三方登录是什么关系呢？先来说下这个问题，在上一章例子中，我们走完这个授权协议拿到令牌以后，说的场景是拿用户的自拍数据，但是如果我不去拿用户的自拍数据，而是拿用户的基本信息，比如它的昵称、头像，我拿到了这些数据信息以后，我根据用户信息构建<code>Authentication</code>，放进<code>SecurityContext</code>里面，这里2个类之前说过了，读者应该还有印象，当你往<code>SecurityContext</code>里面放入经过验证的<code>Authentication</code>实例的时候，实际对<code>SpringSecurity</code>来说已经登录成功了，如果我们引导用户走完这个流程实际上就相当于用户使用了它在服务提供商上的用户基本信息登录了我们的第三方应用，这个就是所谓的第三方登录（QQ、微信登录），它的一个实现基本原理和流程，那么<code>SpringSocial</code>是干什么的呢？它实际上就是把这个流程，给你封装起来实现了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567224268835.png" srcset="/img/loading.gif" alt="1567224268835"></p><p><code>SpringSocial</code>它把整个流程封装到了<code>SocialAuthenticationFilter</code>过滤器里面，然后把这个过滤器加到了<code>SpringSecurity</code>的过滤器链上，这样当你访问每一个请求的时候，<code>SocialAuthenticationFilter</code>会把这个请求拦下来，然后带着你把图1的流程走完，实际上也就是实现了微信、QQ登录，这个就是它的核心事情</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567227175116.png" srcset="/img/loading.gif" alt="1567227175116"></p><p>图1是一个逻辑图，现在来看一下在<code>SpringSocial</code>它是如何把这样一个流程封装到<code>SpringSocial</code>特有的一些接口和类里面的。</p><hr><p>首先介绍一下<code>ServiceProvider</code>，它是图1中服务提供商的抽象，针对每一个具体的服务提供商，比如QQ、微信、新浪，你都需要提供一个<code>ServiceProvider</code>的实现类，<code>SpringSocial</code>给我们 提供了一个<code>AbstractOAuth2ServiceProvider</code>，这样一个抽象类，它给我们实现了一些共有的东西，比如你想实现QQ服务提供商实现的时候，我们只要继承这个抽象类就OK了。</p><hr><p>请看图1，在这个服务提供商的6步中，1-5步它是一个标准流程，也就是所说的<code>OAuth</code>协议流程，而第6步是一个个性化的流程，因为第6步每一个服务提供商它所提供的用户信息，它的数据结构都是不一样的，可能有的服务提供商提供3个字段，有的提供5个，有的人的头像字段叫做<code>headerImage</code>，有的叫做<code>image</code>，因为都不一样，所有第6步是个性化的，针对这2块，<code>ServiceProvider</code>里分别有2个封装</p><ol><li>OAuth2Operations：这个就是<code>OAuth2</code>的相关操作类，它封装了第一步到第5步<code>OAuth</code>协议的标准流程，<code>SpringSocial</code>提供给我们了一个默认的实现<code>OAuth2Template</code>，这个类会帮助我们完成<code>OAuth</code>协议的流程;</li><li>Api：<code>Api</code>没有一个明确的接口，因为每一个服务提供商它对用户基本信息的调用都是有区别的，所以在这一块要自己去写一个接口来封装获取用户信息，也就是第6步的行为，这里<code>SpringSocial</code>也提供了抽象类：<code>AbstractOAuth2ApiBinding</code>，来帮助我们更快的实现我们第6步所需要封装的<code>Api</code>实现。</li></ol><hr><p>现在看到的这3个接口以及相应的<code>抽象类/实现</code>实际上是封装了图1中跟服务提供商相关的东西，也就是第1步到第6步的行为，那么到第7步，跟服务提供商没有任何关系了，第7步整个都是在第三方应用内部完成的，也就是上面图中左边这一块</p><ol><li>Connection：这个接口不是数据库中的<code>Connection</code>，它的作用是封装我们前6步完成以后获得到的用户信息，在实际代码中用得实现类叫做<code>OAuth2Connection</code>；</li><li>ConnectionFactory：<code>Connection</code>它是由谁创建出来的？它是由<code>ConnectionFactory</code>连接工厂创建出来的，实际上要用到的类叫做<code>OAuth2ConnectionFactory</code>，这个工厂负责创建<code>Connection</code>实例，也就是包含了用户信息的对象，为了创建这个对象，它一定先走右边的流程，走右边流程就需要<code>ServiceProvider</code>，所以在<code>OAuth2ConnectionFactory</code>里面就包含一个<code>ServiceProvider</code>实例的，右边这套东西是被 封装起来放到<code>ConnectionFactory</code>里面的，那么在我们代码里会调用<code>ConnectionFactory</code>，用它里面的<code>ServiceProvider</code>去走图1的前6步流程，获取到用户信息，然后把这个用户信息封装成<code>Connection</code>；</li><li>ApiAdapter：这里有一个问题，这个<code>Connection</code>实际上是一个固定的数据结构，就是它的字段名都是固定的，前面说了，在走这个流程的时候第6步，获取到的用户信息实际上是每一个服务提供商它的定义都不一样的，如何把这些不一样的数据结构转换成<code>Connection</code>这样标准的数据结构，这个是由叫做<code>ApiAdapter</code>，这样一个接口的实现来完成的，<code>ApiAdapter</code>顾名思义就在图上的<code>Api</code>和<code>Connection</code>之前做一个适配；</li><li>UsersConnectionRepository：刚刚说<code>Connection</code>封装都是服务提供商里面的用户信息，在我们的业务系统里面，一般情况下会把业务系统的用户存在<code>user</code>的一张表里面，那么我们业务系统里面的用户信息如何和我的服务提供商用户信息关联在一起呢？换句话来说，服务提供商里面A用户，它要登录的时候，你怎么知道实际上是我业务系统里的张三登录了，这个对应关系是怎么建立的？实际上这个对应关系是存在数据库里的，数据库里有一个叫做<code>UsersConnection</code>表，这张表存储了你业务系统里的user表<code>user_id</code>，和一个服务提供商的用户<code>connection</code>之前的一个对应关系，那么由谁操作这个<code>UsersConnection</code>表呢？它是由<code>UsersConnectionRepository</code>来操作的，从这个名字看来，它是一个存储器，真正我们在代码里要到的实现类叫做<code>JdbcUsersConnectionRepository</code>，这个类的作用就是针对数据库里面<code>UsersConnection</code>这张表去做一些<code>CRUD</code>操作。</li></ol><hr><p>这里就介绍完了，需要注意： 这里的概念都是在开发中我们自己要写代码的时候涉及到的一些概念，就像之前说的登录成功的逻辑，我们会实现一个接口，叫<code>AuthenticationSuccessHandler</code>，与那个意思类似，现在将的是一些零散的接口，我们要自己去实现它，这样我们才能把QQ登录、微信登录的逻辑架在这个<code>SpringSocial</code>上，但是实际上<code>SpringSocial</code>已经把绝大部分第三方登录逻辑所需要实现的代码都实现了，我们在这只是介绍了跟我们自己要做的事情相关的一些东西，我们把这些东西实现以后，我们就能把整个流程跑起来，那么把整个流程跑起来以后，我们在进到<code>SpringSocial</code>代码里面跟着流程，在这个过程会看到<code>SpringSocial</code>提我们去实现，不用去管的那些代码它到底都做了什么，了解这是知识，我们就可以开始动手写一个第3方登录了，在动手之前来看一下<code>Spring</code>的<a href="https://projects.spring.io/spring-social/" target="_blank" rel="noopener">官方网站</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/spring-social.png" srcset="/img/loading.gif" alt=""></p><p>它这里提供了一些实现，如果你想连<code>FaceBook</code>，就引到自己的工程中就OK了，它把整个需要实现的东西都提供了，直接用就OK了</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 三、Social 】 1.OAuth协议简介</title>
    <link href="/spring-security-3.1.html"/>
    <url>/spring-security-3.1.html</url>
    
    <content type="html"><![CDATA[<hr><h1 id="OAuth协议解决的问题"><a href="#OAuth协议解决的问题" class="headerlink" title="OAuth协议解决的问题"></a>OAuth协议解决的问题</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567212996187.png" srcset="/img/loading.gif" alt="1567212996187"></p><p>如果要开发一个第三方应用进行微信图片的数据的读取，并将照片进行美化处理。那么这里就会出现微信不会将微信的账号和密码给第三方应用的问题。</p><p>即是给了用户名和密码也会存在微信账号安全问题以及微信应用的权限问题。因此OAuth协议就是为了解决这些问题的。</p><p>对于微信助手来说默认的情况下可以把为微信所有用户等变成潜在用户，比从0开始扩展客户效率和成本都要好的多。</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567213462066.png" srcset="/img/loading.gif" alt="1567213462066"></p><p>那么这里就有一个问题了：微信肯定不会允许我随便去读微信的用户信息的，那么这个时候就需要一个用户的授权用户同意我去读微信的自拍数据，有了这个授权以后就可以告诉微信说用户同意了，那么这个时候微信就会把用户的自拍数据开放给我，那么如何来得到用户授权呢？传统的做法我跟用户去要用户的微信的账号和密码，先不说用户会不会给，就算用户把账号和密码给我了，我拿着这个账号和密码 去微信读用户的自拍数据也是存在很多问题的：</p><ol><li>应用可以访问用户在微信上的所有数据；</li><li>用户只有修改密码才能收回授权；</li><li>密码泄露的可能性大大提高。</li></ol><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567213713727.png" srcset="/img/loading.gif" alt="1567213713727"></p><p><code>OAuth</code>协议就是来解决以上问题的，它的主要思路就是用户不用在把密码告诉我，而是交给一个令牌（<code>Token</code>），那么我再去访问微信上用户的自拍数据的时候，我就不用用户的用户名和密码了，而是改成用用户的令牌，那么这样之前几个问题就都不存在了，第1个问题：首先这个令牌写着你只能访问用户的自拍数据，所以你就不能访问用户在微信上其他的数据，第2个问题：这个令牌上会有一个有效期，比如说这个令牌只能用一个月，那么一个月以后就再也不能访问用户的自拍数据了，然后最后一个问题：“密码泄露的可能性大大提高”，这里 根本不需要密码就也解决了。</p><h1 id="OAuth协议运行流程"><a href="#OAuth协议运行流程" class="headerlink" title="OAuth协议运行流程"></a>OAuth协议运行流程</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567214223221.png" srcset="/img/loading.gif" alt="1567214223221"></p><p>相关角色：</p><ul><li><code>Provider</code>(服务提供商)：它负责提供令牌，在之前例子中，微信来提供这个令牌，所以微信是服务器提供商<code>Provider</code></li><li><code>Resource Owner</code>(资源所有者)：用户的自拍数据，所有者为用户自己</li><li><code>Client</code>(第三方应用)：慕课微信助手</li><li><code>Authorization Server</code>(认证服务器)：认证用户身份，产生令牌</li><li><code>Resource Server</code>(资源服务器)：存放数据的。并在这里验证请求中携带的<code>Token</code>信息</li></ul><h1 id="访问流程"><a href="#访问流程" class="headerlink" title="访问流程"></a>访问流程</h1><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567214618345.png" srcset="/img/loading.gif" alt="1567214618345"></p><ol><li>用户在使用第三方应用的时候，第三方应用请求用户进行微信的授权。</li><li>用户同意授权后，第三方应用请求微信的认证服务器，并验证用户是否同意了授权，第三方应用就会去访问服务提供商的认证服务器然后告诉它说用户同意我来访问用户的自拍数据了，你给我一个令牌</li><li>认证服务器会验证第3方应用说的是不是实话，用户是不是真的同意你来访问了，如果确实同意了那么认证服务器就会发放一个令牌给第3方应用</li><li>第三方应用拿到这个令牌以后，它就可以使用这个令牌去请求资源服务器去申请获取资源，资源服务器会验证申请资源请求携带的令牌，确认令牌无误那么就会同意用户的资源开放给第三方应用</li></ol><h1 id="授权码模式具体的实现步骤"><a href="#授权码模式具体的实现步骤" class="headerlink" title="授权码模式具体的实现步骤"></a>授权码模式具体的实现步骤</h1><p>这里根据不同场景，<code>OAuth</code>中定义了4种授权模式：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567214719109.png" srcset="/img/loading.gif" alt="1567214719109"></p><p>授权码模式是这这4种里面功能最完整，流程最严密的授权模式，你现在在互联网上能看到的所有提供商，不管是微博也好，微信也好，所有的服务提供商全都是采用授权码模式来完成整个OAuth流程的。</p><p>下面就来介绍一下授权码模式流程：</p><ol><li>用户访问我们的客户端应用，如果第三方应用它需要用户的授权，它会将用户导向 认证服务器，那么用户同意授权的动作会在认证服务器上来完成；</li><li>如果用户同意授权，那么认证服务器会将用户重新导回到第三方应用上去，导回去的时候，导回到第三方应用的哪个地址上这个是由第三方应用和认证服务器事先商量好的，那么它将用户导回事先商量好的<code>URL</code>上的同时，它会携带一个授权码，注意：这里不是返回我们要的令牌，不是<code>token</code>，而是授权码；</li><li>客户端在收到这个授权码以后，它会拿着这个授权码向认证服务器去申请令牌，这一步是在客户端后端的服务器去完成的，对用户是不可见的</li><li>认证服务器会对申请令牌这个请求中携带的授权码进行验证看是不是它之前发给客户端的，如果是：那么它会向客户端发送一个访问令牌（<code>Token</code>）</li></ol><p>这里的就是授权码模式的主要流程，为什么叫授权码模式，因为在这个过程中会产生一个授权码，在其他模式里是没有这个授权码的，所以叫授权码模式，这个模式有2个主要的特点：</p><ol><li>用户同意这个授权的动作是在认证服务器上完成的，其他授权模式里面，密码模式和客户端模式这个同意授权都是在第三方应用完成的，完成以后，第三方应用去向认证服务器中带着一堆信息说用户授权给我了，同意我来访问，这个时候认证服务器没法确定用户是不是真的授权了，有可能这个信息是第三方应用伪造的，这里在授权码模式里同意授权这个动作是在认证服务器上完成的，所以认证服务器可以明确的知道用户确实同意了授权；</li><li>在用户同意授权的时候，从认证服务器访问第三方的时候，它携带的并不是令牌，而是一个授权码，第三方应用在接到这个授权码以后要从第三方应用的服务器再发一个请求给认证服务器，拿着这个授权码去换令牌，在这个模式下面，必须有一个服务器，那么有些网站它可能就是一个静态网站它只有页面，它没有服务器，那么这种网站就会使用4种模式的第2种：简化模式，在简化模式里面从认证服务器返回第三方应用的时候，直接带的就是令牌，因为这种模式下，第三方应用它没有服务器，那么只能返回到页面上，然后在页面上用脚本去读取返回的令牌；</li></ol>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 二、Form 】  2.自定义用户认证逻辑</title>
    <link href="/spring-security-2.2.html"/>
    <url>/spring-security-2.2.html</url>
    
    <content type="html"><![CDATA[<p>之前通过user和控制台上的密码进行登录，在实际开发肯定不会这么做登录，这里笔者会带着读者来实现实际的登录功能</p><hr><h1 id="个性化登录页"><a href="#个性化登录页" class="headerlink" title="个性化登录页"></a>个性化登录页</h1><p>首先自己创建一个登录页面，<code>browser#resources/resources/mcr-login.html</code></p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/authentication/form"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>账号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>告诉<code>spring security</code>登录页面的位置，当用户没做登录时，就会跳转到这里</p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http                 .formLogin()+                .loginPage(<span class="hljs-string">"/mcr-login.html"</span>)...    &#125;</code></pre><p>之前看源码的时候，<code>UsernamePasswordAuthenticationFilter</code>，它只处理<code>/login</code>的<code>post请求</code>，所以还需要配置一下，告诉<code>UsernamePasswordAuthenticationFilter</code>去处理我们编写的其他路径：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     http             .formLogin()            .loginProcessingUrl(<span class="hljs-string">"/authentication/form"</span>)       ... &#125;</code></pre><p>启动，访问：<a href="http://localhost:8080/user.html" target="_blank" rel="noopener">http://localhost:8080/user.html</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566906164555.png" srcset="/img/loading.gif" alt="1566906164555"></p><p>这是怎么回事？——因为现在<code>spring security</code>跳转的到了<code>mcr-login.html</code>，而它也是受保护的，所以会继续跳转，而跳转的页面是<code>mcr-login.html</code>，这样就会出现多次跳转的情况</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566906354466.png" srcset="/img/loading.gif" alt="1566906354466"></p><p> <code>mcr-login.html</code>不需要保护</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;     http             .formLogin()       ...             .and()             .authorizeRequests()         ↓关键代码             .antMatchers(<span class="hljs-string">"/mcr-login.html"</span>)             .permitAll()             .anyRequest().authenticated(); &#125;</code></pre><p>现在自定义的页面是出来了，进行登录时：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566907097168.png" srcset="/img/loading.gif" alt="1566907097168"></p><p>这是因为在默认情况下，<code>spring security</code>提供了跨域请求的防护，这里需要关闭防护</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;       http        ...               .authorizeRequests()...           ↓关键代码               .and()               .csrf()               .disable();   &#125;</code></pre><h1 id="自定义认证逻辑"><a href="#自定义认证逻辑" class="headerlink" title="自定义认证逻辑"></a>自定义认证逻辑</h1><p>之前通过账号：user，密码：控制台上的，来认证通过，实际开发不会这样吧？这里就来带着笔者来实现自定义认证逻辑</p><hr><p>在这之前，先来介绍一下<code>UserDetailsService</code>，它是专门负责处理认证的，这里的<code>username</code>参数是用户在表单中输入的账号，我们可以通过账号去数据库中拿取用户的信息，返回给<code>spring security</code>，<code>spring security</code>就会拿着这个信息去和表单输入的账号密码去做处理</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.springframework.security.core.userdetails;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;<span class="hljs-function">UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException</span>;&#125;</code></pre><p>编写一个类实现<code>UserDetailsService</code>接口，假如所有账号的密码都是123</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.security.service;<span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;        log.info(<span class="hljs-string">"用户-&gt;&#123;&#125;进行了登录"</span>, username);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username, <span class="hljs-string">"123"</span>, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));    &#125;&#125;</code></pre><p>这里返回的UserDetails类型，我使用的是它自带的User类，在实际开发中，可以自己创建一个User类实现接口，这个接口包含方法：</p><ul><li>getAuthorities：权限信息</li><li>getPassword：密码</li><li>getUsername：账号</li><li>isAccountNonExpired：账户是否过期：true（否），false（是）</li><li>isAccountNonLocked：账户是否锁定</li><li>isCredentialsNonExpired：密码是否过期</li><li>isEnabled：账号是否可用</li></ul><p>从数据库中读取的密码不会是123，这里介绍一下加密器来模拟一下用户密码是加密的，这个一般是用到注册使用的</p><p><code>PasswordEncoder</code>就是加密器</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PasswordEncoder</span> </span>&#123;    <span class="hljs-comment">//加密</span>    <span class="hljs-function">String <span class="hljs-title">encode</span><span class="hljs-params">(CharSequence var1)</span></span>;    <span class="hljs-comment">//验证是否匹配</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(CharSequence var1, String var2)</span></span>;&#125;</code></pre><p>将加密器注入到IOC容器中</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();    &#125;</code></pre><p>McrUserDetailsService：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsService</span> </span>&#123;    <span class="hljs-meta">@Resource</span>+    <span class="hljs-keyword">private</span> PasswordEncoder passwordEncoder;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetails <span class="hljs-title">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException </span>&#123;+        String pwd = passwordEncoder.encode(<span class="hljs-string">"123"</span>);        log.info(<span class="hljs-string">"用户-&gt;&#123;&#125;进行了登录，它的密码是-&gt;&#123;&#125;"</span>, username, pwd);+        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username, pwd, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="hljs-string">"admin"</span>));    &#125;&#125;</code></pre><h1 id="处理不同请求"><a href="#处理不同请求" class="headerlink" title="处理不同请求"></a>处理不同请求</h1><p>这里实现以下图中的功能：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566914744512.png" srcset="/img/loading.gif" alt="1566914744512"></p><p>对响应提示信息进行封装</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.model.vo;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrSecurityVO</span> </span>&#123;    <span class="hljs-keyword">private</span> Object content;&#125;</code></pre><p>controller:</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/authentication"</span>)<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityController</span> </span>&#123;    <span class="hljs-keyword">private</span> RequestCache requestCache = <span class="hljs-keyword">new</span> HttpSessionRequestCache();    <span class="hljs-keyword">private</span> RedirectStrategy redirectStrategy = <span class="hljs-keyword">new</span> DefaultRedirectStrategy();    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/require"</span>)    <span class="hljs-meta">@ResponseStatus</span>(HttpStatus.UNAUTHORIZED)    <span class="hljs-function"><span class="hljs-keyword">public</span> McrSecurityVO <span class="hljs-title">requireAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        SavedRequest savedRequest = requestCache.getRequest(request, response);        <span class="hljs-keyword">if</span> (savedRequest != <span class="hljs-keyword">null</span>) &#123;            String targetUrl = savedRequest.getRedirectUrl();            log.info(<span class="hljs-string">"引发跳转的请求-&gt;&#123;&#125;"</span>, targetUrl);            <span class="hljs-keyword">if</span> (StringUtils.endsWithIgnoreCase(targetUrl, <span class="hljs-string">".html"</span>)) &#123;                redirectStrategy.sendRedirect(request, response, <span class="hljs-string">"/mcr-login.html"</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> McrSecurityVO(<span class="hljs-string">"请引导用户跳转到登录页面"</span>);    &#125;&#125;</code></pre><p>修改配置，跳转到<code>/authentication/require</code></p><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http                .formLogin()+               .loginPage(<span class="hljs-string">"/authentication/require"</span>)                .loginProcessingUrl(<span class="hljs-string">"/authentication/form"</span>)                .and()                .authorizeRequests()+               .antMatchers(<span class="hljs-string">"/mcr-login.html"</span>, <span class="hljs-string">"/authentication/require"</span>)                .permitAll()                .anyRequest().authenticated()                .and()                .csrf()                .disable();    &#125;</code></pre><h1 id="登录成功和登录失败的响应"><a href="#登录成功和登录失败的响应" class="headerlink" title="登录成功和登录失败的响应"></a>登录成功和登录失败的响应</h1><ul><li>处理成功响应：AuthenticationSuccessHandler</li><li>处理失败响应：AuthenticationFailureHandler</li></ul><p>这2个类都是接口类，使用它们需要实现这2个接口</p><p>成功处理：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.authentication;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationSuccessHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(authentication)));    &#125;&#125;</code></pre><p>失败处理：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.authentication;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationFailureHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);        response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(exception.getMessage())));    &#125;&#125;</code></pre><p>配置：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http                   .formLogin()+                   .successHandler(authenticationSuccessHandler)+                  .failureHandler(authenticationFailureHandler)                   .loginPage(<span class="hljs-string">"/authentication/require"</span>)                   .loginProcessingUrl(<span class="hljs-string">"/authentication/form"</span>)               ...    &#125;&#125;</code></pre><h1 id="认证流程源码详情"><a href="#认证流程源码详情" class="headerlink" title="认证流程源码详情"></a>认证流程源码详情</h1><p>流程图：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566918955707.png" srcset="/img/loading.gif" alt="1566918955707"></p><ul><li><p>UsernamePasswordAuthenticationFilter:表单用户名登陆过滤器</p></li><li><p>AuthenticationManager：管理所有的Provider，并选择适合的进行验证</p></li><li><p>AuthenticationProvider：验证提供者，可以自己写provider处理自己的业务场景逻辑</p></li><li><p>UserDetailsService：验证用户登陆信息</p></li><li><p>UserDetails:用户信息</p></li><li><p>Authentication:认证信息封装</p><hr></li></ul><p>UsernamePasswordAuthenticationFilter :</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566919161314.png" srcset="/img/loading.gif" alt="1566919161314"></p><p>通过用户填写的表单信息封装成UsernamePasswordAuthenticationToken  </p><p>UsernamePasswordAuthenticationToken  ：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566919277796.png" srcset="/img/loading.gif" alt="1566919277796"></p><p>这里它首先调用了自己的父类构造方法，传递了一个null</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566919334433.png" srcset="/img/loading.gif" alt="1566919334433"></p><p>这个实际上就是刚刚讲的UserDetails中的权限信息，由于现在还在做认证处理，没确定用户的账号和密码是否正确，所以这里还没有给定权限信息，接着它将账号和密码赋给自己的本地变量上，最后的：<code>setAuthenticated(false);</code>这个方法的意思是当前用户信息是否经过了身份认证，这里还在认证，所以传false</p><hr><p>回到<code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code>方法，继续往下看，它然后执行了这么一段代码，传递了request和前面的<code>UsernamePasswordAuthenticationToken</code>对象</p><pre><code class="hljs java">setDetails(request, authRequest);</code></pre><hr><p>这里的<code>setDetails</code>方法中调用了参数<code>authRequest</code>的<code>setDetails</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125;</code></pre><p>来看看<code>authenticationDetailsSource.buildDetails(request)</code>是的返回结构</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566919792395.png" srcset="/img/loading.gif" alt="1566919792395"></p><p>这里就是将ip地址和<code>sessionId</code>设置给<code>UsernamePasswordAuthenticationToken</code>对象</p><hr><p>回到<code>UsernamePasswordAuthenticationFilter</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566919884046.png" srcset="/img/loading.gif" alt="1566919884046"></p><p>这里将token交给了<code>AuthenticationManager</code></p><hr><p><code>ProviderManager#authenticate</code>,这里的<code>ProviderManager</code>，实现了<code>AuthenticationManager</code>接口，实际上用得是它</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566920015141.png" srcset="/img/loading.gif" alt="1566920015141"></p><p>这里它会拿取所有的<code>AuthenticationProvider</code>来进行遍历，调用每个<code>AuthenticationProvider</code>的<code>supports</code>方法并传递<code>token</code>，这里的<code>supports</code>方法会根据<code>token</code>，查看自己是否对这个<code>token</code>支持认证，如果支持就会调用自己的<code>authenticate</code>方法，将<code>token</code>传递进去</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566920224819.png" srcset="/img/loading.gif" alt="1566920224819"></p><p>来看下<code>AuthenticationProvider#authenticate</code>，它的<code>authenticate</code>方法属于它的父类的</p><p><code>AbstractUserDetailsAuthenticationProvider#authenticate</code></p><pre><code class="hljs java">UserDetails user = <span class="hljs-keyword">this</span>.userCache.getUserFromCache(username);<span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;cacheWasUsed = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">try</span> &#123;user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication);&#125;<span class="hljs-keyword">catch</span> (UsernameNotFoundException notFound) &#123;logger.debug(<span class="hljs-string">"User '"</span> + username + <span class="hljs-string">"' not found"</span>);<span class="hljs-keyword">if</span> (hideUserNotFoundExceptions) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,<span class="hljs-string">"Bad credentials"</span>));&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">throw</span> notFound;&#125;&#125;</code></pre><p>这里它首先会通过用户的账号从缓存中拿，如果拿不到就调用<code>retrieveUser</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> UserDetails <span class="hljs-title">retrieveUser</span><span class="hljs-params">(String username,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;UserDetails loadedUser;<span class="hljs-keyword">try</span> &#123;loadedUser = <span class="hljs-keyword">this</span>.getUserDetailsService().loadUserByUsername(username);&#125;&#125;</code></pre><p>在这里这一段            <code>loadedUser = this.getUserDetailsService().loadUserByUsername(username);</code>实际上调用的就是我之前编写的<code>McrUserDetailsService#loadUserByUsername</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566920666268.png" srcset="/img/loading.gif" alt="1566920666268"></p><p>回到<code>AbstractUserDetailsAuthenticationProvider#authenticate</code></p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;preAuthenticationChecks.check(user);additionalAuthenticationChecks(user,(UsernamePasswordAuthenticationToken) authentication);&#125;<span class="hljs-keyword">catch</span> (AuthenticationException exception) &#123;<span class="hljs-comment">//..</span>&#125;<span class="hljs-comment">//...</span><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user);</code></pre><p>preAuthenticationChecks.check：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultPreAuthenticationChecks</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsChecker</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(UserDetails user)</span> </span>&#123;<span class="hljs-keyword">if</span> (!user.isAccountNonLocked()) &#123;logger.debug(<span class="hljs-string">"User account is locked"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> LockedException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.locked"</span>,<span class="hljs-string">"User account is locked"</span>));&#125;<span class="hljs-keyword">if</span> (!user.isEnabled()) &#123;logger.debug(<span class="hljs-string">"User account is disabled"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DisabledException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.disabled"</span>,<span class="hljs-string">"User is disabled"</span>));&#125;<span class="hljs-keyword">if</span> (!user.isAccountNonExpired()) &#123;logger.debug(<span class="hljs-string">"User account is expired"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AccountExpiredException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.expired"</span>,<span class="hljs-string">"User account has expired"</span>));&#125;&#125;&#125;</code></pre><p>检查用户是否锁定、用户账号是否启动、用户账号是否过期，如果出现一个就会抛出对应的异常</p><hr><p>additionalAuthenticationChecks：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">additionalAuthenticationChecks</span><span class="hljs-params">(UserDetails userDetails,</span></span><span class="hljs-function"><span class="hljs-params">UsernamePasswordAuthenticationToken authentication)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;Object salt = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.saltSource != <span class="hljs-keyword">null</span>) &#123;salt = <span class="hljs-keyword">this</span>.saltSource.getSalt(userDetails);&#125;<span class="hljs-keyword">if</span> (authentication.getCredentials() == <span class="hljs-keyword">null</span>) &#123;logger.debug(<span class="hljs-string">"Authentication failed: no credentials provided"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,<span class="hljs-string">"Bad credentials"</span>));&#125;String presentedPassword = authentication.getCredentials().toString();<span class="hljs-keyword">if</span> (!passwordEncoder.isPasswordValid(userDetails.getPassword(),presentedPassword, salt)) &#123;logger.debug(<span class="hljs-string">"Authentication failed: password does not match stored value"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BadCredentialsException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.badCredentials"</span>,<span class="hljs-string">"Bad credentials"</span>));&#125;&#125;</code></pre><p>这里通过passwordEncoder加密解密器去校验当前密码是否匹配，不匹配的话就抛出异常</p><hr><p>postAuthenticationChecks.check：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultPostAuthenticationChecks</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDetailsChecker</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(UserDetails user)</span> </span>&#123;<span class="hljs-keyword">if</span> (!user.isCredentialsNonExpired()) &#123;logger.debug(<span class="hljs-string">"User account credentials have expired"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CredentialsExpiredException(messages.getMessage(<span class="hljs-string">"AbstractUserDetailsAuthenticationProvider.credentialsExpired"</span>,<span class="hljs-string">"User credentials have expired"</span>));&#125;&#125;&#125;</code></pre><hr><p>在里所有检查都通过，就认为用户 认证是成功的，用户认证成功的时候会返回：</p><pre><code class="hljs java"><span class="hljs-keyword">return</span> createSuccessAuthentication(principalToReturn, authentication, user)</code></pre><p>createSuccessAuthentication:</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Authentication <span class="hljs-title">createSuccessAuthentication</span><span class="hljs-params">(Object principal,</span></span><span class="hljs-function"><span class="hljs-params">Authentication authentication, UserDetails user)</span> </span>&#123;UsernamePasswordAuthenticationToken result = <span class="hljs-keyword">new</span> UsernamePasswordAuthenticationToken(principal, authentication.getCredentials(),authoritiesMapper.mapAuthorities(user.getAuthorities()));result.setDetails(authentication.getDetails());<span class="hljs-keyword">return</span> result;&#125;</code></pre><p>这里就会拿之前的token，重新实例化一个token，并把权限信息设置上去，它在这次调用的另外一个构造方法,调用setAuthenticated传递true，表示这个账号信息已经认证通过了</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UsernamePasswordAuthenticationToken</span><span class="hljs-params">(Object principal, Object credentials,</span></span><span class="hljs-function"><span class="hljs-params">Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<span class="hljs-keyword">super</span>(authorities);<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">this</span>.credentials = credentials;<span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// must use super, as we override</span>&#125;</code></pre><p>到这里，<code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code>就走完了，实际上调用<code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code>的是<code>AbstractAuthenticationProcessingFilter#doFilter</code>，这里它做了一系列的判断，如果都没问题，则会调用<code>successfulAuthentication</code>方法，如果有问题，<code>UsernamePasswordAuthenticationFilter#attemptAuthentication</code>方法会抛出一个异常，这这里面就行了捕获就会调用<code>unsuccessfulAuthentication</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;HttpServletRequest request = (HttpServletRequest) req;HttpServletResponse response = (HttpServletResponse) res;<span class="hljs-keyword">if</span> (!requiresAuthentication(request, response)) &#123;chain.doFilter(request, response);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Request is to process authentication"</span>);&#125;Authentication authResult;<span class="hljs-keyword">try</span> &#123;authResult = attemptAuthentication(request, response);<span class="hljs-keyword">if</span> (authResult == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// return immediately as subclass has indicated that it hasn't completed</span><span class="hljs-comment">// authentication</span><span class="hljs-keyword">return</span>;&#125;sessionStrategy.onAuthentication(authResult, request, response);&#125;<span class="hljs-keyword">catch</span> (InternalAuthenticationServiceException failed) &#123;logger.error(<span class="hljs-string">"An internal error occurred while trying to authenticate the user."</span>,failed);unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">catch</span> (AuthenticationException failed) &#123;<span class="hljs-comment">// Authentication failed</span>unsuccessfulAuthentication(request, response, failed);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// Authentication success</span><span class="hljs-keyword">if</span> (continueChainBeforeSuccessfulAuthentication) &#123;chain.doFilter(request, response);&#125;successfulAuthentication(request, response, chain, authResult);&#125;</code></pre><p>successfulAuthentication：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">successfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Authentication success. Updating SecurityContextHolder to contain: "</span>+ authResult);&#125;SecurityContextHolder.getContext().setAuthentication(authResult);rememberMeServices.loginSuccess(request, response, authResult);<span class="hljs-comment">// Fire event</span><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.eventPublisher != <span class="hljs-keyword">null</span>) &#123;eventPublisher.publishEvent(<span class="hljs-keyword">new</span> InteractiveAuthenticationSuccessEvent(authResult, <span class="hljs-keyword">this</span>.getClass()));&#125;successHandler.onAuthenticationSuccess(request, response, authResult);&#125;</code></pre><ul><li><code>successHandler.onAuthenticationSuccess(request, response, authResult);</code>:调用之前编写的登录成功处理器McrAuthenticationSuccessHandler#onAuthenticationSuccess；</li><li><code>SecurityContextHolder.getContext().setAuthentication(authResult);</code>：将用户信息存储在sesison中</li></ul><p>SecurityContextHolder.getContext().setAuthentication(authResult)：</p><p>这里的SecurityContextHolder.getContext()返回一个SecurityContext类，SecurityContext类的实现类是SecurityContextImpl，调用的是它的setAuthentication方法</p><blockquote><p>这里的SecurityContextHolder看了半天没办法表达，以后再补上</p></blockquote><hr><p>unsuccessfulAuthentication：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response, AuthenticationException failed)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;SecurityContextHolder.clearContext();<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;logger.debug(<span class="hljs-string">"Authentication request failed: "</span> + failed.toString(), failed);logger.debug(<span class="hljs-string">"Updated SecurityContextHolder to contain null Authentication"</span>);logger.debug(<span class="hljs-string">"Delegating to authentication failure handler "</span> + failureHandler);&#125;rememberMeServices.loginFail(request, response);failureHandler.onAuthenticationFailure(request, response, failed);&#125;</code></pre><p>这里就是调用之前编写的失败处理器McrAuthenticationFailureHandler</p><h1 id="获取当前用户信息"><a href="#获取当前用户信息" class="headerlink" title="获取当前用户信息"></a>获取当前用户信息</h1><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentUser</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> SecurityContextHolder.getContext().getAuthentication();   &#125;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me/2"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(Authentication authentication)</span> </span>&#123;       <span class="hljs-keyword">return</span> authentication;   &#125;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/me/v3"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCurrentUser</span><span class="hljs-params">(@AuthenticationPrincipal UserDetails authentication)</span> </span>&#123;       <span class="hljs-keyword">return</span> authentication;   &#125;</code></pre><hr><h1 id="图形验证码登录"><a href="#图形验证码登录" class="headerlink" title="图形验证码登录"></a>图形验证码登录</h1><h2 id="生成图形验证码"><a href="#生成图形验证码" class="headerlink" title="生成图形验证码"></a>生成图形验证码</h2><p>将图片验证码需要的信息封装成一个类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.model.dto;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCodeDTO</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 图片</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> BufferedImage image;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 随机数</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> String code;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 过期时间</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> LocalDateTime expireTime;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCodeDTO</span><span class="hljs-params">(BufferedImage image, String code, <span class="hljs-keyword">int</span> expireIn)</span></span>&#123;<span class="hljs-keyword">this</span>.image = image;<span class="hljs-keyword">this</span>.code = code;<span class="hljs-comment">//多少秒后</span><span class="hljs-keyword">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireIn);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCodeDTO</span><span class="hljs-params">(BufferedImage image, String code, LocalDateTime expireTime)</span></span>&#123;<span class="hljs-keyword">this</span>.image = image;<span class="hljs-keyword">this</span>.code = code;<span class="hljs-keyword">this</span>.expireTime = expireTime;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExpired</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> LocalDateTime.now().isAfter(expireTime);&#125;&#125;</code></pre><p>获取图形验证码的请求</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/code"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeController</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SESSION_KEY = <span class="hljs-string">"SESSION_KEY_CODE"</span>;    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/image"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">imageCreateCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//1：根据随机数生成图片</span>        ImageCodeDTO imageCodeDTO = generate(<span class="hljs-keyword">new</span> ServletWebRequest(request));        <span class="hljs-comment">//2：将图片放入session中</span>        sessionStrategy.setAttribute(<span class="hljs-keyword">new</span> ServletWebRequest(request), SESSION_KEY + <span class="hljs-string">"/image"</span>, imageCodeDTO);        <span class="hljs-comment">//3：将生成的图片写入接口的响应中</span>        ImageIO.write(imageCodeDTO.getImage(), <span class="hljs-string">"JPEG"</span>, response.getOutputStream());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> ImageCodeDTO <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        <span class="hljs-keyword">int</span> width = <span class="hljs-number">67</span>;        <span class="hljs-keyword">int</span> height = <span class="hljs-number">23</span>;        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics g = image.getGraphics();        Random random = <span class="hljs-keyword">new</span> Random();        g.setColor(getRandColor(<span class="hljs-number">200</span>, <span class="hljs-number">250</span>));        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.ITALIC, <span class="hljs-number">20</span>));        g.setColor(getRandColor(<span class="hljs-number">160</span>, <span class="hljs-number">200</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">155</span>; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            g.drawLine(x, y, x + xl, y + yl);        &#125;        String sRand = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;            String rand = String.valueOf(random.nextInt(<span class="hljs-number">10</span>));            sRand += rand;            g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>), <span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>), <span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>)));            g.drawString(rand, <span class="hljs-number">13</span> * i + <span class="hljs-number">6</span>, <span class="hljs-number">16</span>);        &#125;        g.dispose();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImageCodeDTO(image, sRand, <span class="hljs-number">60</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成随机背景条纹</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fc</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bc</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Color <span class="hljs-title">getRandColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fc, <span class="hljs-keyword">int</span> bc)</span> </span>&#123;        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-keyword">if</span> (fc &gt; <span class="hljs-number">255</span>) &#123;            fc = <span class="hljs-number">255</span>;        &#125;        <span class="hljs-keyword">if</span> (bc &gt; <span class="hljs-number">255</span>) &#123;            bc = <span class="hljs-number">255</span>;        &#125;        <span class="hljs-keyword">int</span> r = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">int</span> g = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">int</span> b = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color(r, g, b);    &#125;&#125;</code></pre><p>让这个请求不需要校验</p><pre><code class="hljs java">.antMatchers(....                      <span class="hljs-string">"/code/**"</span></code></pre><p>在登录页面中加入：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>图形验证码:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"imageCode"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/code/image"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span></code></pre><h2 id="图形验证码验证"><a href="#图形验证码验证" class="headerlink" title="图形验证码验证"></a>图形验证码验证</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566723514793.png" srcset="/img/loading.gif" alt=""></p><p>图形验证码是比用户的账号密码先效验的，所以我会在<code>UsernamePasswordAuthenticationFilter</code>前面加一个验证用户填的验证码是否正确的过滤器，如果验证不通过就抛出异常，这里的异常我希望可以让<code>spring security</code>捕获，可以自定义一个类继承<code>AuthenticationException</code> ，或者直接抛出<code>AuthenticationException</code> 的异常，这里我就自定义一个</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthenticationException</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">7285211528095468156L</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ValidateCodeException</span><span class="hljs-params">(String msg)</span> </span>&#123;        <span class="hljs-keyword">super</span>(msg);    &#125;&#125;</code></pre><hr><p>过滤器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageValidateCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.equals(<span class="hljs-string">"/authentication/form"</span>, request.getRequestURI())                &amp;&amp; StringUtils.equalsIgnoreCase(request.getMethod(), <span class="hljs-string">"post"</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                validate(<span class="hljs-keyword">new</span> ServletWebRequest(request));            &#125; <span class="hljs-keyword">catch</span> (ValidateCodeException e) &#123;                authenticationFailureHandler.onAuthenticationFailure(request, response, e);                <span class="hljs-comment">//出现异常不继续执行</span>                <span class="hljs-keyword">return</span>;            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> ServletRequestBindingException </span>&#123;        ImageCodeDTO codeInSession = (ImageCodeDTO) sessionStrategy.getAttribute(request,                ValidateCodeController.SESSION_KEY + <span class="hljs-string">"/image"</span>);        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), <span class="hljs-string">"imageCode"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码的值不能为空"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不存在"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession.isExpired()) &#123;            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码已过期"</span>);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不匹配"</span>);        &#125;        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);    &#125;&#125;</code></pre><hr><p>将图形验证码过滤添加到<code>UsernamePasswordAuthenticationFilter</code>的前面：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    ImageValidateCodeFilter imageValidateCodeFilter = <span class="hljs-keyword">new</span> ImageValidateCodeFilter();    imageValidateCodeFilter.setAuthenticationFailureHandler(authenticationFailureHandler);    http            .addFilterBefore(imageValidateCodeFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"> //...</span><span class="hljs-class"></span><span class="hljs-class">&#125;</span></code></pre><h1 id="手机登录"><a href="#手机登录" class="headerlink" title="手机登录"></a>手机登录</h1><h2 id="生成短信验证码"><a href="#生成短信验证码" class="headerlink" title="生成短信验证码"></a>生成短信验证码</h2><p>和上面的图形验证码差不多，不多废话直接上代码</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.model.dto;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeDTO</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String code;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 失效时间 </span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LocalDateTime expireTime;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeDTO</span><span class="hljs-params">(String code, <span class="hljs-keyword">int</span> expireAfterSeconds)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-comment">//多少秒后</span>        <span class="hljs-keyword">this</span>.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeDTO</span><span class="hljs-params">(String code, LocalDateTime expireTime)</span> </span>&#123;        <span class="hljs-keyword">this</span>.code = code;        <span class="hljs-keyword">this</span>.expireTime = expireTime;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否失效</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExpired</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> LocalDateTime.now().isAfter(expireTime);    &#125;&#125;</code></pre><hr><p>ValidateCodeController</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/sms"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createSmsCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;      String code = String.valueOf(RandomUtils.nextInt(<span class="hljs-number">9999</span>));      SmsCodeDTO smsCodeDTO = <span class="hljs-keyword">new</span> SmsCodeDTO(code, <span class="hljs-number">60</span>);      sessionStrategy.setAttribute(<span class="hljs-keyword">new</span> ServletWebRequest(request, response), SESSION_KEY + <span class="hljs-string">"/sms"</span>, smsCodeDTO);      <span class="hljs-keyword">return</span> code;  &#125;</code></pre><hr><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>短信登录<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/authentication/mobile"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>手机号:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"mobile"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"13012345678"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>短信验证码:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"smsCode"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/code/sms?mobile=13012345678"</span>&gt;</span>发送验证码<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><h2 id="手机登录验证"><a href="#手机登录验证" class="headerlink" title="手机登录验证"></a>手机登录验证</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567003728157.png" srcset="/img/loading.gif" alt="1567003728157"></p><p>手机登录，1是手机号码，2是手机收到的验证码，这里的验证与前面的图形验证码验证是不同的，它不能通过<code>UsernamePasswordAuthenticationFilter</code>去做验证，在这里就需要自己自定义一个<code>AtuehtncationFilter</code>，然后还需要一个做验证的<code>Provider</code>也是需要自己来做的，读者不用担心很复杂，笔者这里是通过复制这些源码，来进行修改完成的，实际上不会太难</p><hr><p>SmsCodeAuthenticationToken：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authentication.mobile;<span class="hljs-keyword">import</span> org.springframework.security.authentication.AbstractAuthenticationToken;<span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<span class="hljs-keyword">import</span> org.springframework.security.core.SpringSecurityCoreVersion;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationToken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationToken</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID; <span class="hljs-comment">// ~ Instance fields</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object principal;<span class="hljs-comment">//存放认证信息。</span> <span class="hljs-comment">// ~ Constructors</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 认证之前存放手机号</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeAuthenticationToken</span><span class="hljs-params">(Object mobile)</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">this</span>.principal = mobile;setAuthenticated(<span class="hljs-keyword">false</span>);&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 认证成功存放用户</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeAuthenticationToken</span><span class="hljs-params">(Object principal, Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;<span class="hljs-keyword">super</span>(authorities);<span class="hljs-keyword">this</span>.principal = principal;<span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// must use super, as we override</span>&#125; <span class="hljs-comment">// ~ Methods</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.principal;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;<span class="hljs-keyword">if</span> (isAuthenticated) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead"</span>);&#125; <span class="hljs-keyword">super</span>.setAuthenticated(<span class="hljs-keyword">false</span>);&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eraseCredentials</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>.eraseCredentials();&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</code></pre><p>SmsCodeAuthenticationFilter：</p><blockquote><p>实际上与UsernamePasswordAuthenticationFilter做的事情是差不多的，只不过它这里拿的是用户填写的手机号码封装成SmsCodeAuthenticationToken</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authentication.mobile;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAuthenticationProcessingFilter</span> </span>&#123;<span class="hljs-comment">//请求中携带的参数名</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String IMOOC_FORM_MOBILE_KEY = <span class="hljs-string">"mobile"</span>;<span class="hljs-keyword">private</span> String mobileParameter = IMOOC_FORM_MOBILE_KEY;<span class="hljs-comment">// 请求中携带参数的名字是什么</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> postOnly = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//是否仅处理post请求</span><span class="hljs-comment">// ~ Constructors</span><span class="hljs-comment">//处理的短信登录的请求是什么</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(<span class="hljs-string">"/authentication/mobile"</span>, <span class="hljs-string">"POST"</span>));&#125;<span class="hljs-comment">// ~ Methods</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">attemptAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;<span class="hljs-keyword">if</span> (postOnly &amp;&amp; !request.getMethod().equals(<span class="hljs-string">"POST"</span>)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AuthenticationServiceException(<span class="hljs-string">"Authentication method not supported: "</span> + request.getMethod());&#125;String mobile = obtainMobile(request);<span class="hljs-keyword">if</span> (mobile == <span class="hljs-keyword">null</span>) &#123;mobile = <span class="hljs-string">""</span>;&#125;mobile = mobile.trim();SmsCodeAuthenticationToken authRequest = <span class="hljs-keyword">new</span> SmsCodeAuthenticationToken(mobile);<span class="hljs-comment">// 将请求的信息设置在Token中</span>setDetails(request, authRequest);<span class="hljs-comment">//拿着Token调用AuthenticationManager</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAuthenticationManager().authenticate(authRequest);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取请求参数中的手机号</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">obtainMobile</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<span class="hljs-keyword">return</span> request.getParameter(mobileParameter);&#125; <span class="hljs-comment">/**</span><span class="hljs-comment"> * 将请求的信息设置在Token中</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> authRequest</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDetails</span><span class="hljs-params">(HttpServletRequest request, SmsCodeAuthenticationToken authRequest)</span> </span>&#123;authRequest.setDetails(authenticationDetailsSource.buildDetails(request));&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMobileParameter</span><span class="hljs-params">(String mobileParameter)</span> </span>&#123;Assert.hasText(mobileParameter, <span class="hljs-string">"Mobile parameter must not be empty or null"</span>);<span class="hljs-keyword">this</span>.mobileParameter = mobileParameter;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPostOnly</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> postOnly)</span> </span>&#123;<span class="hljs-keyword">this</span>.postOnly = postOnly;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">getMobileParameter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> mobileParameter;&#125;&#125;</code></pre><p>SmsCodeAuthenticationProvider：</p><blockquote><p>用于验证SmsCodeAuthenticationToken</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authentication.mobile;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthenticationProvider</span> </span>&#123;<span class="hljs-meta">@Setter</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">private</span> UserDetailsService userDetailsService;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 身份认证的逻辑</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Authentication <span class="hljs-title">authenticate</span><span class="hljs-params">(Authentication authentication)</span> <span class="hljs-keyword">throws</span> AuthenticationException </span>&#123;SmsCodeAuthenticationToken smsCodeAuthenticationToken = (SmsCodeAuthenticationToken)authentication;UserDetails user = userDetailsService.loadUserByUsername((String) smsCodeAuthenticationToken.getPrincipal());<span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalAuthenticationServiceException(<span class="hljs-string">"无法获取用户信息"</span>);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 1:用户认证信息</span><span class="hljs-comment"> * 2：用户权限</span><span class="hljs-comment"> */</span>SmsCodeAuthenticationToken authenticationResult = <span class="hljs-keyword">new</span> SmsCodeAuthenticationToken(user, user.getAuthorities());<span class="hljs-comment">//将之前未认证的请求放进认证后的Token中</span>authenticationResult.setDetails(smsCodeAuthenticationToken);<span class="hljs-keyword">return</span> authenticationResult;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * AuthenticationManager带着Token调用Provider</span><span class="hljs-comment"> * 判断传进来的Token最终调用的是哪个Provider</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span><span class="hljs-params">(Class&lt;?&gt; authentication)</span> </span>&#123;<span class="hljs-keyword">return</span> SmsCodeAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">isAssignableFrom</span>(<span class="hljs-title">authentication</span>)</span>;&#125;&#125;</code></pre><p>ImageValidateCodeFilter：</p><blockquote><p>这里的SmsValidateCodeFilter 和ImageValidateCodeFilter逻辑一样</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.sms;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.SmsCodeDTO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeController;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.validate.code.ValidateCodeException;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.HttpSessionSessionStrategy;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.SessionStrategy;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestBindingException;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestUtils;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-keyword">import</span> org.springframework.web.filter.OncePerRequestFilter;<span class="hljs-keyword">import</span> javax.servlet.FilterChain;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsValidateCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">if</span> (request.getRequestURI().equals(<span class="hljs-string">"/authentication/mobile"</span>)                &amp;&amp; StringUtils.equalsIgnoreCase(request.getMethod(), <span class="hljs-string">"post"</span>)) &#123;            <span class="hljs-keyword">try</span> &#123;                validate(<span class="hljs-keyword">new</span> ServletWebRequest(request));            &#125; <span class="hljs-keyword">catch</span> (ValidateCodeException e) &#123;                authenticationFailureHandler.onAuthenticationFailure(request, response, e);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> ServletRequestBindingException </span>&#123;        String key = ValidateCodeController.SESSION_KEY + <span class="hljs-string">"/sms"</span>;        SmsCodeDTO smsCodeDTO = (SmsCodeDTO) sessionStrategy.getAttribute(request,                key);        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), <span class="hljs-string">"smsCode"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码的值不能为空"</span>);        &#125;        <span class="hljs-keyword">if</span> (smsCodeDTO == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不存在"</span>);        &#125;        <span class="hljs-keyword">if</span> (smsCodeDTO.isExpired()) &#123;            sessionStrategy.removeAttribute(request, key);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码已过期"</span>);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.equals(smsCodeDTO.getCode(), codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不匹配"</span>);        &#125;        sessionStrategy.removeAttribute(request, key);    &#125;&#125;</code></pre><p>现在可以将这些类配置到browser模块里，但是有一个问题，以后还有对app模块进行code时，希望app模块中也提供手机登录的功能，那又得在app模块中进行配置，这里可以将这个配置抽象起来，通过继承<code>SecurityConfigurerAdapter</code>类，然后将配置写在里面，browser和app模块只需要引入这个配置就可以了</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.authentication.mobile;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.security.authentication.AuthenticationManager;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.SecurityConfigurerAdapter;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<span class="hljs-keyword">import</span> org.springframework.security.web.DefaultSecurityFilterChain;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.AuthenticationFailureHandler;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.AuthenticationSuccessHandler;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeAuthenticationSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SecurityConfigurerAdapter</span>&lt;<span class="hljs-title">DefaultSecurityFilterChain</span>, <span class="hljs-title">HttpSecurity</span>&gt; </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> UserDetailsService userDetailsService;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;SmsCodeAuthenticationFilter smsCodeAuthenticationFilter = <span class="hljs-keyword">new</span> SmsCodeAuthenticationFilter();smsCodeAuthenticationFilter.setAuthenticationManager(http.getSharedObject(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;smsCodeAuthenticationFilter.setAuthenticationSuccessHandler(authenticationSuccessHandler);smsCodeAuthenticationFilter.setAuthenticationFailureHandler(authenticationFailureHandler);SmsCodeAuthenticationProvider smsCodeAuthenticationProvider = <span class="hljs-keyword">new</span> SmsCodeAuthenticationProvider();smsCodeAuthenticationProvider.setUserDetailsService(userDetailsService);http.authenticationProvider(smsCodeAuthenticationProvider).addFilterAfter(smsCodeAuthenticationFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;&#125;</code></pre><p>在SmsCodeAuthenticationSecurityConfig中将<code>SmsValidateCodeFilter</code>进行配置，并引入SmsCodeAuthenticationSecurityConfig配置</p><p>SmsCodeAuthenticationSecurityConfig#configure</p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        SmsValidateCodeFilter smsValidateCodeFilter = <span class="hljs-keyword">new</span> SmsValidateCodeFilter();        smsValidateCodeFilter.setAuthenticationFailureHandler(authenticationFailureHandler);        http.apply(smsCodeAuthenticationSecurityConfig)                .and()                .addFilterBefore(smsValidateCodeFilter, UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre><h1 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h1><p>这里的重构代码，主要是将一些固定的值使yml、properties可配置，比如说之前做的自定义登录页面，在别人拿到我们的代码加入他的工程时，他编写的登录页面路径和名称必须是固定的，他在开发时可能并没有使用前后端分离，登录失败时，只想跳回登录页面，不希望是返回一段josn…，我们就来实现这些功能</p><h2 id="登录页面路径"><a href="#登录页面路径" class="headerlink" title="登录页面路径"></a>登录页面路径</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityProperties</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录页路径</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String loginUrl = <span class="hljs-string">"/mcr-login.html"</span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"mcr.b4.security"</span>)<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> BrowserSecurityProperties browser = <span class="hljs-keyword">new</span> BrowserSecurityProperties();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core; <span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties</span>(SecurityProperties<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">SecurityCoreConfig</span> </span>&#123;&#125;</code></pre><p>com.b4.mcr.auth.browser.BrowserSecurityController#requireAuthentication：</p><pre><code class="hljs java">    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> SecurityProperties security; <span class="hljs-function"><span class="hljs-keyword">public</span> McrSecurityVO <span class="hljs-title">requireAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">//..</span> redirectStrategy.sendRedirect(request, response, security.getBrowser().getLoginUrl());&#125;</code></pre><p>BrowserSecurityConfig：</p><blockquote><p>这里把所有的@Resource注解去掉，在类上方加入@AllArgsConstructor</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationSuccessHandler authenticationSuccessHandler;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> SmsCodeAuthenticationSecurityConfig smsCodeAuthenticationSecurityConfig;    <span class="hljs-keyword">private</span> SecurityProperties security;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BrowserSecurityProperties browser = security.getBrowser();<span class="hljs-comment">//....</span>                .antMatchers(browser.getLoginUrl(), <span class="hljs-string">"/authentication/require"</span>, <span class="hljs-string">"/code/**"</span>)                  &#125;&#125;</code></pre><h2 id="成功失败处理器"><a href="#成功失败处理器" class="headerlink" title="成功失败处理器"></a>成功失败处理器</h2><p>成功失败处理器对于一些开发来说是没必要返回josn的，他可能希望得是跳转页面</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> LoginType &#123;    JSON, REDIRECT&#125;</code></pre><p>BrowserSecurityProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> LoginType loginType = LoginType.JSON;</code></pre><p>成功处理器和失败处理器都从icon容器中拿取SecurityProperties类，判断BrowserSecurityProperties中的LoginType是json的话就返回json，否则跳转页面，这里跳转页面可以不用自己写，spring security中的默认使用的就是跳转，可以将之前的失败、成功接口换成继承spring security中提供的</p><p>成功处理器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.authentication;<span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationSuccessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavedRequestAwareAuthenticationSuccessHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-keyword">private</span> SecurityProperties security;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationSuccess</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span> (security.getBrowser().getLoginType().equals(LoginType.JSON)) &#123;            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(authentication)));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.onAuthenticationSuccess(request, response, authentication);        &#125;    &#125;&#125;</code></pre><p>失败处理器：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser.authentication;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.vo.McrSecurityVO;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.LoginType;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.SecurityProperties;<span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.security.core.AuthenticationException;<span class="hljs-keyword">import</span> org.springframework.security.web.authentication.ExceptionMappingAuthenticationFailureHandler;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-meta">@Component</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthenticationFailureHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ExceptionMappingAuthenticationFailureHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> ObjectMapper objectMapper;    <span class="hljs-keyword">private</span> SecurityProperties security;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthenticationFailure</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;        <span class="hljs-keyword">if</span> (security.getBrowser().getLoginType().equals(LoginType.JSON)) &#123;            response.setContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>);            response.getWriter().write(objectMapper.writeValueAsString(<span class="hljs-keyword">new</span> McrSecurityVO(exception.getMessage())));        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">super</span>.onAuthenticationFailure(request, response, exception);        &#125;    &#125;&#125;</code></pre><h2 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h2><hr><p>图片验证码生成的宽、高，验证码长度、过期时间</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCodeProperties</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">67</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">23</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> length = <span class="hljs-number">4</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expireIn = <span class="hljs-number">60</span>;&#125;</code></pre><p>因为以后app模块也会实现图片验证码功能，所以这里不应该放到BrowserSecurityProperties类中，这里创建一个ValidateCodeProperties放到SecurityProperties中</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeProperties</span> </span>&#123;<span class="hljs-keyword">private</span> ImageCodeProperties image = <span class="hljs-keyword">new</span> ImageCodeProperties();&#125;</code></pre><p>SecurityProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> ValidateCodeProperties code = <span class="hljs-keyword">new</span> ValidateCodeProperties();</code></pre><p>之前把生成图片验证码的逻辑放到了ValidateCodeController类中，这样做会不好扩展，如果说使用者不想用我提供的图片验证码生成，而是用其他的那就没法实现了，这里我使用里氏替换原则实现，首先这里做一个接口，提供一个生成图片类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.model.dto.ImageCodeDTO;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidateCodeGenerator</span> </span>&#123;<span class="hljs-function">ImageCodeDTO <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span></span>;&#125;</code></pre><p>默认实现类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.demo.core.validate.code.image;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageValidateCodeGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeGenerator</span> </span>&#123;    <span class="hljs-meta">@Setter</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ImageCodeDTO <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        <span class="hljs-keyword">int</span> width = ServletRequestUtils.getIntParameter(request.getRequest(), <span class="hljs-string">"width"</span>,                securityProperties.getCode().getImage().getWidth());        <span class="hljs-keyword">int</span> height = ServletRequestUtils.getIntParameter(request.getRequest(), <span class="hljs-string">"height"</span>,                securityProperties.getCode().getImage().getHeight());        BufferedImage image = <span class="hljs-keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);        Graphics g = image.getGraphics();        Random random = <span class="hljs-keyword">new</span> Random();        g.setColor(getRandColor(<span class="hljs-number">200</span>, <span class="hljs-number">250</span>));        g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);        g.setFont(<span class="hljs-keyword">new</span> Font(<span class="hljs-string">"Times New Roman"</span>, Font.ITALIC, <span class="hljs-number">20</span>));        g.setColor(getRandColor(<span class="hljs-number">160</span>, <span class="hljs-number">200</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">155</span>; i++) &#123;            <span class="hljs-keyword">int</span> x = random.nextInt(width);            <span class="hljs-keyword">int</span> y = random.nextInt(height);            <span class="hljs-keyword">int</span> xl = random.nextInt(<span class="hljs-number">12</span>);            <span class="hljs-keyword">int</span> yl = random.nextInt(<span class="hljs-number">12</span>);            g.drawLine(x, y, x + xl, y + yl);        &#125;        String sRand = <span class="hljs-string">""</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; securityProperties.getCode().getImage().getLength(); i++) &#123;            String rand = String.valueOf(random.nextInt(<span class="hljs-number">10</span>));            sRand += rand;            g.setColor(<span class="hljs-keyword">new</span> Color(<span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>), <span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>), <span class="hljs-number">20</span> + random.nextInt(<span class="hljs-number">110</span>)));            g.drawString(rand, <span class="hljs-number">13</span> * i + <span class="hljs-number">6</span>, <span class="hljs-number">16</span>);        &#125;        g.dispose();                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImageCodeDTO(image,sRand, securityProperties.getCode().getImage().getExpireIn());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成随机背景条纹</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fc</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bc</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> Color <span class="hljs-title">getRandColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fc, <span class="hljs-keyword">int</span> bc)</span> </span>&#123;        Random random = <span class="hljs-keyword">new</span> Random();        <span class="hljs-keyword">if</span> (fc &gt; <span class="hljs-number">255</span>) &#123;            fc = <span class="hljs-number">255</span>;        &#125;        <span class="hljs-keyword">if</span> (bc &gt; <span class="hljs-number">255</span>) &#123;            bc = <span class="hljs-number">255</span>;        &#125;        <span class="hljs-keyword">int</span> r = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">int</span> g = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">int</span> b = fc + random.nextInt(bc - fc);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Color(r, g, b);    &#125;&#125;</code></pre><p>编写一个配置类，判断使用者是否自己实现了ValidateCodeGenerator类并放入IOC中，是：就用他自己的，否：用我们默认提供的</p><p>ValidateCodeBeanConfig</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.demo.core.validate.code;<span class="hljs-keyword">import</span> com.b4.demo.core.properties.SecurityProperties;<span class="hljs-keyword">import</span> com.b4.demo.core.validate.code.image.ImageValidateCodeGenerator;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeBeanConfig</span> </span>&#123;    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@ConditionalOnMissingBean</span>(name = <span class="hljs-string">"imageValidateCodeGenerator"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeGenerator <span class="hljs-title">imageValidateCodeGenerator</span><span class="hljs-params">()</span> </span>&#123;        ImageValidateCodeGenerator imageValidateCodeGenerator = <span class="hljs-keyword">new</span> ImageValidateCodeGenerator();        imageValidateCodeGenerator.setSecurityProperties(securityProperties);        <span class="hljs-keyword">return</span> imageValidateCodeGenerator;    &#125;&#125;</code></pre><p>ValidateCodeController#imageCreateCode：</p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> ValidateCodeGenerator imageValidateCodeGenerator;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/image"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">imageCreateCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        <span class="hljs-comment">//1：根据随机数生成图片</span>        ImageCodeDTO imageCodeDTO = (ImageCodeDTO) imageValidateCodeGenerator.generate(<span class="hljs-keyword">new</span> ServletWebRequest(request));        <span class="hljs-comment">//2：将图片放入session中</span>        sessionStrategy.setAttribute(<span class="hljs-keyword">new</span> ServletWebRequest(request), SESSION_KEY + <span class="hljs-string">"/image"</span>, imageCodeDTO);        <span class="hljs-comment">//3：将生成的图片写入接口的响应中</span>        ImageIO.write(imageCodeDTO.getImage(), <span class="hljs-string">"JPEG"</span>, response.getOutputStream());    &#125;</code></pre><p>前面实现了通过<code>SmsValidateCodeFilter</code>来拦截登录请求，在某些业务场景，可能还需要拦截其他的地址，这里的地址是可变的，下面我就来满足这个业务需求</p><p>ImageCodeProperties在加入url属性</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> String url;</code></pre><p>ImageValidateCodeFilter：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.mcr.s.auth.core.validate.code.image;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageValidateCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-comment">//配置文件中配置的需要验证码的拦截路径</span>    <span class="hljs-keyword">private</span> Set&lt;String&gt; urls = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-keyword">private</span> AntPathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-keyword">super</span>.afterPropertiesSet();        String[] configUrls = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (securityProperties.getCode().getImage().getUrl() != <span class="hljs-keyword">null</span>) &#123;            configUrls = StringUtils.splitByWholeSeparatorPreserveAllTokens(securityProperties.getCode().getImage().getUrl(), <span class="hljs-string">","</span>);        &#125;        <span class="hljs-keyword">if</span> (configUrls != <span class="hljs-keyword">null</span>) &#123;            urls.addAll(Arrays.asList(configUrls));        &#125;        urls.add(<span class="hljs-string">"/authentication/form"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        <span class="hljs-keyword">boolean</span> action = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (String url : urls) &#123;            <span class="hljs-keyword">if</span> (pathMatcher.match(url, request.getRequestURI())) &#123;                action = <span class="hljs-keyword">true</span>;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (action) &#123;            <span class="hljs-keyword">try</span> &#123;                validate(<span class="hljs-keyword">new</span> ServletWebRequest(request));            &#125; <span class="hljs-keyword">catch</span> (ValidateCodeException e) &#123;                authenticationFailureHandler.onAuthenticationFailure(request, response, e);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        filterChain.doFilter(request, response);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> ServletRequestBindingException </span>&#123;        ImageCodeDTO codeInSession = (ImageCodeDTO) sessionStrategy.getAttribute(request,                ValidateCodeController.SESSION_KEY + <span class="hljs-string">"/image"</span>);        String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), <span class="hljs-string">"imageCode"</span>);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码的值不能为空"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不存在"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession.isExpired()) &#123;            sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码已过期"</span>);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码不匹配"</span>);        &#125;        sessionStrategy.removeAttribute(request, ValidateCodeController.SESSION_KEY);    &#125;&#125;</code></pre><p>BrowserSecurityConfig#configure</p><pre><code class="hljs java">    imageValidateCodeFilter.setSecurityProperties(security);imageValidateCodeFilter.afterPropertiesSet();</code></pre><h2 id="手机验证码"><a href="#手机验证码" class="headerlink" title="手机验证码"></a>手机验证码</h2><p>现在使用者希望生成的短信验证码是6位数，我们之前因为给的是一个无法修改的长度，使用者来说是无法修改的，这些进行重构</p><hr><p>在这里开始之前，来看看以UML图：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567164661098.png" srcset="/img/loading.gif" alt="1567164661098"></p><p>这里可以看到<code>SmsCodeDTO</code>和<code>ImageCodeDTO</code>的属性有3个是相同的，这里可以通过继承关系来减少代码，<code>ImageCodeDTO</code>继承<code>SmsCodeDTO</code>就OK了，这里将<code>SmsCodeDTO</code>的名字修改为<code>ValidateCodeDTO</code>，这样才更像一个父类；</p><p>ImageCodeDTO</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.model.dto;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCodeDTO</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidateCodeDTO</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 图片</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> BufferedImage image;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCodeDTO</span><span class="hljs-params">(BufferedImage image, String code, <span class="hljs-keyword">int</span> expireAfterSeconds)</span> </span>&#123;        <span class="hljs-keyword">super</span>(code, expireAfterSeconds);        <span class="hljs-keyword">this</span>.image = image;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCodeDTO</span><span class="hljs-params">(BufferedImage image, String code, LocalDateTime expireTime)</span> </span>&#123;        <span class="hljs-keyword">super</span>(code, expireTime);        <span class="hljs-keyword">this</span>.image = image;    &#125;&#125;</code></pre><p>ValidateCodeGenerator</p><blockquote><p>返回类型改为ValidateCodeDTO</p></blockquote><pre><code class="hljs java"><span class="hljs-function">ValidateCodeDTO <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span></span>;</code></pre><p>如果使用者想把手机验证码的长度进行修改，这样的需求是无法实现的，因为我们这里的长度是写死的，然后假设我之前的的短信使用的是腾讯的短信服务，而使用者喜欢用阿里云的，但是没法改就只能含泪使用腾讯的了，这里就来重构这些的代码吧，让它变为可变的</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsCodeProperties</span> </span>&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 长度</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> length = <span class="hljs-number">6</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 过期秒数 默认3分钟</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> expireIn = <span class="hljs-number">180</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 拦截的请求</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String url;&#125;</code></pre><p>这里会想到ImageCodeProperties和SmsCodeProperties的属性很多都一样，这里也用继承关系来简化</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageCodeProperties</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SmsCodeProperties</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> width = <span class="hljs-number">67</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> height = <span class="hljs-number">23</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ImageCodeProperties</span><span class="hljs-params">()</span> </span>&#123;        setLength(<span class="hljs-number">4</span>);    &#125;&#125;</code></pre><p>ValidateCodeProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> SmsCodeProperties sms = <span class="hljs-keyword">new</span> SmsCodeProperties();</code></pre><p>定义一个发送器接口：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.sms;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsCodeSender</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String mobile, String code)</span></span>;&#125;</code></pre><p>发送接口默认实现类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.sms;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-meta">@Slf</span>4j<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultSmsCodeSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsCodeSender</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(String mobile, String code)</span> </span>&#123;        log.info(<span class="hljs-string">"腾讯云服务向手机-&gt;&#123;&#125;发送短信验证码-&gt;&#123;&#125;"</span>, mobile, code);    &#125;&#125;</code></pre><p>ValidateCodeBeanConfig</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnMissingBean</span>(SmsCodeSender<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">SmsCodeSender</span> <span class="hljs-title">smsCodeSender</span>() </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultSmsCodeSender();&#125;</code></pre><p>如果用户没有实现SmsCodeSender的类，就使用我提供的DefaultSmsCodeSender，也就是腾讯服务</p><hr><p>SmsValidateCodeGenerator</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.sms;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"smsValidateCodeGenerator"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsValidateCodeGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeGenerator</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeDTO <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        String code = RandomStringUtils.randomNumeric(securityProperties.getCode().getSms().getLength());        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ValidateCodeDTO(code, securityProperties.getCode().getSms().getExpireIn());    &#125;&#125;</code></pre><p>ValidateCodeController：</p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span>  <span class="hljs-keyword">private</span> ValidateCodeGenerator smsValidateCodeGenerator;  <span class="hljs-meta">@Resource</span>  <span class="hljs-keyword">private</span> SmsCodeSender smsCodeSender;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * 获取图片验证码</span><span class="hljs-comment">   */</span>  <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/sms"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createSms</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletRequestBindingException </span>&#123;      log.info(<span class="hljs-string">"获取短信验证码"</span>);      <span class="hljs-comment">//1.获取短信验证码</span>      ValidateCodeDTO validateCodeDTO = smsValidateCodeGenerator.generate(<span class="hljs-keyword">new</span> ServletWebRequest(request, response));      <span class="hljs-comment">//2.保存到session中</span>      sessionStrategy.setAttribute(<span class="hljs-keyword">new</span> ServletWebRequest(request), SESSION_KEY + <span class="hljs-string">"/sms"</span>, validateCodeDTO);      <span class="hljs-comment">//3.发送</span>      String mobile = ServletRequestUtils.getRequiredStringParameter(request, <span class="hljs-string">"mobile"</span>);      smsCodeSender.send(mobile, validateCodeDTO.getCode());  &#125;</code></pre><h2 id="硬字符串重构"><a href="#硬字符串重构" class="headerlink" title="硬字符串重构"></a>硬字符串重构</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.properties;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SecurityConstants</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认的处理验证码的url前缀</span><span class="hljs-comment">     */</span>    String DEFAULT_VALIDATE_CODE_URL_PREFIX = <span class="hljs-string">"/code"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 当请求需要身份认证时，默认跳转的url</span><span class="hljs-comment">     */</span>    String DEFAULT_UNAUTHENTICATED_URL = <span class="hljs-string">"/authentication/require"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认的用户名密码登录请求处理url</span><span class="hljs-comment">     */</span>    String DEFAULT_LOGIN_PROCESSING_URL_FORM = <span class="hljs-string">"/authentication/form"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认的手机验证码登录请求处理url</span><span class="hljs-comment">     */</span>    String DEFAULT_LOGIN_PROCESSING_URL_MOBILE = <span class="hljs-string">"/authentication/mobile"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 默认登录页面</span><span class="hljs-comment">     */</span>    String DEFAULT_LOGIN_PAGE_URL = <span class="hljs-string">"/mcr-login.html"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证图片验证码时，http请求中默认的携带图片验证码信息的参数的名称</span><span class="hljs-comment">     */</span>    String DEFAULT_PARAMETER_NAME_CODE_IMAGE = <span class="hljs-string">"imageCode"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证短信验证码时，http请求中默认的携带短信验证码信息的参数的名称</span><span class="hljs-comment">     */</span>    String DEFAULT_PARAMETER_NAME_CODE_SMS = <span class="hljs-string">"smsCode"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送短信验证码 或 验证短信验证码时，传递手机号的参数的名称</span><span class="hljs-comment">     */</span>    String DEFAULT_PARAMETER_NAME_MOBILE = <span class="hljs-string">"mobile"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * session失效默认的跳转地址</span><span class="hljs-comment">     */</span>    String DEFAULT_SESSION_INVALID_URL = <span class="hljs-string">"/session/invalid"</span>;&#125;</code></pre><p>BrowserSecurityProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> String loginUrl = SecurityConstants.DEFAULT_LOGIN_PAGE_URL;</code></pre><p>BrowserSecurityConfig</p><pre><code class="hljs java">            .loginPage(SecurityConstants.DEFAULT_UNAUTHENTICATED_URL)               .loginProcessingUrl(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM)                          SecurityConstants.DEFAULT_UNAUTHENTICATED_URL, SecurityConstants.DEFAULT_VALIDATE_CODE_URL_PREFIX + <span class="hljs-string">"/*"</span>)           &#125;</code></pre><p>SmsValidateCodeFilter</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (request.getRequestURI().equals(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE)</code></pre><p>SmsCodeAuthenticationFilter</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsCodeAuthenticationFilter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">super</span>(<span class="hljs-keyword">new</span> AntPathRequestMatcher(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, <span class="hljs-string">"POST"</span>));&#125;</code></pre><p>ImageValidateCodeFilter：</p><pre><code class="hljs java">String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_IMAGE);</code></pre><p>SmsValidateCodeFilter</p><pre><code class="hljs java">String codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(), SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_SMS);</code></pre><p>ValidateCodeController</p><pre><code class="hljs java">String mobile = ServletRequestUtils.getRequiredStringParameter(request, SecurityConstants.DEFAULT_PARAMETER_NAME_MOBILE);</code></pre><h2 id="验证码读写重构"><a href="#验证码读写重构" class="headerlink" title="验证码读写重构"></a>验证码读写重构</h2><p>通过以上的重构，是不是发现,手机验证码和图片验证码的生成逻辑非常得相似：</p><ol><li>生成验证码，放入session</li><li>用户登录时，拿出来进行对比</li></ol><p>这里定义一个枚举单例工厂</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> com.b4.mcr.auth.core.properties.SecurityConstants;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ValidateCodeType &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 短信验证码</span><span class="hljs-comment"> */</span>SMS &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParamNameOnValidate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_SMS;&#125;&#125;,<span class="hljs-comment">/**</span><span class="hljs-comment"> * 图片验证码</span><span class="hljs-comment"> */</span>IMAGE &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getParamNameOnValidate</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> SecurityConstants.DEFAULT_PARAMETER_NAME_CODE_IMAGE;&#125;&#125;;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 校验时从请求中获取的参数的名字</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getParamNameOnValidate</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>这里定义一个发送器接口，里面有2个方法，create：创建验证码并将验证码保存到session中，然后响应给前端，validate：效验用户填写的信息是否和session中一样</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 校验码处理器，封装不同校验码的处理逻辑</span><span class="hljs-comment"> * </span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ValidateCodeProcessor</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 验证码放入session时的前缀</span><span class="hljs-comment"> */</span>String SESSION_KEY_PREFIX = <span class="hljs-string">"SESSION_KEY_FOR_CODE_"</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建校验码</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 校验验证码</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest servletWebRequest)</span></span>;&#125;</code></pre><p>发送器接口的抽象实现类：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> org.apache.commons.lang.StringUtils;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.HttpSessionSessionStrategy;<span class="hljs-keyword">import</span> org.springframework.social.connect.web.SessionStrategy;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestBindingException;<span class="hljs-keyword">import</span> org.springframework.web.bind.ServletRequestUtils;<span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletWebRequest;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractValidateCodeProcessor</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ValidateCodeDTO</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ValidateCodeProcessor</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 操作session的工具类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> SessionStrategy sessionStrategy = <span class="hljs-keyword">new</span> HttpSessionSessionStrategy();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 收集系统中所有的 &#123;<span class="hljs-doctag">@link</span> ValidateCodeGenerator&#125; 接口的实现。</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Map&lt;String, ValidateCodeGenerator&gt; validateCodeGenerators;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(ServletWebRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        C validateCode = generate(request);        save(request, validateCode);        send(request, validateCode);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成校验码</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> C <span class="hljs-title">generate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        String type = getValidateCodeType().toString().toLowerCase();        String generatorName = type + ValidateCodeGenerator<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getSimpleName</span>()</span>;<span class="hljs-comment">//                String generatorName = type + StringUtils.substringAfter(ValidateCodeGenerator.class.getSimpleName(), "Validate");</span>        ValidateCodeGenerator validateCodeGenerator = validateCodeGenerators.get(generatorName);        <span class="hljs-keyword">if</span> (validateCodeGenerator == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码生成器"</span> + generatorName + <span class="hljs-string">"不存在"</span>);        &#125;        <span class="hljs-keyword">return</span> (C) validateCodeGenerator.generate(request);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 保存校验码</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(ServletWebRequest request, C validateCode)</span> </span>&#123;        sessionStrategy.setAttribute(request, getSessionKey(), validateCode);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构建验证码放入session时的key</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSessionKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> SESSION_KEY_PREFIX + getValidateCodeType().toString().toUpperCase();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据请求的url获取校验码的类型</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> ValidateCodeType <span class="hljs-title">getValidateCodeType</span><span class="hljs-params">()</span> </span>&#123;        String type = StringUtils.substringBefore(getClass().getSimpleName(), <span class="hljs-string">"ValidateCodeProcessor"</span>);        <span class="hljs-keyword">return</span> ValidateCodeType.valueOf(type.toUpperCase());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送校验码，由子类实现</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ServletWebRequest request, C validateCode)</span> <span class="hljs-keyword">throws</span> Exception</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validate</span><span class="hljs-params">(ServletWebRequest request)</span> </span>&#123;        ValidateCodeType processorType = getValidateCodeType();        String sessionKey = getSessionKey();        C codeInSession = (C) sessionStrategy.getAttribute(request, sessionKey);        String codeInRequest;        <span class="hljs-keyword">try</span> &#123;            codeInRequest = ServletRequestUtils.getStringParameter(request.getRequest(),                    processorType.getParamNameOnValidate());        &#125; <span class="hljs-keyword">catch</span> (ServletRequestBindingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"获取验证码的值失败"</span>);        &#125;        <span class="hljs-keyword">if</span> (StringUtils.isBlank(codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(processorType + <span class="hljs-string">"验证码的值不能为空"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(processorType + <span class="hljs-string">"验证码不存在"</span>);        &#125;        <span class="hljs-keyword">if</span> (codeInSession.isExpired()) &#123;            sessionStrategy.removeAttribute(request, sessionKey);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(processorType + <span class="hljs-string">"验证码已过期"</span>);        &#125;        <span class="hljs-keyword">if</span> (!StringUtils.equals(codeInSession.getCode(), codeInRequest)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(processorType + <span class="hljs-string">"验证码不匹配"</span>);        &#125;        sessionStrategy.removeAttribute(request, sessionKey);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.image;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 图片验证码处理器</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zhailiang</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span>(<span class="hljs-string">"imageValidateCodeProcessor"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImageValidateCodeProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValidateCodeProcessor</span>&lt;<span class="hljs-title">ImageCodeDTO</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 发送图形验证码，将其写到响应中</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ServletWebRequest request, ImageCodeDTO imageCode)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ImageIO.write(imageCode.getImage(), <span class="hljs-string">"JPEG"</span>, request.getResponse().getOutputStream());    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code.sms;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 短信验证码处理器</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span>(<span class="hljs-string">"smsValidateCodeProcessor"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsValidateCodeProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractValidateCodeProcessor</span>&lt;<span class="hljs-title">ValidateCodeDTO</span>&gt; </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 短信验证码发送器</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SmsCodeSender smsCodeSender;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ServletWebRequest request, ValidateCodeDTO validateCode)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        String paramName = SecurityConstants.DEFAULT_PARAMETER_NAME_MOBILE;        String mobile = ServletRequestUtils.getRequiredStringParameter(request.getRequest(), paramName);        smsCodeSender.send(mobile, validateCode.getCode());    &#125;&#125;</code></pre><p>那么controller中要如何使用呢？写2个方法？这里用这么一个办法，只需要编写一个方法就搞定了,</p><p>首先这里的findValidateCodeProcessor方法通过不同的type来从validateCodeProcessors成员变量中拿取不同的ValidateCodeProcessor实现。这里使用了容器单例模式</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeProcessorHolder</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> Map&lt;String, ValidateCodeProcessor&gt; validateCodeProcessors;<span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeProcessor <span class="hljs-title">findValidateCodeProcessor</span><span class="hljs-params">(ValidateCodeType type)</span> </span>&#123;<span class="hljs-keyword">return</span> findValidateCodeProcessor(type.toString().toLowerCase());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> ValidateCodeProcessor <span class="hljs-title">findValidateCodeProcessor</span><span class="hljs-params">(String type)</span> </span>&#123;String name = type.toLowerCase() + ValidateCodeProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getSimpleName</span>()</span>;ValidateCodeProcessor processor = validateCodeProcessors.get(name);<span class="hljs-keyword">if</span> (processor == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateCodeException(<span class="hljs-string">"验证码处理器"</span> + name + <span class="hljs-string">"不存在"</span>);&#125;<span class="hljs-keyword">return</span> processor;&#125;&#125;</code></pre><p>获取图片验证码的请求：<code>/code/image</code>，发送短信验证码的请求：<code>/code/sms</code>，这里会给到type参数上，然后交给<code>validateCodeProcessorHolder#findValidateCodeProcessor</code>，获取对应的<code>ValidateCodeProcessor</code>实现，调用它2的create方法，而它两的create方法是父类<code>AbstractValidateCodeProcessor</code>的，那么就会调用<code>generate</code>方法生成验证码，然后通过<code>save</code>保存到<code>session</code>中，最后调用<code>send</code>方法发送出去</p><p>ValidateCodeController</p><pre><code class="hljs java"><span class="hljs-meta">@Resource</span>   <span class="hljs-keyword">private</span> ValidateCodeProcessorHolder validateCodeProcessorHolder;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建验证码，根据验证码类型不同，调用不同的 &#123;<span class="hljs-doctag">@link</span> ValidateCodeProcessor&#125;接口实现</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;type&#125;"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createCode</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, @PathVariable String type)</span></span><span class="hljs-function">           <span class="hljs-keyword">throws</span> Exception </span>&#123;       validateCodeProcessorHolder.findValidateCodeProcessor(type).create(<span class="hljs-keyword">new</span> ServletWebRequest(request, response));   &#125;</code></pre><p>ValidateCodeFilter，将2个校验过滤器结合起来，其他2个可以删除掉了</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.core.validate.code;<span class="hljs-meta">@Component</span>(<span class="hljs-string">"validateCodeFilter"</span>)<span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValidateCodeFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证码校验失败处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> AuthenticationFailureHandler authenticationFailureHandler;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 系统配置信息</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> SecurityProperties securityProperties;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 系统中的校验码处理器</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> ValidateCodeProcessorHolder validateCodeProcessorHolder;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 存放所有需要校验验证码的url</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ValidateCodeType&gt; urlMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 验证请求url与配置的url是否匹配的工具类</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AntPathMatcher pathMatcher = <span class="hljs-keyword">new</span> AntPathMatcher();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 初始化要拦截的url配置信息</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;        <span class="hljs-keyword">super</span>.afterPropertiesSet();        urlMap.put(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_FORM, ValidateCodeType.IMAGE);        addUrlToMap(securityProperties.getCode().getImage().getUrl(), ValidateCodeType.IMAGE);        urlMap.put(SecurityConstants.DEFAULT_LOGIN_PROCESSING_URL_MOBILE, ValidateCodeType.SMS);        addUrlToMap(securityProperties.getCode().getSms().getUrl(), ValidateCodeType.SMS);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 讲系统中配置的需要校验验证码的URL根据校验的类型放入map</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUrlToMap</span><span class="hljs-params">(String urlString, ValidateCodeType type)</span> </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(urlString)) &#123;            String[] urls = StringUtils.splitByWholeSeparatorPreserveAllTokens(urlString, <span class="hljs-string">","</span>);            <span class="hljs-keyword">for</span> (String url : urls) &#123;                urlMap.put(url, type);            &#125;        &#125;    &#125;    <span class="hljs-comment">/*</span><span class="hljs-comment">     * (non-Javadoc)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * @see</span><span class="hljs-comment">     * org.springframework.web.filter.OncePerRequestFilter#doFilterInternal(</span><span class="hljs-comment">     * javax.servlet.http.HttpServletRequest,</span><span class="hljs-comment">     * javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain)</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        ValidateCodeType type = getValidateCodeType(request);        <span class="hljs-keyword">if</span> (type != <span class="hljs-keyword">null</span>) &#123;            logger.info(<span class="hljs-string">"校验请求("</span> + request.getRequestURI() + <span class="hljs-string">")中的验证码,验证码类型"</span> + type);            <span class="hljs-keyword">try</span> &#123;                validateCodeProcessorHolder.findValidateCodeProcessor(type)                        .validate(<span class="hljs-keyword">new</span> ServletWebRequest(request, response));                logger.info(<span class="hljs-string">"验证码校验通过"</span>);            &#125; <span class="hljs-keyword">catch</span> (ValidateCodeException exception) &#123;                authenticationFailureHandler.onAuthenticationFailure(request, response, exception);                <span class="hljs-keyword">return</span>;            &#125;        &#125;        chain.doFilter(request, response);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取校验码的类型，如果当前请求不需要校验，则返回null</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> ValidateCodeType <span class="hljs-title">getValidateCodeType</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        ValidateCodeType result = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">if</span> (!StringUtils.equalsIgnoreCase(request.getMethod(), <span class="hljs-string">"get"</span>)) &#123;            Set&lt;String&gt; urls = urlMap.keySet();            <span class="hljs-keyword">for</span> (String url : urls) &#123;                <span class="hljs-keyword">if</span> (pathMatcher.match(url, request.getRequestURI())) &#123;                    result = urlMap.get(url);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><p>BrowserSecurityConfig：</p><pre><code class="hljs java">   <span class="hljs-keyword">private</span> ValidateCodeFilter validateCodeFilter;    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">//...</span>http.                .addFilterBefore(validateCodeFilter,UsernamePasswordAuthenticationFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"></span><span class="hljs-class"></span><span class="hljs-class">&#125;</span></code></pre><h1 id="记住我"><a href="#记住我" class="headerlink" title="记住我"></a>记住我</h1><p>当用户登录一次以后系统会记住用户一段时间，在段时间用户不能反复登录就可以使用我们的系统</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>BrowserSecurityProperties</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rememberMeSeconds = <span class="hljs-number">36000</span>;</code></pre><p>BrowserSecurityConfig</p><pre><code class="hljs java">  <span class="hljs-keyword">private</span> DataSource dataSource;    <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersistentTokenRepository <span class="hljs-title">repository</span><span class="hljs-params">()</span> </span>&#123;        JdbcTokenRepositoryImpl jdbcTokenRepository = <span class="hljs-keyword">new</span> JdbcTokenRepositoryImpl();        jdbcTokenRepository.setDataSource(dataSource);        <span class="hljs-comment">//自动创建表</span>        jdbcTokenRepository.setCreateTableOnStartup(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span> jdbcTokenRepository;    &#125;<span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        BrowserSecurityProperties browser = security.getBrowser();        http                <span class="hljs-comment">/*rememberMe*/</span>                .rememberMe()                .tokenRepository(repository())                .tokenValiditySeconds(browser.getRememberMeSeconds())                .userDetailsService(userDetailsService)                .and()</code></pre><p>mcr-login.html</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>登录页面<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"/authentication/form"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>账号<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>图形验证码:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"imageCode"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/code/image"</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>                记住我 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remember-me"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567436120008.png" srcset="/img/loading.gif" alt="1567436120008"></p><p>UsernamePasswordAuthenticationFilter认证成功处理以后，它会调用一个RememberMeServices服务，这这个服务中有一个TokenRepository，这个服务它会生成一个token，将这个token写入浏览器到浏览器的cookie里面，同时它会用这个TokenRepository把生成的token写到到数据库里面，因为这个动作是在身份认证成功以后做的，所以它在 token写入数据库的时候，会把认证成功的用户名同时写进去，数据库中token和用户名是一一对应的，比如过了一天用户又来访问系统，他就不需要登录了，他就可以直接访问收保护的服务，那么这个请求经过过滤器链的时候会经过RememberMeAuthenticationFilter过滤器，它会读取cookie中的 token，因为用户在登录成功的时候，就是把一个token写入到浏览器的cookie里，那么在这个过滤器它会把这个token从cookie里读出来，交给RememberMeServices，RememberMeServices会用TokenRepository到数据库里去查这个token我数据库里有没有记录，如果数据库里有记录，那么就把对应的用户名取出来，取出来用户名以后，它会去调用UserDetailsService，然后去获取用户的信息，把当前获取到的用户信息放到SecurityContext里面，这样就把用户登录上了</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1567436147796.png" srcset="/img/loading.gif" alt="1567436147796"></p><p>这里的RememberMeAuthenticationFilter它在过滤器链上绿色部分的倒数第2个位置，前面是一些其他认证过滤器，其他认证都没法认证用户信息的时候，它会去尝试去做认证</p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 二、Form 】  1.Spring Secrutiy基本原理</title>
    <link href="/spring-security-2.1.html"/>
    <url>/spring-security-2.1.html</url>
    
    <content type="html"><![CDATA[<p>请将<code>yml</code>中的这段代码删除，接下来开始学习<code>Spring Security</code>,这段配置是用来关闭/开启它的功能的</p><pre><code class="hljs yaml"><span class="hljs-attr">security:</span>  <span class="hljs-attr">basic:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span></code></pre><p>现在在浏览器中访问，会出现以下弹框</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566728660810.png" srcset="/img/loading.gif" alt="1566728660810"></p><p>这个是<code>spring security</code>的默认配置，这些配置写在<code>WebSecurityConfigurerAdapter</code>中</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;logger.debug(<span class="hljs-string">"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."</span>);http.authorizeRequests().anyRequest().authenticated().and().formLogin().and().httpBasic();&#125;</code></pre><p>我们来登录一下，这里的密码可以在控制台中找到，账号是固定user，密码就是控制台上看见的这个</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566729135804.png" srcset="/img/loading.gif" alt="1566729135804"></p><p>表单登录：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.auth.browser;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="hljs-keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BrowserSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        http                .formLogin().and()                .authorizeRequests()                .anyRequest().authenticated();    &#125;&#125;</code></pre><blockquote><p>这里的代码是针对浏览器来的配置，所以是编写在browser模块中的</p></blockquote><p>现在访问接口时会是这样子：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566729509366.png" srcset="/img/loading.gif" alt="1566729509366"></p><p>原理：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566723514793.png" srcset="/img/loading.gif" alt="1566723514793"></p><p><code>spring secrutiy</code>中最核心是一组过滤器链，之前通过过滤器来拦截<code>rest api</code>，<code>spring security</code>也是通过这种方式来做的，这些过滤器在系统启动的时候<code>spring boot</code>会自动把它都配进去，首先来详细介绍最主要的几个过滤器,最核心的就是图上的绿色过滤器：</p><ul><li>UsernamePasswordAuthenticationFilter：处理表单登录</li><li>BasicAuthenticationFilter：处理http basic登录</li></ul><p>绿色的过滤器用来检查请求中是否有它需要的信息，比如<code>UsernamePasswordAuthenticationFilter</code>这个过滤器来说它会检查你的请求是不是一个登录请求，然后在这个登录请求中看带没带用户名和密码，如果带了这个过滤器就会尝试用用户名和密码去做用户的登录，如果没有带，它就会放过去，交给下一个过滤器，下一个过滤器比如说是<code>BasicAuthenticationFilter</code>，它会检查请求的请求头里面是否有<code>Basic Authorization</code>的信息，如果有，尝试拿出来做<code>base64</code>字节码取出用户名密码来登录，如果还有其他的认证方式（在spring security）它还提供了很多其他的认证方式，按照这个原理它会一个个往下走，任何一个过滤器，它成功完成了用户登录以后，它会在请求上做一个标记：当前这个用户认证成功了，请求经过这些绿色的过滤器之后，会到<code>FilterSecurityInterceptor</code>拦截器中，这个过拦截器是整个<code>spring security</code>过滤器链上的最后一个，它是最终的守门人，它门后就是我们编写的<code>rest api</code>，在个拦截器中它会决定当前请求能不能去访问后面的<code>rest api</code>。它会依据你编写的配置（<code>BrowserSecurityConfig</code>）进行判断，判断当前请求是不是经过前面某一个过滤器的身份认证，判断的结果是过，就能访问到<code>rest api</code>，如果不过，它会根据不过的原因来抛出不同的异常，在它的前面的<code>ExceptionTranslationFilter</code>,这个过滤器会来捕获<code>FilterSecurityInterceptor</code>抛出来的异常，然后根据不同的异常做相应的处理，比如是没有登录不能访问，它会根据前面的配置引导用户去登录，例如你配置的是<code>formLogin</code>就会自动跳转到登录页面，配置的是<code>basicLogin</code>，就是弹框。在这里绿色的过滤器，你是可以控制的，其他过滤器你是不能控制的，它一定会在<code>spring security</code>规定的位置执行。</p><hr><p>下面debug来到这几个过滤器上加断点</p><p>这个是等会我访问的接口</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566729706574.png" srcset="/img/loading.gif" alt="1566729706574"></p><hr><p>断点位置：</p><ul><li><code>FilterSecurityInterceptor#invoke</code>-&gt;124行</li><li><code>ExceptionTranslationFilter#doFilter</code>-&gt;123行</li><li><code>ExceptionTranslationFilter#doFilter</code>-&gt;123行</li><li><code>UsernamePasswordAuthenticationFilter</code>-&gt;61行</li></ul><p>访问<a href="http://localhost:8080/user" target="_blank" rel="noopener">http://localhost:8080/user</a></p><p>现在它来到了：</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566730453087.png" srcset="/img/loading.gif" alt="1566730453087"></p><p>因为访问这个<code>/user</code>，没带登录信息，所以前面的过滤器都不起作用，一直跑到<code>FilterSecurityInterceptor</code>里面，由这个断点位置的代码做判断：能不能访问<code>/user</code>接口</p><p>然后接着执行完这里的代码，它抛出了一个异常，这个异常会抛到<code>ExceptionTranslationFilter</code>过滤器中</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566730671953.png" srcset="/img/loading.gif" alt="1566730671953"></p><p>然后根据异常做处理，因为没登录，所以会重定向到登录页面上去，我这里填写正确的账号和密码进行登录，这个时候会停在<code>UsernamePasswordAuthenticationFilter</code>，它获取用户填写的信息进行登录</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566730843749.png" srcset="/img/loading.gif" alt="1566730843749"></p><p>接着往下走</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566731054715.png" srcset="/img/loading.gif" alt="1566731054715"></p><p>它在这里又来验证请求是否能访问，再往下</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566731095879.png" srcset="/img/loading.gif" alt="1566731095879"></p><p>这回它没抛异常了，来执行了<code>fi.getChain().doFilter(fi.getRequest(), fi.getResponse());</code>代码，这里实际上也就是调用<code>/user</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566731157388.png" srcset="/img/loading.gif" alt="1566731157388"></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 一、Restful Api 】  3.Restful Api</title>
    <link href="/spring-security-1.3.html"/>
    <url>/spring-security-1.3.html</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在使用<code>spring mvc</code>框架时，<code>get</code>、<code>post</code>请求用得是最多得，在不同的业务场景进行选择，在笔者身边的同事不太注重这些，夸张点全部使用post请求，这样是不合理的，笔者总结了以下几种：</p><table><thead><tr><th align="center">请求</th><th align="center">业务场景</th></tr></thead><tbody><tr><td align="center">get</td><td align="center">查询</td></tr><tr><td align="center">post</td><td align="center">新增</td></tr><tr><td align="center">put</td><td align="center">修改</td></tr><tr><td align="center">delete</td><td align="center">删除</td></tr></tbody></table><blockquote><p>在团队开发中都根据这样去写代码，看一个接口做了什么行为只需要看请求方式就OK了，良好的编码习惯使系统更容易维护，如果读者之前没有按照这样做，请现在开始养成这种习惯，<strong>良好的编码习惯很重要</strong>！！！</p><hr><p>笔者会编写一套<code>CRUD</code>，给读者进行参考</p></blockquote><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><p>为查询接口的响应封装成一个类</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.model.vo;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> String userId;    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-keyword">private</span> String password;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.controller;<span class="hljs-keyword">import</span> com.b4.mcr.model.vo.UserVO;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Arrays.asList(                <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"001"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"t1"</span>),                <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"002"</span>, <span class="hljs-string">"t2"</span>, <span class="hljs-string">"t2"</span>),                <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"003"</span>, <span class="hljs-string">"t3"</span>, <span class="hljs-string">"t3"</span>)        );    &#125;    <span class="hljs-meta">@PostMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(@RequestBody UserVO userVO)</span> </span>&#123;        <span class="hljs-comment">//新增逻辑</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@PutMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">update</span><span class="hljs-params">(@RequestBody UserVO userVO)</span> </span>&#123;        <span class="hljs-comment">//修改逻辑</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@DeleteMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">delete</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;        <span class="hljs-comment">//删除逻辑</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> UserVO <span class="hljs-title">geInfo</span><span class="hljs-params">(@PathVariable String id)</span> </span>&#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"t001"</span>, <span class="hljs-string">"t1"</span>, <span class="hljs-string">"t1"</span>);    &#125;&#125;</code></pre><h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><p>从刚刚编写的<code>list</code>方法中，我不希望将所有字段给前端展示，而这个<code>get</code>方法要根据角色的权限才能访问，例如admin，可以查看指定账号的密码。我们在开发中，假设使用的是<code>mybatis plus</code>框架，通过调用它自带的<code>get</code>、<code>getOne</code>方法都是全字段查询，哪改怎么办？要自己动手写<code>mapper.xml</code>，就为了少一个密码字段？那如果哪一天这个表可能多了一个字段，又要改<code>mapper.xml</code>中的这个语句，想想都觉得痛苦，笔者这里会给读者介绍一个对这种业务场景，非常适用的解决方案——<code>@JsonView</code>注解，使用方式：</p><ul><li>使用接口来声明多个视图</li><li>在值对象的<code>get</code>方法上指定视图</li><li>在<code>Controller</code>方法上指定视图</li></ul><h2 id="abbrlink-1"><a href="#abbrlink-1" class="headerlink" title="abbrlink: 1"></a>abbrlink: 1</h2><p>在<code>UserVO</code>的中声明了 2个接口<code>UserSimpleView</code>、<code>UserDetailView</code>，<code>UserDetailView</code>接口继承与<code>UserSimpleView</code>接口，<code>userName</code>属性上修饰了<code>@JsonView</code>，指定的是<code>UserSimpleView</code>属性，而<code>password</code>指定的是<code>UserDetailView</code>，由于<code>UserDetailView</code>继承于<code>UserSimpleView</code>，所以它也包含了<code>userName</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.model.vo;<span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonView;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserSimpleView</span> </span>&#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDetailView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserSimpleView</span> </span>&#123;    &#125;    <span class="hljs-meta">@JsonView</span>(UserSimpleView<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">userName</span></span>;    <span class="hljs-meta">@JsonView</span>(UserDetailView<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    <span class="hljs-title">private</span> <span class="hljs-title">String</span> <span class="hljs-title">password</span></span>;&#125;</code></pre><p>在<code>UserController</code>的<code>list</code>、<code>get</code>方法上声明</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span><span class="hljs-meta">@JsonView</span>(UserVO.UserSimpleView<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">UserVO</span>&gt; <span class="hljs-title">query</span>() </span>&#123;    <span class="hljs-keyword">return</span> Arrays.asList(            <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t1"</span>),            <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"t2"</span>, <span class="hljs-string">"t2"</span>),            <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"t3"</span>, <span class="hljs-string">"t3"</span>)    );&#125;<span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)<span class="hljs-meta">@JsonView</span>(UserVO.UserDetailView<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">UserVO</span> <span class="hljs-title">geInfo</span>(@<span class="hljs-title">PathVariable</span> <span class="hljs-title">String</span> <span class="hljs-title">id</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserVO(<span class="hljs-string">"t1"</span>, <span class="hljs-string">"t1"</span>);&#125;</code></pre><p>list方法的响应：</p><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"t1"</span>    &#125;,    &#123;        <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"t2"</span>    &#125;,    &#123;        <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"t3"</span>    &#125;]</code></pre><p>get方法的响应：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"t1"</span>,    <span class="hljs-attr">"password"</span>: <span class="hljs-string">"t1"</span>&#125;</code></pre><h2 id="新增、修改接口"><a href="#新增、修改接口" class="headerlink" title="新增、修改接口"></a>新增、修改接口</h2><p>在做新增和修改的时候，肯定会有这么一个场景：对客户端传递过来的数据进行校验，通过if传统的方式来进行判断，如果发生错误信息就响应相关的提示信息，首先这样写是没什么问题，但是各种if的逻辑在实际的开发中很容易出现各种问题，做的好一点，可以抽象成一个方法，做的不好一点可能会出现复制出现大量冗余的代码，一旦出现复制，在修改的时候就很麻烦，需要一个个进行修改，笔者会在这里通过一些办法来解决这个问题。</p><p>传统方式：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(StringUtils.isBlank(userVO.getXXX()))&#123;<span class="hljs-keyword">if</span>(...)     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ...&#125;<span class="hljs-keyword">if</span> ...</code></pre><p>解决方案：</p><p>在<code>org.hibernate.validator</code>这个包下面提供了一些校验注解，通过这些注解就能轻松的进行数据效验</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566701442199.png" srcset="/img/loading.gif" alt="1566701442199"></p><p>在<code>UserVO</code>中的使用<code>NotBlank</code>注解来修饰password属性，添加上这个注解就可以不用在控制器中写if判断数据是不是空了</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserVO</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;   <span class="hljs-comment">//...</span>    <span class="hljs-meta">@NotBlank</span>    <span class="hljs-keyword">private</span> String password;&#125;</code></pre><p>我们还要在控制器的参数中加上<code>Valid</code>注解来告诉这里的参数需要验证</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(@Valid @RequestBody UserVO userVO)</span> </span>&#123;   <span class="hljs-comment">//...</span>  &#125;</code></pre><p>现在通过<code>post man</code>工具进行访问这个接口（如果读者不清楚post man是干什么的，可以来看下这个<a href="https://www.jianshu.com/p/6c9b45994c34" target="_blank" rel="noopener">文档</a>）</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566701998934.png" srcset="/img/loading.gif" alt="1566701998934"></p><p>这里可以看到，校验是通过的，这里还需要加上一个<code>BindingResult</code>参数，它里面存储了这些错误信息，</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(@Valid @RequestBody UserVO userVO, BindingResult errors)</span> </span>&#123;        <span class="hljs-keyword">if</span> (errors.hasErrors()) &#123;            errors.getAllErrors().forEach(error -&gt; System.out.println(error.getDefaultMessage()));            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//新增逻辑</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566702315546.png" srcset="/img/loading.gif" alt="1566702315546"></p><p>这里还有其他的注解，笔者就不一一列举，感兴趣的读者可以自己来试一下</p><table><thead><tr><th align="center">注解</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">@NotNull</td><td align="center">值不能为空</td></tr><tr><td align="center">@Null</td><td align="center">值必须为空</td></tr><tr><td align="center">@Pattern(regex=)</td><td align="center">字符串必须匹配正则表达式</td></tr><tr><td align="center">@Size(min=,max=)</td><td align="center">集合的元素必须在min和max之间</td></tr><tr><td align="center">@CreditCardNumber</td><td align="center">字符串必须是信用卡号（按美国的标准验证）</td></tr><tr><td align="center">@Email</td><td align="center">字符串必须是Email地址</td></tr><tr><td align="center">@Length(min=,max=)</td><td align="center">检查字符串的长度</td></tr><tr><td align="center">@NotBlank</td><td align="center">字符串必须有字符</td></tr><tr><td align="center">@NotEmpty</td><td align="center">字符串不能为null，集合由元素</td></tr><tr><td align="center">@Range(min=,max=)</td><td align="center">数字必须大于等于min，小于等于max</td></tr><tr><td align="center">@SafeHtml</td><td align="center">字符串是安全的html</td></tr><tr><td align="center">@URL</td><td align="center">字符串是合法的URL</td></tr><tr><td align="center">@AssertFalse</td><td align="center">值必须是false</td></tr><tr><td align="center">@AssertTrue</td><td align="center">值必须是true</td></tr><tr><td align="center">@DecimalMax(value=,inclusive=)</td><td align="center">值必须小于等（inclusive=true）/小于（inclusive=false）,value属性指定的值。可以注解在字符串类型属性上</td></tr><tr><td align="center">@DecimalMin(value=,inclusive=)</td><td align="center">值必须大于等（inclusive=true）/大于（inclusive=false）,value属性指定的值。可以注解在字符串类型属性上</td></tr><tr><td align="center">@Digits</td><td align="center">数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度</td></tr><tr><td align="center">@Future</td><td align="center">值必须是未来的日期</td></tr><tr><td align="center">@Past</td><td align="center">值必须是过去的日期</td></tr><tr><td align="center">@Max</td><td align="center">值必须小于等于value指定的值。不能注解在字符串类型的属性上</td></tr><tr><td align="center">@Min</td><td align="center">值必须大于等于value指定的值。不能注解在字符串类型的属性上</td></tr></tbody></table><hr><p><code>Hibernate Validator</code>中提供了一套效验注解供我们使用，可在一些业务场景中，这些注解是明显不够用的，这里笔者会带着大家来自定义这种注解，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.validator;<span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<span class="hljs-keyword">import</span> java.lang.annotation.Retention;<span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<span class="hljs-keyword">import</span> java.lang.annotation.Target;<span class="hljs-keyword">import</span> javax.validation.Constraint;<span class="hljs-keyword">import</span> javax.validation.Payload;<span class="hljs-meta">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Constraint</span>(validatedBy = MyConstraintValidator<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">MyConstraint</span> </span>&#123;<span class="hljs-function">String <span class="hljs-title">message</span><span class="hljs-params">()</span></span>;Class&lt;?&gt;[] groups() <span class="hljs-keyword">default</span> &#123; &#125;;Class&lt;? extends Payload&gt;[] payload() <span class="hljs-keyword">default</span> &#123; &#125;;&#125;</code></pre><p>这里先创建了一个注解类：<code>MyConstraint</code>，它里面有<code>message</code>、<code>groups</code>、<code>payload</code>这3个方法，这里是根据<code>Hibernate Validator</code>的约定来的，是不行要有的3个方法，作用笔者不一一介绍，感兴趣的读者可以去看<a href="https://hibernate.org/validator/" target="_blank" rel="noopener">官方文档</a></p><p>要对<code>MyConstraint</code>接口实现校验，需要创建一个类实现<code>ConstraintValidator</code>接口，并且在<code>MyConstraint</code>注解类上通过<code>@Constraint(validatedBy = xxx.class)</code>，来标识效验器，先不急着写，来看看它里面的源码是怎么写的，来看看<code>ConstraintValidator</code>类</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment">* JBoss, Home of Professional Open Source</span><span class="hljs-comment">* Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors</span><span class="hljs-comment">* by the @authors tag. See the copyright.txt in the distribution for a</span><span class="hljs-comment">* full listing of individual contributors.</span><span class="hljs-comment">*</span><span class="hljs-comment">* Licensed under the Apache License, Version 2.0 (the "License");</span><span class="hljs-comment">* you may not use this file except in compliance with the License.</span><span class="hljs-comment">* You may obtain a copy of the License at</span><span class="hljs-comment">* http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment">* Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment">* distributed under the License is distributed on an "AS IS" BASIS,</span><span class="hljs-comment">* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="hljs-comment">* See the License for the specific language governing permissions and</span><span class="hljs-comment">* limitations under the License.</span><span class="hljs-comment">*/</span><span class="hljs-keyword">package</span> javax.validation;<span class="hljs-keyword">import</span> javax.validation.constraintvalidation.SupportedValidationTarget;<span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Defines the logic to validate a given constraint &#123;<span class="hljs-doctag">@code</span> A&#125;</span><span class="hljs-comment"> * for a given object type &#123;<span class="hljs-doctag">@code</span> T&#125;.</span><span class="hljs-comment"> * &lt;p/&gt;</span><span class="hljs-comment"> * Implementations must comply to the following restriction:</span><span class="hljs-comment"> * &lt;ul&gt;</span><span class="hljs-comment"> *     &lt;li&gt;&#123;<span class="hljs-doctag">@code</span> T&#125; must resolve to a non parameterized type&lt;/li&gt;</span><span class="hljs-comment"> *     &lt;li&gt;or generic parameters of &#123;<span class="hljs-doctag">@code</span> T&#125; must be unbounded</span><span class="hljs-comment"> *     wildcard types&lt;/li&gt;</span><span class="hljs-comment"> * &lt;/ul&gt;</span><span class="hljs-comment"> * &lt;p/&gt;</span><span class="hljs-comment"> * The annotation &#123;<span class="hljs-doctag">@link</span> SupportedValidationTarget&#125; can be put on a</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> ConstraintValidator&#125; implementation to mark it as supporting</span><span class="hljs-comment"> * cross-parameter constraints. Check out &#123;<span class="hljs-doctag">@link</span> SupportedValidationTarget&#125;</span><span class="hljs-comment"> * and &#123;<span class="hljs-doctag">@link</span> Constraint&#125; for more information.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Emmanuel Bernard</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Hardy Ferentschik</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Annotation</span>, <span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Initializes the validator in preparation for</span><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #isValid(Object, ConstraintValidatorContext)&#125; calls.</span><span class="hljs-comment"> * The constraint annotation for a given constraint declaration</span><span class="hljs-comment"> * is passed.</span><span class="hljs-comment"> * &lt;p/&gt;</span><span class="hljs-comment"> * This method is guaranteed to be called before any use of this instance for</span><span class="hljs-comment"> * validation.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> constraintAnnotation annotation instance for a given constraint declaration</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(A constraintAnnotation)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Implements the validation logic.</span><span class="hljs-comment"> * The state of &#123;<span class="hljs-doctag">@code</span> value&#125; must not be altered.</span><span class="hljs-comment"> * &lt;p/&gt;</span><span class="hljs-comment"> * This method can be accessed concurrently, thread-safety must be ensured</span><span class="hljs-comment"> * by the implementation.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value object to validate</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> context context in which the constraint is evaluated</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> false&#125; if &#123;<span class="hljs-doctag">@code</span> value&#125; does not pass the constraint</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(T value, ConstraintValidatorContext context)</span></span>;&#125;</code></pre><p>笔者整理这2个类的作用：</p><ul><li>initialize:初始化自己，它这里的<code>constraintAnnotation</code>参数是<code>Annotation</code>的子类，也就是那些校验的注解，在这可以通过这个参数拿到应用层中写的<code>message</code>、<code>max</code>这些值，存储到自己的成员变量中</li><li><code>isValid</code>：方法中编写你的效验逻辑，第1个参数<code>value</code>:获取被注解的属性、方法的值，另外一个就不多讲，很少用得上（PS：笔者这里没用过，哈哈），返回值是<code>true</code>表示验证通过，false表示数据有问题</li></ul><p>接着来看下<code>Hibernate Validator</code>是如何实现<code>ConstraintValidator</code>接口的呢？这里以<code>NotBlank</code>注解的效验器为例，我通过IDEA，查找到<code>NotBlankValidator</code></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566705844750.png" srcset="/img/loading.gif" alt="1566705844750"></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotBlankValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">NotBlank</span>, <span class="hljs-title">CharSequence</span>&gt; </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(NotBlank annotation)</span> </span>&#123;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Checks that the trimmed string is not empty.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> charSequence The character sequence to validate.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> constraintValidatorContext context in which the constraint is evaluated.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Returns &lt;code&gt;true&lt;/code&gt; if the string is &lt;code&gt;null&lt;/code&gt; or the length of &lt;code&gt;charSequence&lt;/code&gt; between the specified</span><span class="hljs-comment"> *         &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; values (inclusive), &lt;code&gt;false&lt;/code&gt; otherwise.</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(CharSequence charSequence, ConstraintValidatorContext constraintValidatorContext)</span> </span>&#123;<span class="hljs-keyword">if</span> ( charSequence == <span class="hljs-keyword">null</span> ) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-keyword">return</span> charSequence.toString().trim().length() &gt; <span class="hljs-number">0</span>;&#125;&#125;</code></pre><p>它这里<code>initialize</code>没有写内容，来看这个<code>isValid</code>方法的实现：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.validator;<span class="hljs-keyword">import</span> javax.validation.ConstraintValidator;<span class="hljs-keyword">import</span> javax.validation.ConstraintValidatorContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConstraintValidator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConstraintValidator</span>&lt;<span class="hljs-title">MyConstraint</span>, <span class="hljs-title">Object</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(MyConstraint constraintAnnotation)</span> </span>&#123;        System.out.println(<span class="hljs-string">"my validator init"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(Object value, ConstraintValidatorContext context)</span> </span>&#123;        System.out.println(value);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre><p>然后在UserVO中的username注解刚刚编写的MyConstraint</p><pre><code class="hljs java"><span class="hljs-meta">@MyConstraint</span>(message = <span class="hljs-string">"test"</span>) <span class="hljs-keyword">private</span> String userName;</code></pre><p>来测试一下，还是通过post man访问add方法</p><p>控制台内容：</p><pre><code class="hljs applescript"><span class="hljs-keyword">my</span> validator initt1不能为空</code></pre><p>相信笔者在这里也明白校验器的声明周期了，它在程序启动时，并不会进行初始化，而在调用接口的时候，如果这个接口的参数中的属性使用了我们自己定义的<code>MyConstraint</code>注解，它就会先进行初始化，然后再进行校验</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>笔者会领着读者先去查看<code>spring boot</code>中给我们提供的默认错误处理。</p><p>现在访问<a href="http://localhost:8080/xxx，这个接口是不存在的，它会在浏览器响应这么一段内容" target="_blank" rel="noopener">http://localhost:8080/xxx，这个接口是不存在的，它会在浏览器响应这么一段内容</a></p><pre><code class="hljs j">Whitelabel Error PageThis application has no explicit mapping for &#x2F;error, so you are seeing this as a fallback.Sun Aug 25 12:24:52 CST 2019There was an unexpected error (type&#x3D;Not Found, status&#x3D;404).No message available</code></pre><p>使用<code>post</code>响应内容</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1566707174774</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-number">404</span>,    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"Not Found"</span>,    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"No message available"</span>,    <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/user1"</span>&#125;</code></pre><p>它是如何实现的呢？来看看<code>BasicErrorController</code>类</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * Copyright 2012-2016 the original author or authors.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span><span class="hljs-comment"> * you may not use this file except in compliance with the License.</span><span class="hljs-comment"> * You may obtain a copy of the License at</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><span class="hljs-comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span><span class="hljs-comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="hljs-comment"> * See the License for the specific language governing permissions and</span><span class="hljs-comment"> * limitations under the License.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> org.springframework.boot.autoconfigure.web;<span class="hljs-meta">@Controller</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<span class="hljs-meta">@RequestMapping</span>(produces = <span class="hljs-string">"text/html"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request,</span></span><span class="hljs-function"><span class="hljs-params">HttpServletResponse response)</span> </span>&#123;HttpStatus status = getStatus(request);Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));response.setStatus(status.value());ModelAndView modelAndView = resolveErrorView(request, response, status, model);<span class="hljs-keyword">return</span> (modelAndView == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">"error"</span>, model) : modelAndView);&#125;<span class="hljs-meta">@RequestMapping</span><span class="hljs-meta">@ResponseBody</span><span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;Map&lt;String, Object&gt; body = getErrorAttributes(request,isIncludeStackTrace(request, MediaType.ALL));HttpStatus status = getStatus(request);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status);&#125;<span class="hljs-comment">//...</span>&#125;</code></pre><p><code>errorHtml</code>方法的上面<code>@RequestMapping(produces = &quot;text/html&quot;)</code>,这么有段代码，在浏览器中访问时，请求头就会带上<code>text/html</code>，所以它会自动走到这里面，如果不是浏览器访问，比如是<code>post man</code>或者APP通过http client来访问是不会带上<code>text/html</code>这样的请求头的，所以它会进error方法中，这个方法注解了<code>@ResponseBody</code>，也就是说，它会响应<code>json</code>格式的数据</p><p>这里我在<code>UserController</code>中再创一个接口</p><pre><code class="hljs java"><span class="hljs-meta">@PostMapping</span>(<span class="hljs-string">"/v2"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add2</span><span class="hljs-params">(@Valid @RequestBody UserVO userVO)</span> </span>&#123;       <span class="hljs-comment">//新增逻辑</span>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;   &#125;</code></pre><p>使用<code>post man</code>进行访问，这里传递一个空<code>json</code>，响应结果：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1566708165191</span>,    <span class="hljs-attr">"status"</span>: <span class="hljs-number">400</span>,    <span class="hljs-attr">"error"</span>: <span class="hljs-string">"Bad Request"</span>,    <span class="hljs-attr">"exception"</span>: <span class="hljs-string">"org.springframework.web.bind.MethodArgumentNotValidException"</span>,    <span class="hljs-attr">"errors"</span>: [        &#123;            <span class="hljs-attr">"codes"</span>: [                <span class="hljs-string">"NotBlank.userVO.password"</span>,                <span class="hljs-string">"NotBlank.password"</span>,                <span class="hljs-string">"NotBlank.java.lang.String"</span>,                <span class="hljs-string">"NotBlank"</span>            ],            <span class="hljs-attr">"arguments"</span>: [                &#123;                    <span class="hljs-attr">"codes"</span>: [                        <span class="hljs-string">"userVO.password"</span>,                        <span class="hljs-string">"password"</span>                    ],                    <span class="hljs-attr">"arguments"</span>: <span class="hljs-literal">null</span>,                    <span class="hljs-attr">"defaultMessage"</span>: <span class="hljs-string">"password"</span>,                    <span class="hljs-attr">"code"</span>: <span class="hljs-string">"password"</span>                &#125;            ],            <span class="hljs-attr">"defaultMessage"</span>: <span class="hljs-string">"不能为空"</span>,            <span class="hljs-attr">"objectName"</span>: <span class="hljs-string">"userVO"</span>,            <span class="hljs-attr">"field"</span>: <span class="hljs-string">"password"</span>,            <span class="hljs-attr">"rejectedValue"</span>: <span class="hljs-literal">null</span>,            <span class="hljs-attr">"bindingFailure"</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">"code"</span>: <span class="hljs-string">"NotBlank"</span>        &#125;    ],    <span class="hljs-attr">"message"</span>: <span class="hljs-string">"Validation failed for object='userVO'. Error count: 1"</span>,    <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/user/v2"</span>&#125;</code></pre><p>实现浏览器中如果出现404异常，就跳转到指定页面</p><p>在demo模块中创建<code>404.html</code>，当用户在浏览器中请求如果发生404，就会到这个页面上</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566712743738.png" srcset="/img/loading.gif" alt="1566712743738"></p><p>实现客户端访问接口出现异常，响应相关的提示json</p><p>创建一个自定义异常</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.exception;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserNotExistException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;    <span class="hljs-keyword">private</span> String id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserNotExistException</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-string">"user not exist"</span>);        <span class="hljs-keyword">this</span>.id = id;    &#125;&#125;</code></pre><p>在UserController中编写一个方法，直接抛出异常</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/v2"</span>)  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title">query2</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserNotExistException(<span class="hljs-string">"1"</span>);  &#125;</code></pre><p>编写一个处理<code>UserNotExistException</code>异常的处理器</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.controller;<span class="hljs-keyword">import</span> com.b4.mcr.exception.UserNotExistException;<span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@ControllerAdvice</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ControllerExceptionHandler</span> </span>&#123;    <span class="hljs-meta">@ExceptionHandler</span>(UserNotExistException<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">    @<span class="hljs-title">ResponseBody</span></span><span class="hljs-class">    @<span class="hljs-title">ResponseStatus</span>(<span class="hljs-title">HttpStatus</span>.<span class="hljs-title">INTERNAL_SERVER_ERROR</span>)</span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Object</span>&gt; <span class="hljs-title">handleUserNotExistException</span>(<span class="hljs-title">UserNotExistException</span> <span class="hljs-title">ex</span>) </span>&#123;        Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        result.put(<span class="hljs-string">"id"</span>, ex.getId());        result.put(<span class="hljs-string">"message"</span>, ex.getMessage());        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre><blockquote><p>这里通过ExceptionHandler注解来监听UserNotExistException异常，这里是可以监听多个的</p></blockquote><p>访问<a href="http://localhost:8080/user/v2，响应结果：" target="_blank" rel="noopener">http://localhost:8080/user/v2，响应结果：</a></p><pre><code class="hljs java">&#123;    <span class="hljs-string">"id"</span>: <span class="hljs-string">"1"</span>,    <span class="hljs-string">"message"</span>: <span class="hljs-string">"user not exist"</span>&#125;</code></pre><h1 id="拦截Rest服务"><a href="#拦截Rest服务" class="headerlink" title="拦截Rest服务"></a>拦截Rest服务</h1><p>在某些业务场景中，我们要对一些<code>restful api</code>做一些统一的处理，这里就可以使用拦截来实现，拦截的方式有3种：</p><ul><li>过滤器（Filter）</li><li>拦截器（Interceptor）</li><li>切片（Aspect）</li></ul><p>这里有个业务场景：记录所有的api处理时间</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> com.b4.mcr.web.filter;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> javax.servlet.Filter;<span class="hljs-keyword">import</span> javax.servlet.FilterChain;<span class="hljs-keyword">import</span> javax.servlet.FilterConfig;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.ServletRequest;<span class="hljs-keyword">import</span> javax.servlet.ServletResponse;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see javax.servlet.Filter#destroy()</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"time filter destroy"</span>);&#125;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse, javax.servlet.FilterChain)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;System.out.println(<span class="hljs-string">"time filter start"</span>);<span class="hljs-keyword">long</span> start = <span class="hljs-keyword">new</span> Date().getTime();chain.doFilter(request, response);System.out.println(<span class="hljs-string">"time filter 耗时:"</span>+ (<span class="hljs-keyword">new</span> Date().getTime() - start));System.out.println(<span class="hljs-string">"time filter finish"</span>);&#125;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see javax.servlet.Filter#init(javax.servlet.FilterConfig)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig arg0)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;System.out.println(<span class="hljs-string">"time filter init"</span>);&#125;&#125;</code></pre><blockquote><p>笔者这里使用了    <code>System.out.println()</code>，在实际开发中建议使用logger，因为它有锁，影响性能</p></blockquote><p>这样是针对所有接口去拦截，现在可能希望只针对一些接口去拦截该怎么做？首先去除TimeFilter类的Component注解，然后编写一个Config类，进行配置，这样做有什么好处？比如你希望这个过滤器只在开发、测试环境上使用，而生产环境中不使用，就可以通过Profile注解来控制，这里读者不会去介绍Profile注解，感兴趣去百度吧~</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.config;<span class="hljs-keyword">import</span> com.b4.mcr.web.filter.TimeFilter;<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">timeFilter</span><span class="hljs-params">()</span> </span>&#123;        FilterRegistrationBean registrationbean = <span class="hljs-keyword">new</span> FilterRegistrationBean(<span class="hljs-keyword">new</span> TimeFilter());        registrationbean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));        <span class="hljs-keyword">return</span> registrationbean;    &#125;&#125;</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>之前通过<code>Filter</code>来拦截，但是这有个问题，它只能拿到http的请求和响应，这里希望能知道这个请求是哪个控制器的方法来处理的，通过上面的<code>Filter</code>是无法实现的，这样的场景可以通过拦截器来实现</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.interceptor;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.method.HandlerMethod;<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see org.springframework.web.servlet.HandlerInterceptor#preHandle(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.Object)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"preHandle"</span>);System.out.println(((HandlerMethod)handler).getBean().getClass().getName());System.out.println(((HandlerMethod)handler).getMethod().getName());request.setAttribute(<span class="hljs-string">"startTime"</span>, <span class="hljs-keyword">new</span> Date().getTime());<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see org.springframework.web.servlet.HandlerInterceptor#postHandle(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.Object, org.springframework.web.servlet.ModelAndView)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><span class="hljs-function"><span class="hljs-params">ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"postHandle"</span>);Long start = (Long) request.getAttribute(<span class="hljs-string">"startTime"</span>);System.out.println(<span class="hljs-string">"time interceptor 耗时:"</span>+ (<span class="hljs-keyword">new</span> Date().getTime() - start));&#125;<span class="hljs-comment">/* (non-Javadoc)</span><span class="hljs-comment"> * @see org.springframework.web.servlet.HandlerInterceptor#afterCompletion(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.Object, java.lang.Exception)</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"afterCompletion"</span>);Long start = (Long) request.getAttribute(<span class="hljs-string">"startTime"</span>);System.out.println(<span class="hljs-string">"time interceptor 耗时:"</span>+ (<span class="hljs-keyword">new</span> Date().getTime() - start));System.out.println(<span class="hljs-string">"ex is "</span>+ex);&#125;&#125;</code></pre><p>方法介绍：</p><ul><li>preHandle：它的返回值决定了后面的api是不是要执行，返回true：执行，false：被拦截，不执行了</li><li>postHandle：post请求执行的方法，在api执行之后，执行此方法</li><li>afterCompletion：其他请求方式执行的方法，在api执行之后，执行此方法</li></ul><p>这里通过@Component还没生效，还需要在配置类中进行配置</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> TimeInterceptor timeInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        <span class="hljs-keyword">super</span>.addInterceptors(registry);        registry.addInterceptor(timeInterceptor);    &#125;    <span class="hljs-comment">//..</span>&#125;</code></pre><p>浏览器中请求<a href="http://localhost:8080/user/v2" target="_blank" rel="noopener">http://localhost:8080/user/v2</a></p><p>控制台输出：</p><pre><code class="hljs java">preHandlecom.b4.mcr.web.controller.UserControllerquery2<span class="hljs-number">2019</span>-<span class="hljs-number">08</span>-<span class="hljs-number">25</span> <span class="hljs-number">15</span>:<span class="hljs-number">09</span>:<span class="hljs-number">57.339</span>  WARN <span class="hljs-number">13856</span> --- [nio-<span class="hljs-number">8080</span>-exec-<span class="hljs-number">2</span>] .m.m.a.ExceptionHandlerExceptionResolver : Resolved exception caused by Handler execution: UserNotExistException(id=<span class="hljs-number">1</span>)afterCompletiontime interceptor 耗时:<span class="hljs-number">1</span>ex is <span class="hljs-keyword">null</span></code></pre><p>这里的/user/v2中抛出了一个UserNotExistException异常</p><pre><code class="hljs java"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/v2"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title">query2</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserNotExistException(<span class="hljs-string">"1"</span>);   &#125;</code></pre><p>这是因为，这个UserNotExistException被ControllerExceptionHandler检测，所以就拿不到了，这里要注意一下</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>之前使用拦截器方式拿到了处理器中的方法，但是还是有问题，它拿不到方法中的参数，来看下<code>DispatcherServlet#doService</code>方法的内容</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;doDispatch(request, response);&#125;</code></pre><p>它这里会调用doDispatch方法，来看下doDispatch的这段代码</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">// Actually invoke the handler.</span>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre><p>这里通过<code>mappedHandler</code>调用了<code>applyPreHandle</code>方法并传递了<code>request</code>，<code>response</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">applyPreHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;HandlerInterceptor[] interceptors = getInterceptors();<span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; interceptors.length; i++) &#123;HandlerInterceptor interceptor = interceptors[i];<span class="hljs-keyword">if</span> (!interceptor.preHandle(request, response, <span class="hljs-keyword">this</span>.handler)) &#123;triggerAfterCompletion(request, response, <span class="hljs-keyword">null</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">this</span>.interceptorIndex = i;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p>它这里拿到所有的拦截器，然后遍历调用<code>preHandle</code>方法，这样一来就能调用我们写的<code>TimeInterceptor#preHandle</code>方法了，如果返回<code>false</code>，这里的<code>mappedHandler</code>对象的<code>applyPreHandle</code>也会返回<code>false</code>，然后在<code>DispatcherServlet#doDispatch</code>就直接返回，不在往下走了，也就不会执行    <code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>了，这里也就是调用处理器的方法不被执行，这就是在<code>TimeInterceptor#preHandle</code>方法中返回<code>false</code>，就不会执行api的原因，然后再说下拦截器为什么拿不到处理器方法的参数？——请看</p><pre><code class="hljs java">mappedHandler.applyPreHandle(processedRequest, response)</code></pre><p>这是不是只传了request、response，而没传递handler参数，所以在这个时候，handler是空的</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></code></pre><p>这个handler参数是在执行了这段代码才拿到的，所以说<code>preHandle</code>并不知道参数长成什么丫子的</p><pre><code class="hljs java">mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</code></pre><hr><p>通过切片就可以满足这样的业务需求，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.aspect;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeAspect</span> </span>&#123;<span class="hljs-meta">@Around</span>(<span class="hljs-string">"execution(* com.b4.mcr.web.controller.*.*(..))"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">handleControllerMethod</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;System.out.println(<span class="hljs-string">"time aspect start"</span>);Object[] args = pjp.getArgs();<span class="hljs-keyword">for</span> (Object arg : args) &#123;System.out.println(<span class="hljs-string">"arg is "</span>+arg);&#125;<span class="hljs-keyword">long</span> start = <span class="hljs-keyword">new</span> Date().getTime();Object object = pjp.proceed();System.out.println(<span class="hljs-string">"time aspect 耗时:"</span>+ (<span class="hljs-keyword">new</span> Date().getTime() - start));System.out.println(<span class="hljs-string">"time aspect end"</span>);<span class="hljs-keyword">return</span> object;&#125;&#125;</code></pre><p>使用<code>post man</code>发送请求</p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566719187552.png" srcset="/img/loading.gif" alt="1566719187552"></p><p>控制台输出：</p><pre><code class="hljs pgsql">t1<span class="hljs-type">time</span> aspect <span class="hljs-keyword">start</span>arg <span class="hljs-keyword">is</span> UserVO(userName=t1, <span class="hljs-keyword">password</span>=t1)<span class="hljs-type">time</span> aspect 耗时:<span class="hljs-number">0</span><span class="hljs-type">time</span> aspect <span class="hljs-keyword">end</span></code></pre><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566719359465.png" srcset="/img/loading.gif" alt="1566719359465"></p><h1 id="Swagger文档"><a href="#Swagger文档" class="headerlink" title="Swagger文档"></a>Swagger文档</h1><blockquote><p>笔者正在补充~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 一、Restful Api 】  2.Hello Spring Security</title>
    <link href="/spring-security-1.2.html"/>
    <url>/spring-security-1.2.html</url>
    
    <content type="html"><![CDATA[<p>在<code>demo</code>中编写<code>Application</code>并启动</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">McrAuthDemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(McrAuthDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>启动中出现一个异常，原因是在<code>core</code>中依赖了<code>spring-sesion</code></p><pre><code class="hljs routeros">019-08-24 13:46:59.655 <span class="hljs-builtin-name">ERROR</span> 27780 --- [ost-startStop-1] o.s.b.web.embedded.tomcat.TomcatStarter  : <span class="hljs-builtin-name">Error</span> starting Tomcat context. Exception: org.springframework.beans.factory.UnsatisfiedDependencyException. Message: <span class="hljs-builtin-name">Error</span> creating bean with name <span class="hljs-string">'sessionRepositoryFilterRegistration'</span> defined <span class="hljs-keyword">in</span> class path<span class="hljs-built_in"> resource </span>[org/springframework/boot/autoconfigure/session/SessionRepositoryFilterConfiguration.class]: Unsatisfied dependency expressed through method <span class="hljs-string">'sessionRepositoryFilterRegistration'</span> parameter 1; nested exception is org.springframework.beans.factory.BeanCreationException: <span class="hljs-builtin-name">Error</span> creating bean with name <span class="hljs-string">'org.springframework.boot.autoconfigure.session.JdbcSessionConfiguration$SpringBootJdbcHttpSessionConfiguration'</span>: Injection of autowired dependencies failed; nested exception is java.lang.NoSuchMethodError: org.springframework.boot.autoconfigure.session.JdbcSessionConfiguration<span class="hljs-variable">$SpringBootJdbcHttpSessionConfiguration</span>.setCleanupCron(Ljava/lang/String;)V</code></pre><p>这里配置一下<code>demo</code>模块的配置文件，再次启动就不会出现异常了</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">session:</span>    <span class="hljs-attr">store-type:</span> <span class="hljs-string">none</span></code></pre><p>首先编写一个<code>controller</code>进行测试</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.b4.mcr.web.controller;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/test"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"test"</span>;    &#125;&#125;</code></pre><p><em>访问</em><a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a></p><p><img src="https://shui-blog.oss-cn-shenzhen.aliyuncs.com/img/1/1566658180434.png" srcset="/img/loading.gif" alt="1566658180434"></p><blockquote><p>spring boot会提供一些默认的spring security配置，所以在进行访问api时会进行拦截</p></blockquote><p>在章节开始，笔者不会直接去讲spring security的内容，而会去说一些Web的相关知识，所以把spring boot提供的配置禁用一下</p><hr><p><code>application.yml</code></p><pre><code class="hljs yaml"><span class="hljs-attr">security:</span>  <span class="hljs-attr">basic:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【 一、Restful Api 】  1.代码结构介绍</title>
    <link href="/spring-security-1.1.html"/>
    <url>/spring-security-1.1.html</url>
    
    <content type="html"><![CDATA[<h1 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h1><p>笔者使用的是<code>maven</code>进行构建的工程，这里给读者们介绍一下模块的含义以及<code>pom.xml</code>中所需要的依赖</p><table><thead><tr><th align="center">模块</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">mcr-auth</td><td align="center">主模块</td></tr><tr><td align="center">mcr-auth-core</td><td align="center">核心业务逻辑</td></tr><tr><td align="center">mcr-auth-browser</td><td align="center">浏览器安全特定代码</td></tr><tr><td align="center">mcr-auth-app</td><td align="center">app相关特定代码</td></tr><tr><td align="center">mcr-auth-demo</td><td align="center">样例程序</td></tr></tbody></table><h1 id="mcr-auth"><a href="#mcr-auth" class="headerlink" title="mcr-auth"></a>mcr-auth</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mcr.version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">mcr.version</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.17<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.spring.platform<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>platform-bom<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Brussels-SR4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Dalston.SR2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>         <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre><h1 id="mcr-auth-core"><a href="#mcr-auth-core" class="headerlink" title="mcr-auth-core"></a>mcr-auth-core</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-comment">&lt;!-- &lt;dependency&gt;</span><span class="hljs-comment">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><span class="hljs-comment">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><span class="hljs-comment">    &lt;/dependency&gt;--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.social<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-social-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.social<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-social-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.social<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-social-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.social<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-social-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-beanutils<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h1 id="mcr-auth-browser"><a href="#mcr-auth-browser" class="headerlink" title="mcr-auth-browser"></a>mcr-auth-browser</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mcr.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h1 id="mcr-auth-app"><a href="#mcr-auth-app" class="headerlink" title="mcr-auth-app"></a>mcr-auth-app</h1><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;mcr.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><h1 id="mcr-auth-demo"><a href="#mcr-auth-demo" class="headerlink" title="mcr-auth-demo"></a>mcr-auth-demo</h1><h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.b4<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mcr-auth-browser<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.tomakehurst<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wiremock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                       <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>demo<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a><strong>application.yml</strong></h2><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://mcr.com:3306/mcr?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
      <category>SpringSecurity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
